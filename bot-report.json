{
  "reportUid": "iGxcnzUQ3Q4",
  "labels": [
    {
      "name": "QA (Quality Assurance)",
      "color": "1D76DB"
    }
  ],
  "comment": "LightChaser-V3",
  "footnote": "V4 wen?",
  "findings": [
    {
      "severity": "Low",
      "title": "Potential division by zero should have zero checks in place ",
      "description": "Implement a zero address check for found instances",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n132:     function _calculatePaymentProRata(\n133:         uint256 amount,\n134:         uint256 elapsedTime,\n135:         uint256 totalTime\n136:     ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n137:         \n138:         uint256 numerator = (amount * elapsedTime) * 1000;\n139: \n140:         \n141:         \n142:         renterAmount = ((numerator / totalTime) + 500) / 1000;\n143: \n144:         \n145:         lenderAmount = amount - renterAmount;\n146:     }\n\n```\n",
          "loc": [
            "[132](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L132-L132)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Missing checks for address(0x0) when updating address state variables ",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n277:     function executeAction(Actions action_, address target_) external onlyExecutor {\n278:         if (action_ == Actions.InstallModule) {\n279:             ensureContract(target_);\n280:             ensureValidKeycode(Module(target_).KEYCODE());\n281:             _installModule(Module(target_));\n282:         } else if (action_ == Actions.UpgradeModule) {\n283:             ensureContract(target_);\n284:             ensureValidKeycode(Module(target_).KEYCODE());\n285:             _upgradeModule(Module(target_));\n286:         } else if (action_ == Actions.ActivatePolicy) {\n287:             ensureContract(target_);\n288:             _activatePolicy(Policy(target_));\n289:         } else if (action_ == Actions.DeactivatePolicy) {\n290:             ensureContract(target_);\n291:             _deactivatePolicy(Policy(target_));\n292:         } else if (action_ == Actions.MigrateKernel) {\n293:             ensureContract(target_);\n294:             _migrateKernel(Kernel(target_));\n295:         } else if (action_ == Actions.ChangeExecutor) {\n296:             executor = target_; // <= FOUND\n297:         } else if (action_ == Actions.ChangeAdmin) {\n298:             admin = target_; // <= FOUND\n299:         }\n300: \n301:         emit Events.ActionExecuted(action_, target_);\n302:     }\n\n```\n",
          "loc": [
            "[277](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L277-L298)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Assembly block creates dirty bits ",
      "description": "Manipulating data directly at the free memory pointer location without subsequently adjusting the pointer can lead to unwanted data remnants, or \"dirty bits\", in that memory spot. This can cause challenges for the Solidity optimizer, making it difficult to determine if memory cleaning is required before reuse, potentially resulting in less efficient optimization. To mitigate this issue, it's advised to always update the free memory pointer following any data write operation. Furthermore, using the `assembly (\"memory-safe\") { ... }` annotation will clearly indicate to the optimizer the sections of your code that are memory-safe, improving code efficiency and reducing the potential for errors.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n40:         assembly {\n41:             \n42:             if eq(mload(rentalAssets), 0) {\n43:                 \n44:                 mstore(rentalAssets, 0x20)\n45: \n46:                 \n47:                 mstore(add(0x20, rentalAssets), 0x00)\n48:             }\n49: \n50:             \n51:             \n52:             let newByteDataSize := add(mload(rentalAssets), 0x40) // <= FOUND\n53: \n54:             \n55:             let rentalAssetElementPtr := add(rentalAssets, 0x20)\n56: \n57:             \n58:             let elements := add(mload(rentalAssetElementPtr), 1)\n59: \n60:             \n61:             \n62:             \n63:             \n64:             let newItemPosition := add(\n65:                 rentalAssetElementPtr,\n66:                 sub(mul(elements, 0x40), 0x20) // <= FOUND\n67:             )\n68: \n69:             \n70:             mstore(rentalAssets, newByteDataSize)\n71: \n72:             \n73:             mstore(rentalAssetElementPtr, elements)\n74: \n75:             \n76:             mstore(newItemPosition, _rentalId)\n77: \n78:             \n79:             mstore(add(newItemPosition, 0x20), rentalAssetAmount)\n80: \n81:             \n82:             \n83:             mstore(0x40, add(newItemPosition, 0x40)) // <= FOUND\n84:         }\n\n```\n",
          "loc": [
            "[52](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L52-L83)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Cyclomatic complexity in functions ",
      "description": "Cyclomatic complexity is a software metric used to measure the complexity of a program. It quantifies the number of linearly independent paths through a program's source code, giving an idea of how complex the control flow is. High cyclomatic complexity may indicate a higher risk of defects and can make the code harder to understand, test, and maintain. It often suggests that a function or method is trying to do too much, and a refactor might be needed. By breaking down complex functions into smaller, more focused pieces, you can improve readability, ease of testing, and overall maintainability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n195:     function _checkTransaction(address from, address to, bytes memory data) private view { // <= FOUND\n196:         bytes4 selector;\n197: \n198:         \n199:         assembly {\n200:             selector := mload(add(data, 0x20))\n201:         }\n202: \n203:         if (selector == e721_safe_transfer_from_1_selector) {\n204:             \n205:             uint256 tokenId = uint256(\n206:                 _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset)\n207:             );\n208: \n209:             \n210:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n211:         } else if (selector == e721_safe_transfer_from_2_selector) {\n212:             \n213:             uint256 tokenId = uint256(\n214:                 _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset)\n215:             );\n216: \n217:             \n218:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n219:         } else if (selector == e721_transfer_from_selector) {\n220:             \n221:             uint256 tokenId = uint256(\n222:                 _loadValueFromCalldata(data, e721_transfer_from_token_id_offset)\n223:             );\n224: \n225:             \n226:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n227:         } else if (selector == e721_approve_selector) {\n228:             \n229:             uint256 tokenId = uint256(\n230:                 _loadValueFromCalldata(data, e721_approve_token_id_offset)\n231:             );\n232: \n233:             \n234:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n235:         } else if (selector == e1155_safe_transfer_from_selector) {\n236:             \n237:             uint256 tokenId = uint256(\n238:                 _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n239:             );\n240: \n241:             \n242:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n243:         } else if (selector == gnosis_safe_enable_module_selector) {\n244:             \n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L195)"
          ]
        },
        {
          "content": "```solidity\n277:     function executeAction(Actions action_, address target_) external onlyExecutor { // <= FOUND\n278:         if (action_ == Actions.InstallModule) {\n279:             ensureContract(target_);\n280:             ensureValidKeycode(Module(target_).KEYCODE());\n281:             _installModule(Module(target_));\n282:         } else if (action_ == Actions.UpgradeModule) {\n283:             ensureContract(target_);\n284:             ensureValidKeycode(Module(target_).KEYCODE());\n285:             _upgradeModule(Module(target_));\n286:         } else if (action_ == Actions.ActivatePolicy) {\n287:             ensureContract(target_);\n288:             _activatePolicy(Policy(target_));\n289:         } else if (action_ == Actions.DeactivatePolicy) {\n290:             ensureContract(target_);\n291:             _deactivatePolicy(Policy(target_));\n292:         } else if (action_ == Actions.MigrateKernel) {\n293:             ensureContract(target_);\n294:             _migrateKernel(Kernel(target_));\n295:         } else if (action_ == Actions.ChangeExecutor) {\n296:             executor = target_;\n297:         } else if (action_ == Actions.ChangeAdmin) {\n298:             admin = target_;\n299:         }\n300: \n301:         emit Events.ActionExecuted(action_, target_);\n302:     }\n\n```\n",
          "loc": [
            "[277](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L277-L277)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Code does not follow the best practice of check-effects-interaction ",
      "description": "The \"check-effects-interaction\" pattern is a best practice in smart contract development, emphasizing the order of operations in functions to prevent reentrancy attacks. Violations arise when a function interacts with external contracts before settling internal state changes or checks. This misordering can expose the contract to potential threats. To adhere to this pattern, first ensure all conditions or checks are satisfied, then update any internal states, and only after these steps, interact with external contracts or addresses. Rearranging operations to this recommended sequence bolsters contract security and aligns with established best practices in the Ethereum community.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n277:     function executeAction(Actions action_, address target_) external onlyExecutor { // <= FOUND\n278:         if (action_ == Actions.InstallModule) {\n279:             ensureContract(target_);\n280:             ensureValidKeycode(Module(target_).KEYCODE()); // <= FOUND\n281:             _installModule(Module(target_));\n282:         } else if (action_ == Actions.UpgradeModule) {\n283:             ensureContract(target_);\n284:             ensureValidKeycode(Module(target_).KEYCODE()); // <= FOUND\n285:             _upgradeModule(Module(target_));\n286:         } else if (action_ == Actions.ActivatePolicy) {\n287:             ensureContract(target_);\n288:             _activatePolicy(Policy(target_));\n289:         } else if (action_ == Actions.DeactivatePolicy) {\n290:             ensureContract(target_);\n291:             _deactivatePolicy(Policy(target_));\n292:         } else if (action_ == Actions.MigrateKernel) {\n293:             ensureContract(target_);\n294:             _migrateKernel(Kernel(target_));\n295:         } else if (action_ == Actions.ChangeExecutor) {\n296:             executor = target_;\n297:         } else if (action_ == Actions.ChangeAdmin) {\n298:             admin = target_;\n299:         }\n300: \n301:         emit Events.ActionExecuted(action_, target_);\n302:     }\n\n```\n",
          "loc": [
            "[277](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L277-L284)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Events may be emitted out of order due to code not follow the best practice of check-effects-interaction ",
      "description": "The \"check-effects-interaction\" pattern also impacts event ordering. When a contract doesn't adhere to this pattern, events might be emitted in a sequence that doesn't reflect the actual logical flow of operations. This can cause confusion during event tracking, potentially leading to erroneous off-chain interpretations. To rectify this, always ensure that checks are performed first, state modifications come next, and interactions with external contracts or addresses are done last. This will ensure events are emitted in a logical, consistent manner, providing a clear and accurate chronological record of on-chain actions for off-chain systems and observers.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n277:     function executeAction(Actions action_, address target_) external onlyExecutor { // <= FOUND\n278:         if (action_ == Actions.InstallModule) {\n279:             ensureContract(target_);\n280:             ensureValidKeycode(Module(target_).KEYCODE()); // <= FOUND\n281:             _installModule(Module(target_));\n282:         } else if (action_ == Actions.UpgradeModule) {\n283:             ensureContract(target_);\n284:             ensureValidKeycode(Module(target_).KEYCODE()); // <= FOUND\n285:             _upgradeModule(Module(target_));\n286:         } else if (action_ == Actions.ActivatePolicy) {\n287:             ensureContract(target_);\n288:             _activatePolicy(Policy(target_));\n289:         } else if (action_ == Actions.DeactivatePolicy) {\n290:             ensureContract(target_);\n291:             _deactivatePolicy(Policy(target_));\n292:         } else if (action_ == Actions.MigrateKernel) {\n293:             ensureContract(target_);\n294:             _migrateKernel(Kernel(target_));\n295:         } else if (action_ == Actions.ChangeExecutor) {\n296:             executor = target_;\n297:         } else if (action_ == Actions.ChangeAdmin) {\n298:             admin = target_;\n299:         }\n300: \n301:         emit Events.ActionExecuted(action_, target_); // <= FOUND\n302:     }\n\n```\n",
          "loc": [
            "[277](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L277-L301)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "For extended 'using-for' usage, use the latest pragma version ",
      "description": "Solidity versions of 0.8.13 or above can make use of enhanced using-for notation within contracts.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase \n\n```\n",
          "loc": [
            ""
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase \n\n```\n",
          "loc": [
            ""
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator \n\n```\n",
          "loc": [
            ""
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator \n\n```\n",
          "loc": [
            ""
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider merging sequential for loops ",
      "description": "Merging multiple `for` loops within a function in Solidity can enhance efficiency and reduce gas costs, especially when they share a common iterating variable or perform related operations. By minimizing redundant iterations over the same data set, execution becomes more cost-effective. However, while merging can optimize gas usage and simplify logic, it may also increase code complexity. Therefore, careful balance between optimization and maintainability is essential, along with thorough testing to ensure the refactored code behaves as expected.\n",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n530:     function _rentFromZone(\n531:         RentPayload memory payload,\n532:         SeaportPayload memory seaportPayload\n533:     ) internal {\n534:         \n535:         _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n536: \n537:         \n538:         _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n539: \n540:         \n541:         _executionInvariantChecks(\n542:             seaportPayload.totalExecutions,\n543:             payload.fulfillment.recipient\n544:         );\n545: \n546:         \n547:         \n548:         Item[] memory items = _convertToItems(\n549:             seaportPayload.offer,\n550:             seaportPayload.consideration,\n551:             payload.metadata.orderType\n552:         );\n553: \n554:         \n555:         \n556:         if (\n557:             payload.metadata.orderType.isBaseOrder() ||\n558:             payload.metadata.orderType.isPayOrder()\n559:         ) {\n560:             \n561:             \n562:             \n563:             bytes memory rentalAssetUpdates = new bytes(0);\n564: \n565:             \n566:             \n567:             for (uint256 i; i < items.length; ++i) { // <= FOUND\n568:                 if (items[i].isRental()) {\n569:                     \n570:                     _insert(\n571:                         rentalAssetUpdates,\n572:                         items[i].toRentalId(payload.fulfillment.recipient),\n573:                         items[i].amount\n574:                     );\n575:                 }\n576:             }\n577: \n578:             \n579:             RentalOrder memory order = RentalOrder({\n580:                 seaportOrderHash: seaportPayload.orderHash,\n581:                 items: items,\n582:                 hooks: payload.metadata.hooks,\n583:                 orderType: payload.metadata.orderType,\n584:                 lender: seaportPayload.offerer,\n585:                 renter: payload.intendedFulfiller,\n586:                 rentalWallet: payload.fulfillment.recipient,\n587:                 startTimestamp: block.timestamp,\n588:                 endTimestamp: block.timestamp + payload.metadata.rentDuration\n589:             });\n590: \n591:             \n592:             bytes32 orderHash = _deriveRentalOrderHash(order);\n593: \n594:             \n595:             STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n596: \n597:             \n598:             \n599:             for (uint256 i = 0; i < items.length; ++i) { // <= FOUND\n600:                 if (items[i].isERC20()) {\n601:                     ESCRW.increaseDeposit(items[i].token, items[i].amount);\n602:                 }\n603:             }\n604: \n605:             \n606:             if (payload.metadata.hooks.length > 0) {\n607:                 _addHooks(\n608:                     payload.metadata.hooks,\n609:                     seaportPayload.offer,\n610:                     payload.fulfillment.recipient\n611:                 );\n612:             }\n613: \n614:             \n615:             _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n616:         }\n617:     }\n\n```\n",
          "loc": [
            "[530](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530-L599)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Lack of unchecked in loops ",
      "description": "In Solidity, the `unchecked` block allows arithmetic operations to not revert on overflow. Without using `unchecked` in loops, extra gas is consumed due to overflow checks. If it's certain that overflows won't occur within the loop, using `unchecked` can make the loop more gas-efficient by skipping unnecessary checks.",
      "gasSavings": 1560,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n231:        for (uint256 i = 0; i < items.length; ++i) {\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n281:             }\n282:         }\n\n```\n",
          "loc": [
            "[231](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L231-L231)"
          ]
        },
        {
          "content": "```solidity\n341:        for (uint256 i = 0; i < orders.length; ++i) {\n342:             \n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L341-L341)"
          ]
        },
        {
          "content": "```solidity\n197:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n198:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n199: \n200:             \n201:             rentedAssets[asset.rentalId] += asset.amount;\n202:         }\n\n```\n",
          "loc": [
            "[197](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n249:        for (uint256 i = 0; i < orderHashes.length; ++i) {\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n\n```\n",
          "loc": [
            "[249](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L249-L249)"
          ]
        },
        {
          "content": "```solidity\n170:        for (uint256 i = 0; i < order.items.length; ++i) {\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n\n```\n",
          "loc": [
            "[170](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L170-L170)"
          ]
        },
        {
          "content": "```solidity\n225:        for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n226:             \n227:             hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n228:         }\n\n```\n",
          "loc": [
            "[225](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L225-L225)"
          ]
        },
        {
          "content": "```solidity\n261:        for (uint256 i; i < offers.length; ++i) {\n262:             \n263:             SpentItem memory offer = offers[i];\n264: \n265:             \n266:             if (offer.isERC721()) {\n267:                 \n268:                 \n269:                 itemType = ItemType.ERC721;\n270:                 settleTo = SettleTo.LENDER;\n271: \n272:                 \n273:                 totalRentals++;\n274:             }\n275:             \n276:             else if (offer.isERC1155()) {\n277:                 \n278:                 \n279:                 itemType = ItemType.ERC1155;\n280:                 settleTo = SettleTo.LENDER;\n281: \n282:                 \n283:                 totalRentals++;\n284:             }\n285:             \n286:             else if (offer.isERC20()) {\n287:                 \n288:                 \n289:                 itemType = ItemType.ERC20;\n290:                 settleTo = SettleTo.RENTER;\n291: \n292:                 \n293:                 totalPayments++;\n294:             }\n295:             \n296:             else {\n297:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n298:             }\n299: \n300:             \n301:             rentalItems[i + startIndex] = Item({\n302:                 itemType: itemType,\n303:                 settleTo: settleTo,\n304:                 token: offer.token,\n305:                 amount: offer.amount,\n306:                 identifier: offer.identifier\n307:             });\n308:         }\n\n```\n",
          "loc": [
            "[261](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L261-L261)"
          ]
        },
        {
          "content": "```solidity\n375:        for (uint256 i; i < considerations.length; ++i) {\n376:             \n377:             ReceivedItem memory consideration = considerations[i];\n378: \n379:             \n380:             if (consideration.isERC20()) {\n381:                 totalPayments++;\n382:             }\n383:             \n384:             else if (consideration.isRental()) {\n385:                 totalRentals++;\n386:             }\n387:             \n388:             else {\n389:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n390:                     consideration.itemType\n391:                 );\n392:             }\n393:         }\n\n```\n",
          "loc": [
            "[375](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L375-L375)"
          ]
        },
        {
          "content": "```solidity\n475:        for (uint256 i = 0; i < hooks.length; ++i) {\n476:             \n477:             target = hooks[i].target;\n478: \n479:             \n480:             if (!STORE.hookOnStart(target)) {\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             \n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             \n488:             offer = offerItems[itemIndex];\n489: \n490:             \n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             \n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 \n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) {\n508:                 \n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 \n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n514:                 );\n515:             } catch (bytes memory revertData) {\n516:                 \n517:                 revert Errors.Shared_HookFailBytes(revertData);\n518:             }\n519:         }\n\n```\n",
          "loc": [
            "[475](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L475-L475)"
          ]
        },
        {
          "content": "```solidity\n695:        for (uint256 i = 0; i < executions.length; ++i) {\n696:             ReceivedItem memory execution = executions[i];\n697: \n698:             \n699:             if (execution.isERC20()) {\n700:                 _checkExpectedRecipient(execution, address(ESCRW));\n701:             }\n702:             \n703:             \n704:             else if (execution.isRental()) {\n705:                 _checkExpectedRecipient(execution, expectedRentalSafe);\n706:             }\n707:             \n708:             else {\n709:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n710:                     execution.itemType\n711:                 );\n712:             }\n713:         }\n\n```\n",
          "loc": [
            "[695](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L695-L695)"
          ]
        },
        {
          "content": "```solidity\n205:        for (uint256 i = 0; i < hooks.length; ++i) {\n206:             \n207:             target = hooks[i].target;\n208: \n209:             \n210:             if (!STORE.hookOnStop(target)) {\n211:                 revert Errors.Shared_DisabledHook(target);\n212:             }\n213: \n214:             \n215:             itemIndex = hooks[i].itemIndex;\n216: \n217:             \n218:             item = rentalItems[itemIndex];\n219: \n220:             \n221:             if (!item.isRental()) {\n222:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n223:             }\n224: \n225:             \n226:             try\n227:                 IHook(target).onStop(\n228:                     rentalWallet,\n229:                     item.token,\n230:                     item.identifier,\n231:                     item.amount,\n232:                     hooks[i].extraData\n233:                 )\n234:             {} catch Error(string memory revertReason) {\n235:                 \n236:                 revert Errors.Shared_HookFailString(revertReason);\n237:             } catch Panic(uint256 errorCode) {\n238:                 \n239:                 string memory stringErrorCode = LibString.toString(errorCode);\n240: \n241:                 \n242:                 revert Errors.Shared_HookFailString(\n243:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n244:                 );\n245:             } catch (bytes memory revertData) {\n246:                 \n247:                 revert Errors.Shared_HookFailBytes(revertData);\n248:             }\n249:         }\n\n```\n",
          "loc": [
            "[205](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L205-L205)"
          ]
        },
        {
          "content": "```solidity\n276:        for (uint256 i; i < order.items.length; ++i) {\n277:             if (order.items[i].isRental()) {\n278:                 \n279:                 _insert(\n280:                     rentalAssetUpdates,\n281:                     order.items[i].toRentalId(order.rentalWallet),\n282:                     order.items[i].amount\n283:                 );\n284:             }\n285:         }\n\n```\n",
          "loc": [
            "[276](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L276-L276)"
          ]
        },
        {
          "content": "```solidity\n324:        for (uint256 i = 0; i < orders.length; ++i) {\n325:             \n326:             _validateRentalCanBeStoped(\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             \n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) {\n334:                 \n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert(\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             \n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n346: \n347:             \n348:             if (orders[i].hooks.length > 0) {\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n350:             }\n351: \n352:             \n353:             _reclaimRentedItems(orders[i]);\n354: \n355:             \n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:         }\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L324)"
          ]
        },
        {
          "content": "```solidity\n438:        for (uint256 i; i < depLength; ++i) {\n439:             Keycode keycode = dependencies[i];\n440: \n441:             \n442:             moduleDependents[keycode].push(policy_);\n443: \n444:             \n445:             getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n446:         }\n\n```\n",
          "loc": [
            "[438](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L438-L438)"
          ]
        },
        {
          "content": "```solidity\n512:        for (uint256 i; i < keycodeLen; ++i) {\n513:             \n514:             Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n515:             \n516:             module.changeKernel(newKernel_);\n517:         }\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L512-L512)"
          ]
        },
        {
          "content": "```solidity\n546:        for (uint256 i; i < depLength; ++i) {\n547:             \n548:             dependents[i].configureDependencies();\n549:         }\n\n```\n",
          "loc": [
            "[546](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L546-L546)"
          ]
        },
        {
          "content": "```solidity\n566:        for (uint256 i = 0; i < reqLength; ++i) {\n567:             \n568:             Permissions memory request = requests_[i];\n569:             modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n570: \n571:             emit Events.PermissionsUpdated(\n572:                 request.keycode,\n573:                 policy_,\n574:                 request.funcSelector,\n575:                 grant_\n576:             );\n577:         }\n\n```\n",
          "loc": [
            "[566](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L566-L566)"
          ]
        },
        {
          "content": "```solidity\n592:        for (uint256 i; i < depcLength; ++i) {\n593:             \n594:             Keycode keycode = dependencies[i];\n595:             Policy[] storage dependents = moduleDependents[keycode];\n596: \n597:             \n598:             uint256 origIndex = getDependentIndex[keycode][policy_];\n599: \n600:             \n601:             Policy lastPolicy = dependents[dependents.length - 1];\n602: \n603:             \n604:             dependents[origIndex] = lastPolicy;\n605: \n606:             \n607:             \n608:             dependents.pop();\n609: \n610:             \n611:             getDependentIndex[keycode][lastPolicy] = origIndex;\n612: \n613:             \n614:             delete getDependentIndex[keycode][policy_];\n615:         }\n\n```\n",
          "loc": [
            "[592](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L592-L592)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Multiple accesses of the same mapping/array key/index should be cached ",
      "description": "Caching repeated accesses to the same mapping or array key/index in smart contracts can lead to significant gas savings. In Solidity, each read operation from storage (like accessing a value in a mapping or array using a key or index) costs gas. By storing the accessed value in a local variable and reusing it within the function, you avoid multiple expensive storage read operations. This practice is particularly beneficial in loops or functions with multiple reads of the same data. Implementing this caching approach enhances efficiency and reduces transaction costs, which is crucial for optimizing smart contract performance and user experience on the blockchain.",
      "gasSavings": 294,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n356:     function _installModule(Module newModule_) internal {\n357:         \n358:         Keycode keycode = newModule_.KEYCODE();\n359: \n360:         \n361:         if (address(getModuleForKeycode[keycode]) != address(0)) { // <= FOUND\n362:             revert Errors.Kernel_ModuleAlreadyInstalled(keycode);\n363:         }\n364: \n365:         \n366:         getModuleForKeycode[keycode] = newModule_; // <= FOUND\n367: \n368:         \n369:         getKeycodeForModule[newModule_] = keycode;\n370: \n371:         \n372:         allKeycodes.push(keycode);\n373: \n374:         \n375:         newModule_.INIT();\n376:     }\n\n```\n",
          "loc": [
            "[356](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L356-L366)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": ".call bypasses function existence check, type checking and argument packing ",
      "description": "Using the `.call` method in Solidity enables direct communication with an address, bypassing function existence checks, type checking, and argument packing. While this can save gas and provide flexibility, it can also introduce security risks and potential errors. The absence of these checks can lead to unexpected behavior if the callee contract's interface changes or if the input parameters are not crafted with care. The resolution to these issues is to use Solidity's high-level interface for calling functions when possible, as it automatically manages these aspects. If using `.call` is necessary, ensure that the inputs are carefully validated and that awareness of the called contract's behavior is maintained.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n102:         \n103:         (bool success, bytes memory data) = token.call( // <= FOUND\n104:             abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n105:         );\n\n```\n",
          "loc": [
            "[102](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L102-L103)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Double type casts create complexity within the code ",
      "description": "Double type casting should be avoided in Solidity contracts to prevent unintended consequences and ensure accurate data representation. Performing multiple type casts in succession can lead to unexpected truncation, rounding errors, or loss of precision, potentially compromising the contract's functionality and reliability. Furthermore, double type casting can make the code less readable and harder to maintain, increasing the likelihood of errors and misunderstandings during development and debugging. To ensure precise and consistent data handling, developers should use appropriate data types and avoid unnecessary or excessive type casting, promoting a more robust and dependable contract execution.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n94: \n95:         \n96:         return address(uint160(uint256(addressHash))); // <= FOUND\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L96-L96)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Inconsistent comment spacing ",
      "description": "Some comments use // X and others //X Amend comments to use only use // X or //X consistently",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n102: //github.com/martinetlee/create2-snippets#method-1-mixing-with-salt\n\n```\n",
          "loc": [
            "[102](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L102-L102)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider adding emergency-stop functionality ",
      "description": "In the event of a security breach or any unforeseen emergency, swiftly suspending all protocol operations becomes crucial. Having a mechanism in place to halt all functions collectively, instead of pausing individual contracts separately, substantially enhances the efficiency of mitigating ongoing attacks or vulnerabilities. This not only quickens the response time to potential threats but also reduces operational stress during these critical periods. Therefore, consider integrating a 'circuit breaker' or 'emergency stop' function into the smart contract system architecture. Such a feature would provide the capability to suspend the entire protocol instantly, which could prove invaluable during a time-sensitive crisis management situation.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23: contract PaymentEscrowBase \n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase \n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n14: contract StorageBase \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase \n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n15: contract Admin is Policy \n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator \n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n22: contract Factory is Policy \n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard \n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator \n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        },
        {
          "content": "```solidity\n14: contract Create2Deployer \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n206: contract Kernel \n\n```\n",
          "loc": [
            "[206](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L206-L206)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Employ Explicit Casting to Bytes or Bytes32 for Enhanced Code Clarity and Meaning ",
      "description": "Smart contracts are complex entities, and clarity in their operations is fundamental to ensure that they function as intended. Casting a single argument instead of utilizing 'abi.encodePacked()' improves the transparency of the operation. It elucidates the intent of the code, reducing ambiguity and making it easier for auditors and developers to understand the codeâ€™s purpose. Such practices promote readability and maintainability, thus reducing the likelihood of errors and misunderstandings. Therefore, it's recommended to employ explicit casts for single arguments where possible, to increase the contract's comprehensibility and ensure a smoother review process.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) {\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) {\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)), // <= FOUND\n187:                     keccak256(abi.encodePacked(hookHashes)), // <= FOUND\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[186](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L186-L187)"
          ]
        },
        {
          "content": "```solidity\n218:     function _deriveOrderMetadataHash(\n219:         OrderMetadata memory metadata\n220:     ) internal view returns (bytes32) {\n221:         \n222:         bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n223: \n224:         \n225:         for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n226:             \n227:             hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n228:         }\n229: \n230:         \n231:         return\n232:             keccak256(\n233:                 abi.encode(\n234:                     _ORDER_METADATA_TYPEHASH,\n235:                     metadata.rentDuration,\n236:                     keccak256(abi.encodePacked(hookHashes)) // <= FOUND\n237:                 )\n238:             );\n239:     }\n\n```\n",
          "loc": [
            "[236](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L236-L236)"
          ]
        },
        {
          "content": "```solidity\n339:     function _deriveRentalTypehashes()\n340:         internal\n341:         pure\n342:         returns (\n343:             bytes32 itemTypeHash,\n344:             bytes32 hookTypeHash,\n345:             bytes32 rentalOrderTypeHash,\n346:             bytes32 orderFulfillmentTypeHash,\n347:             bytes32 orderMetadataTypeHash,\n348:             bytes32 rentPayloadTypeHash\n349:         )\n350:     {\n351:         \n352:         bytes memory itemTypeString = abi.encodePacked( // <= FOUND\n353:             \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n354:         );\n355: \n356:         \n357:         bytes memory hookTypeString = abi.encodePacked( // <= FOUND\n358:             \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n359:         );\n360: \n361:         \n362:         bytes memory rentalOrderTypeString = abi.encodePacked( // <= FOUND\n363:             \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n364:         );\n365: \n366:         \n367:         itemTypeHash = keccak256(itemTypeString);\n368: \n369:         \n370:         hookTypeHash = keccak256(hookTypeString);\n371: \n372:         \n373:         rentalOrderTypeHash = keccak256(\n374:             abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n375:         );\n376: \n377:         {\n378:             \n379:             bytes memory orderFulfillmentTypeString = abi.encodePacked( // <= FOUND\n380:                 \"OrderFulfillment(address recipient)\"\n381:             );\n382: \n383:             \n384:             bytes memory orderMetadataTypeString = abi.encodePacked( // <= FOUND\n385:                 \"OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\"\n386:             );\n387: \n388:             \n389:             bytes memory rentPayloadTypeString = abi.encodePacked( // <= FOUND\n390:                 \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\"\n391:             );\n392: \n393:             \n394:             rentPayloadTypeHash = keccak256(\n395:                 abi.encodePacked( // <= FOUND\n396:                     rentPayloadTypeString,\n397:                     orderMetadataTypeString,\n398:                     orderFulfillmentTypeString\n399:                 )\n400:             );\n401: \n402:             \n403:             orderFulfillmentTypeHash = keccak256(orderFulfillmentTypeString);\n404: \n405:             \n406:             orderMetadataTypeHash = keccak256(orderMetadataTypeString);\n407:         }\n408:     }\n\n```\n",
          "loc": [
            "[352](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L352-L395)"
          ]
        },
        {
          "content": "```solidity\n84:     function getCreate2Address(\n85:         bytes32 salt,\n86:         bytes memory initCode\n87:     ) public view returns (address) {\n88:         \n89:         bytes32 addressHash = keccak256(\n90:             abi.encodePacked(create2_ff, address(this), salt, keccak256(initCode)) // <= FOUND\n91:         );\n92: \n93:         \n94:         return address(uint160(uint256(addressHash)));\n95:     }\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L90-L90)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Missing events in sensitive functions ",
      "description": "Sensitive setter functions in smart contracts often alter critical state variables. Without events emitted in these functions, external observers or dApps cannot easily track or react to these state changes. Missing events can obscure contract activity, hampering transparency and making integration more challenging. To resolve this, incorporate appropriate event emissions within these functions. Events offer an efficient way to log crucial changes, aiding in real-time tracking and post-transaction verification.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n380:     function setFee(uint256 feeNumerator) external onlyByProxy permissioned { // <= FOUND\n381:         \n382:         if (feeNumerator > 10000) {\n383:             revert Errors.PaymentEscrow_InvalidFeeNumerator();\n384:         }\n385: \n386:         \n387:         fee = feeNumerator;\n388:     }\n\n```\n",
          "loc": [
            "[380](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L380-L380)"
          ]
        },
        {
          "content": "```solidity\n173:     function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") { // <= FOUND\n174:         ESCRW.setFee(feeNumerator);\n175:     }\n\n```\n",
          "loc": [
            "[173](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L173-L173)"
          ]
        },
        {
          "content": "```solidity\n192:     function setActiveStatus(bool activate_) external onlyKernel { // <= FOUND\n193:         isActive = activate_;\n194:     }\n\n```\n",
          "loc": [
            "[192](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L192-L192)"
          ]
        },
        {
          "content": "```solidity\n294:     function updateHookPath(address to, address hook) external onlyByProxy permissioned { // <= FOUND\n295:         \n296:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to);\n297: \n298:         \n299:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n300: \n301:         \n302:         _contractToHook[to] = hook;\n303:     }\n\n```\n",
          "loc": [
            "[294](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L294-L294)"
          ]
        },
        {
          "content": "```solidity\n313:     function updateHookStatus( // <= FOUND\n314:         address hook,\n315:         uint8 bitmap\n316:     ) external onlyByProxy permissioned {\n317:         \n318:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n319: \n320:         \n321:         if (bitmap > uint8(7))\n322:             revert Errors.StorageModule_InvalidHookStatusBitmap(bitmap);\n323: \n324:         \n325:         hookStatus[hook] = bitmap;\n326:     }\n\n```\n",
          "loc": [
            "[313](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n362:     function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") { // <= FOUND\n363:         STORE.updateHookPath(to, hook);\n364:     }\n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L362-L362)"
          ]
        },
        {
          "content": "```solidity\n373:     function updateHookStatus( // <= FOUND\n374:         address hook,\n375:         uint8 bitmap\n376:     ) external onlyRole(\"GUARD_ADMIN\") {\n377:         STORE.updateHookStatus(hook, bitmap);\n378:     }\n\n```\n",
          "loc": [
            "[373](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L373-L373)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Shorten the array rather than copying to a new one ",
      "description": "Leveraging inline assembly in Solidity provides the ability to directly manipulate the length slot of an array, thereby altering its length without the need to copy the elements to a new array of the desired size. This technique is more gas-efficient as it avoids the computational expense associated with array duplication. However, this method circumvents the type-checking and safety mechanisms of high-level Solidity and should be used judiciously. Always ensure that the array doesn't contain vital data beyond the revised length, as this data will become unreachable yet still consume storage space.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n116: \n117:         \n118:         updates = new RentalAssetUpdate[](rentalAssetUpdateLength); // <= FOUND\n\n```\n",
          "loc": [
            "[116](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L116-L118)"
          ]
        },
        {
          "content": "```solidity\n166:         \n167:         bytes32[] memory itemHashes = new bytes32[](order.items.length); // <= FOUND\n\n```\n",
          "loc": [
            "[166](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L166-L167)"
          ]
        },
        {
          "content": "```solidity\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length); // <= FOUND\n\n```\n",
          "loc": [
            "[167](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L167-L167)"
          ]
        },
        {
          "content": "```solidity\n222:         \n223:         bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length); // <= FOUND\n\n```\n",
          "loc": [
            "[222](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L222-L223)"
          ]
        },
        {
          "content": "```solidity\n78:         dependencies = new Keycode[](2); // <= FOUND\n\n```\n",
          "loc": [
            "[78](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L78-L78)"
          ]
        },
        {
          "content": "```solidity\n71:         requests = new Permissions[](8); // <= FOUND\n\n```\n",
          "loc": [
            "[71](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L71-L71)"
          ]
        },
        {
          "content": "```solidity\n103:         requests = new Permissions[](2); // <= FOUND\n\n```\n",
          "loc": [
            "[103](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n417:         \n418:         items = new Item[](offers.length + considerations.length); // <= FOUND\n\n```\n",
          "loc": [
            "[417](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L417-L418)"
          ]
        },
        {
          "content": "```solidity\n79:         dependencies = new Keycode[](1); // <= FOUND\n\n```\n",
          "loc": [
            "[79](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L79-L79)"
          ]
        },
        {
          "content": "```solidity\n101:         requests = new Permissions[](1); // <= FOUND\n\n```\n",
          "loc": [
            "[101](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L101-L101)"
          ]
        },
        {
          "content": "```solidity\n94:         requests = new Permissions[](4); // <= FOUND\n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L94-L94)"
          ]
        },
        {
          "content": "```solidity\n315:         \n316:         bytes32[] memory orderHashes = new bytes32[](orders.length); // <= FOUND\n\n```\n",
          "loc": [
            "[315](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L315-L316)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Using bools for storage incurs overhead ",
      "description": "Using boolean variables (`bool`) for storage in Solidity can incur overhead due to the way data is packed in Ethereum's storage layout. A `bool` takes a full storage slot, even though it represents only a true or false value. This leads to inefficient usage of storage space and potentially higher gas costs. To resolve this issue, developers can use bit fields or uint8/uint256 to pack multiple boolean values into a single storage slot. By employing such optimization techniques, it's possible to save on storage space and reduce gas costs, making the contract more efficient.",
      "gasSavings": 560,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n228: \n229:         \n230:         bool isRentalOver = elapsedTime >= totalTime; // <= FOUND\n\n```\n",
          "loc": [
            "[228](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L228-L230)"
          ]
        },
        {
          "content": "```solidity\n335:         bool isActive = STORE.hookOnTransaction(hook); // <= FOUND\n\n```\n",
          "loc": [
            "[335](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L335-L335)"
          ]
        },
        {
          "content": "```solidity\n132:         \n133:         bool hasExpired = endTimestamp <= block.timestamp; // <= FOUND\n\n```\n",
          "loc": [
            "[132](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L132-L133)"
          ]
        },
        {
          "content": "```solidity\n135: \n136:         \n137:         bool isLender = expectedLender == msg.sender; // <= FOUND\n\n```\n",
          "loc": [
            "[135](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L135-L137)"
          ]
        },
        {
          "content": "```solidity\n116:     \n117:     bool public isActive; // <= FOUND\n\n```\n",
          "loc": [
            "[116](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L116-L117)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Low Level Calls to Custom Addresses",
      "description": "Low-level calls (such as `.call()`, `.delegatecall()`, or `.callcode()`) in Solidity provide a way to interact with other contracts or addresses. However, when these calls are made to addresses that are provided as parameters or are not well-validated, they pose a significant security risk. Untrusted addresses might contain malicious code leading to unexpected behavior, loss of funds, or vulnerabilities.\n\n**Resolution**: Prefer using high-level Solidity function calls or interface-based interactions with known contracts to ensure security. If low-level calls are necessary, rigorously validate the addresses and test all possible interactions. Implementing additional checks and fail-safes can help mitigate potential risks associated with low-level calls.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n100:     function _safeTransfer(address token, address to, uint256 value) internal { // <= FOUND\n101:         \n102:         (bool success, bytes memory data) = token.call( // <= FOUND\n103:             abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n104:         );\n105: \n106:         \n107:         \n108:         \n109:         \n110:         \n111:         \n112:         \n113:         \n114:         \n115:         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n116:             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n117:         }\n118:     }\n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L100-L102)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Low level call can be optimized with assembly",
      "description": "Low-level calls, when optimized with assembly, can save gas by avoiding unnecessary operations related to unused returndata. In a typical `.call`, Solidity automatically allocates memory and handles returndata even if it's not used, incurring extra gas costs. By using assembly, a developer can precisely control the execution, selectively ignoring or handling returndata, thereby optimizing gas usage. This specific control over the EVM allows for more efficient execution of calls by eliminating unnecessary memory operations, providing a more gas-efficient method when unused returndata is a concern. However, such optimization should be handled with care, as improper use of assembly might lead to vulnerabilities.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n102:         \n103:         (bool success, bytes memory data) = token.call( // <= FOUND\n104:             abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n105:         );\n\n```\n",
          "loc": [
            "[103](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L103-L103)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Optimize by Using Assembly for Low-Level Calls' Return Data",
      "description": "Using assembly for low-level calls in Solidity can provide gas savings, especially when dealing with return data. High-level Solidity calls include overhead for decoding return data, which can be bypassed with assembly. By directly accessing return data in assembly, you can eliminate unnecessary memory allocation and data copying, leading to a more gas-efficient execution. However, this approach requires a deep understanding of the Ethereum Virtual Machine (EVM) and is prone to errors. Itâ€™s crucial to ensure security and correctness in the implementation. This technique is best suited for advanced users aiming to optimize contract performance in specific, gas-critical scenarios.",
      "gasSavings": 159,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n102:         \n103:         (bool success, bytes memory data) = token.call( // <= FOUND\n104:             abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n105:         );\n\n```\n",
          "loc": [
            "[102](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L102-L103)"
          ]
        }
      ]
    },
    {
      "severity": "Medium",
      "title": "Privileged functions can create points of failure",
      "description": "Ensure such accounts are protected and consider implementing multi sig to prevent a single point of failure",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n310:     function grantRole(Role role_, address addr_) public onlyAdmin  // <= FOUND\n\n```\n",
          "loc": [
            "[310](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L310-L310)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin  // <= FOUND\n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L333)"
          ]
        },
        {
          "content": "```solidity\n99:     function toggleWhitelistDelegate(\n100:         address delegate,\n101:         bool isEnabled\n102:     ) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[102](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L102-L102)"
          ]
        },
        {
          "content": "```solidity\n113:     function toggleWhitelistExtension(\n114:         address extension,\n115:         bool isEnabled\n116:     ) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[116](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L116-L116)"
          ]
        },
        {
          "content": "```solidity\n126:     function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n134:     function freezeStorage() external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[134](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L134-L134)"
          ]
        },
        {
          "content": "```solidity\n144:     function upgradePaymentEscrow(\n145:         address newImplementation\n146:     ) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[146](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L146-L146)"
          ]
        },
        {
          "content": "```solidity\n154:     function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[154](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L154-L154)"
          ]
        },
        {
          "content": "```solidity\n164:     function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[164](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L164-L164)"
          ]
        },
        {
          "content": "```solidity\n173:     function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[173](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L173-L173)"
          ]
        },
        {
          "content": "```solidity\n733:     function validateOrder(\n734:         ZoneParameters calldata zoneParams\n735:     ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue)  // <= FOUND\n\n```\n",
          "loc": [
            "[735](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L735-L735)"
          ]
        },
        {
          "content": "```solidity\n362:     function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L362-L362)"
          ]
        },
        {
          "content": "```solidity\n373:     function updateHookStatus(\n374:         address hook,\n375:         uint8 bitmap\n376:     ) external onlyRole(\"GUARD_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[376](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L376-L376)"
          ]
        },
        {
          "content": "```solidity\n733:     function validateOrder(\n734:         ZoneParameters calldata zoneParams\n735:     ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue) { // <= FOUND\n736:         \n737:         (RentPayload memory payload, bytes memory signature) = abi.decode(\n738:             zoneParams.extraData,\n739:             (RentPayload, bytes)\n740:         );\n741: \n742:         \n743:         SeaportPayload memory seaportPayload = SeaportPayload({\n744:             orderHash: zoneParams.orderHash,\n745:             zoneHash: zoneParams.zoneHash,\n746:             offer: zoneParams.offer,\n747:             consideration: zoneParams.consideration,\n748:             totalExecutions: zoneParams.totalExecutions,\n749:             fulfiller: zoneParams.fulfiller,\n750:             offerer: zoneParams.offerer\n751:         });\n752: \n753:         \n754:         _validateProtocolSignatureExpiration(payload.expiration);\n755: \n756:         \n757:         _validateFulfiller(payload.intendedFulfiller, seaportPayload.fulfiller);\n758: \n759:         \n760:         address signer = _recoverSignerFromPayload(\n761:             _deriveRentPayloadHash(payload),\n762:             signature\n763:         );\n764: \n765:         \n766:         if (!kernel.hasRole(signer, toRole(\"CREATE_SIGNER\"))) { // <= FOUND\n767:             revert Errors.CreatePolicy_UnauthorizedCreatePolicySigner();\n768:         }\n769: \n770:         \n771:         _rentFromZone(payload, seaportPayload);\n772: \n773:         \n774:         validOrderMagicValue = ZoneInterface.validateOrder.selector;\n775:     }\n\n```\n",
          "loc": [
            "[735](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L735-L766)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Contract can't receive NFTs sent with safeTransferFrom method",
      "description": "The contract under consideration is designed to receive and store ERC721 tokens. However, certain smart wallets or contracts might utilize the `safeTransferFrom` method to send an NFT. The `safeTransferFrom` method checks for the implementation of the `onERC721Received` method when the recipient is a contract. This is to ensure that the recipient contract can appropriately handle ERC721 tokens. Therefore, it's essential for the contract to extend the `ERC721Holder` contract from OpenZeppelin. The `ERC721Holder` contract has the `onERC721Received` method implemented, which allows the contract to correctly receive and store ERC721 tokens sent using `safeTransferFrom`.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator \n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        }
      ]
    },
    {
      "severity": "Medium",
      "title": "Return of create2 is not checked",
      "description": "In the assembly block, once the contract creation is initiated using CREATE2, it returns an address. This address is then compared to the zero address. If the returned address is the zero address, it means the contract creation has failed. This is a critical step to validate the success of contract creation and ensures that the smart contract behaves correctly even in the event of contract creation failure. This is essential to ensure proxy calls are not made to an non existent contract",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n32:     function deploy(\n33:         bytes32 salt,\n34:         bytes memory initCode\n35:     ) external payable returns (address deploymentAddress) {\n36:         \n37:         if (address(bytes20(salt)) != msg.sender) {\n38:             revert Errors.Create2Deployer_UnauthorizedSender(msg.sender, salt);\n39:         }\n40: \n41:         \n42:         address targetDeploymentAddress = getCreate2Address(salt, initCode);\n43: \n44:         \n45:         if (deployed[targetDeploymentAddress]) {\n46:             revert Errors.Create2Deployer_AlreadyDeployed(targetDeploymentAddress, salt);\n47:         }\n48: \n49:         \n50:         deployed[targetDeploymentAddress] = true;\n51: \n52:         \n53:         assembly {\n54:             deploymentAddress := create2( // <= FOUND\n55:                 \n56:                 callvalue(),\n57:                 \n58:                 add(initCode, 0x20),\n59:                 \n60:                 mload(initCode),\n61:                 \n62:                 salt\n63:             )\n64:         }\n65: \n66:         \n67:         if (deploymentAddress != targetDeploymentAddress) {\n68:             revert Errors.Create2Deployer_MismatchedDeploymentAddress(\n69:                 targetDeploymentAddress,\n70:                 deploymentAddress\n71:             );\n72:         }\n73:     }\n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L32-L54)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "The call abi.encodeWithSelector is not type safe",
      "description": "In Solidity, `abi.encodeWithSelector` is a function used for encoding data along with a function selector, but it is not type-safe. This means it does not enforce type checking at compile time, potentially leading to errors if arguments do not match the expected types. Starting from version 0.8.13, Solidity introduced `abi.encodeCall`, which offers a safer alternative. `abi.encodeCall` ensures type safety by performing a full type check, aligning the types of the arguments with the function signature. This reduces the risk of bugs caused by typographical errors or mismatched types. Using `abi.encodeCall` enhances the reliability and security of the code by ensuring that the encoded data strictly conforms to the specified types, making it a preferable choice in Solidity versions 0.8.13 and above.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n100:     function _safeTransfer(address token, address to, uint256 value) internal {\n101:         \n102:         (bool success, bytes memory data) = token.call(\n103:             abi.encodeWithSelector(IERC20.transfer.selector, to, value) // <= FOUND\n104:         );\n105: \n106:         \n107:         \n108:         \n109:         \n110:         \n111:         \n112:         \n113:         \n114:         \n115:         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n116:             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n117:         }\n118:     }\n\n```\n",
          "loc": [
            "[103](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n166:     function _reclaimRentedItems(RentalOrder memory order) internal {\n167:         \n168:         bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n169:             \n170:             address(this),\n171:             \n172:             0,\n173:             \n174:             abi.encodeWithSelector(this.reclaimRentalOrder.selector, order), // <= FOUND\n175:             \n176:             Enum.Operation.DelegateCall\n177:         );\n178: \n179:         \n180:         if (!success) {\n181:             revert Errors.StopPolicy_ReclaimFailed();\n182:         }\n183:     }\n\n```\n",
          "loc": [
            "[174](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L174-L174)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Function calls within for loops",
      "description": "Making function calls or external calls within loops in Solidity can lead to inefficient gas usage, potential bottlenecks, and increased vulnerability to attacks. Each function call or external call consumes gas, and when executed within a loop, the gas cost multiplies, potentially causing the transaction to run out of gas or exceed block gas limits. This can result in transaction failure or unpredictable behavior.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n231:        for (uint256 i = 0; i < items.length; ++i) {\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount); // <= FOUND\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount); // <= FOUND\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata( // <= FOUND\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull( // <= FOUND\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n\n```\n",
          "loc": [
            "[231](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L231-L271)"
          ]
        },
        {
          "content": "```solidity\n341:        for (uint256 i = 0; i < orders.length; ++i) {\n342:             \n343:             _settlePayment( // <= FOUND\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L341-L343)"
          ]
        },
        {
          "content": "```solidity\n475:        for (uint256 i = 0; i < hooks.length; ++i) {\n476:             \n477:             target = hooks[i].target;\n478: \n479:             \n480:             if (!STORE.hookOnStart(target)) { // <= FOUND\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             \n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             \n488:             offer = offerItems[itemIndex];\n489: \n490:             \n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             \n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 \n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) {\n508:                 \n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 \n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n514:                 );\n515:             } catch (bytes memory revertData) {\n516:                 \n517:                 revert Errors.Shared_HookFailBytes(revertData);\n518:             }\n519:         }\n\n```\n",
          "loc": [
            "[475](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L475-L480)"
          ]
        },
        {
          "content": "```solidity\n205:        for (uint256 i = 0; i < hooks.length; ++i) {\n206:             \n207:             target = hooks[i].target;\n208: \n209:             \n210:             if (!STORE.hookOnStop(target)) { // <= FOUND\n211:                 revert Errors.Shared_DisabledHook(target);\n212:             }\n213: \n214:             \n215:             itemIndex = hooks[i].itemIndex;\n216: \n217:             \n218:             item = rentalItems[itemIndex];\n219: \n220:             \n221:             if (!item.isRental()) {\n222:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n223:             }\n224: \n225:             \n226:             try\n227:                 IHook(target).onStop(\n228:                     rentalWallet,\n229:                     item.token,\n230:                     item.identifier,\n231:                     item.amount,\n232:                     hooks[i].extraData\n233:                 )\n234:             {} catch Error(string memory revertReason) {\n235:                 \n236:                 revert Errors.Shared_HookFailString(revertReason);\n237:             } catch Panic(uint256 errorCode) {\n238:                 \n239:                 string memory stringErrorCode = LibString.toString(errorCode);\n240: \n241:                 \n242:                 revert Errors.Shared_HookFailString(\n243:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n244:                 );\n245:             } catch (bytes memory revertData) {\n246:                 \n247:                 revert Errors.Shared_HookFailBytes(revertData);\n248:             }\n249:         }\n\n```\n",
          "loc": [
            "[205](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L205-L210)"
          ]
        },
        {
          "content": "```solidity\n276:        for (uint256 i; i < order.items.length; ++i) {\n277:             if (order.items[i].isRental()) {\n278:                 \n279:                 _insert( // <= FOUND\n280:                     rentalAssetUpdates,\n281:                     order.items[i].toRentalId(order.rentalWallet),\n282:                     order.items[i].amount\n283:                 );\n284:             }\n285:         }\n\n```\n",
          "loc": [
            "[276](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L276-L279)"
          ]
        },
        {
          "content": "```solidity\n324:        for (uint256 i = 0; i < orders.length; ++i) {\n325:             \n326:             _validateRentalCanBeStoped( // <= FOUND\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             \n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) {\n334:                 \n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert( // <= FOUND\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             \n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]); // <= FOUND\n346: \n347:             \n348:             if (orders[i].hooks.length > 0) {\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet); // <= FOUND\n350:             }\n351: \n352:             \n353:             _reclaimRentedItems(orders[i]); // <= FOUND\n354: \n355:             \n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender); // <= FOUND\n357:         }\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L356)"
          ]
        },
        {
          "content": "```solidity\n170:        for (uint256 i = 0; i < order.items.length; ++i) {\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]); // <= FOUND\n173:         }\n\n```\n",
          "loc": [
            "[170](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L170-L172)"
          ]
        },
        {
          "content": "```solidity\n225:        for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n226:             \n227:             hookHashes[i] = _deriveHookHash(metadata.hooks[i]); // <= FOUND\n228:         }\n\n```\n",
          "loc": [
            "[225](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L225-L227)"
          ]
        },
        {
          "content": "```solidity\n546:        for (uint256 i; i < depLength; ++i) {\n547:             \n548:             dependents[i].configureDependencies(); // <= FOUND\n549:         }\n\n```\n",
          "loc": [
            "[546](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L546-L548)"
          ]
        },
        {
          "content": "```solidity\n695:        for (uint256 i = 0; i < executions.length; ++i) {\n696:             ReceivedItem memory execution = executions[i];\n697: \n698:             \n699:             if (execution.isERC20()) {\n700:                 _checkExpectedRecipient(execution, address(ESCRW)); // <= FOUND\n701:             }\n702:             \n703:             \n704:             else if (execution.isRental()) {\n705:                 _checkExpectedRecipient(execution, expectedRentalSafe); // <= FOUND\n706:             }\n707:             \n708:             else {\n709:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n710:                     execution.itemType\n711:                 );\n712:             }\n713:         }\n\n```\n",
          "loc": [
            "[695](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L695-L705)"
          ]
        },
        {
          "content": "```solidity\n512:        for (uint256 i; i < keycodeLen; ++i) {\n513:             \n514:             Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n515:             \n516:             module.changeKernel(newKernel_); // <= FOUND\n517:         }\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L512-L516)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "For loops in public or external functions should be avoided due to high gas costs and possible DOS",
      "description": "In Solidity, for loops can potentially cause Denial of Service (DoS) attacks if not handled carefully. DoS attacks can occur when an attacker intentionally exploits the gas cost of a function, causing it to run out of gas or making it too expensive for other users to call. Below are some scenarios where for loops can lead to DoS attacks: Nested for loops can become exceptionally gas expensive and should be used sparingly",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n71:     function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n72:         \n73:         if (address(this) == original) {\n74:             revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed();\n75:         }\n76: \n77:         \n78:         \n79:         \n80:         if (address(this) != rentalOrder.rentalWallet) {\n81:             revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed(\n82:                 rentalOrder.rentalWallet\n83:             );\n84:         }\n85: \n86:         \n87:         uint256 itemCount = rentalOrder.items.length;\n88: \n89:         \n90:         for (uint256 i = 0; i < itemCount; ++i) { // <= FOUND\n91:             Item memory item = rentalOrder.items[i];\n92: \n93:             \n94:             if (item.itemType == ItemType.ERC721)\n95:                 _transferERC721(item, rentalOrder.lender);\n96: \n97:             \n98:             if (item.itemType == ItemType.ERC1155)\n99:                 _transferERC1155(item, rentalOrder.lender);\n100:         }\n101:     }\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L90-L90)"
          ]
        },
        {
          "content": "```solidity\n265:     function stopRent(RentalOrder calldata order) external {\n266:         \n267:         _validateRentalCanBeStoped(order.orderType, order.endTimestamp, order.lender);\n268: \n269:         \n270:         \n271:         \n272:         bytes memory rentalAssetUpdates = new bytes(0);\n273: \n274:         \n275:         \n276:         for (uint256 i; i < order.items.length; ++i) { // <= FOUND\n277:             if (order.items[i].isRental()) {\n278:                 \n279:                 _insert(\n280:                     rentalAssetUpdates,\n281:                     order.items[i].toRentalId(order.rentalWallet),\n282:                     order.items[i].amount\n283:                 );\n284:             }\n285:         }\n286: \n287:         \n288:         if (order.hooks.length > 0) {\n289:             _removeHooks(order.hooks, order.items, order.rentalWallet);\n290:         }\n291: \n292:         \n293:         _reclaimRentedItems(order);\n294: \n295:         \n296:         ESCRW.settlePayment(order);\n297: \n298:         \n299:         STORE.removeRentals(\n300:             _deriveRentalOrderHash(order),\n301:             _convertToStatic(rentalAssetUpdates)\n302:         );\n303: \n304:         \n305:         _emitRentalOrderStopped(order.seaportOrderHash, msg.sender);\n306:     }\n\n```\n",
          "loc": [
            "[276](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L276-L276)"
          ]
        },
        {
          "content": "```solidity\n313:     function stopRentBatch(RentalOrder[] calldata orders) external {\n314:         \n315:         bytes32[] memory orderHashes = new bytes32[](orders.length);\n316: \n317:         \n318:         \n319:         \n320:         bytes memory rentalAssetUpdates = new bytes(0);\n321: \n322:         \n323:         \n324:         for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n325:             \n326:             _validateRentalCanBeStoped(\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             \n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) { // <= FOUND\n334:                 \n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert(\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             \n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n346: \n347:             \n348:             if (orders[i].hooks.length > 0) {\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n350:             }\n351: \n352:             \n353:             _reclaimRentedItems(orders[i]);\n354: \n355:             \n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:         }\n358: \n359:         \n360:         ESCRW.settlePaymentBatch(orders);\n361: \n362:         \n363:         STORE.removeRentalsBatch(orderHashes, _convertToStatic(rentalAssetUpdates));\n364:     }\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L333)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Missing zero address check in constructor",
      "description": "In Solidity, constructors often take address parameters to initialize important components of a contract, such as owner or linked contracts. However, without a check, there's a risk that an address parameter could be mistakenly set to the zero address (0x0). This could occur due to a mistake or oversight during contract deployment. A zero address in a crucial role can cause serious issues, as it cannot perform actions like a normal address, and any funds sent to it are irretrievable. Therefore, it's crucial to include a zero address check in constructors to prevent such potential problems. If a zero address is detected, the constructor should revert the transaction.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n242:     constructor(address _executor, address _admin) { // <= FOUND\n243:         executor = _executor;\n244:         admin = _admin;\n245:     }\n\n```\n",
          "loc": [
            "[242](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L242-L242)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Using zero as a parameter",
      "description": "Taking 0 as a valid argument in Solidity without checks can lead to severe security issues. A historical example is the infamous 0x0 address bug where numerous tokens were lost. This happens because '0' can be interpreted as an uninitialized address, leading to transfers to the '0x0' address, effectively burning tokens. Moreover, 0 as a denominator in division operations would cause a runtime exception. It's also often indicative of a logical error in the caller's code. It's important to always validate input and handle edge cases like 0 appropriately. Use `require()` statements to enforce conditions and provide clear error messages to facilitate debugging and safer code.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n411:     function _convertToItems(\n412:         SpentItem[] memory offers,\n413:         ReceivedItem[] memory considerations,\n414:         OrderType orderType\n415:     ) internal pure returns (Item[] memory items) {\n416:         \n417:         items = new Item[](offers.length + considerations.length);\n418: \n419:         \n420:         if (orderType.isBaseOrder()) {\n421:             \n422:             _processBaseOrderOffer(items, offers, 0);\n423: \n424:             \n425:             _processBaseOrderConsideration(items, considerations, offers.length);\n426:         }\n427:         \n428:         else if (orderType.isPayOrder()) {\n429:             \n430:             _processPayOrderOffer(items, offers, 0);\n431: \n432:             \n433:             if (considerations.length > 0) {\n434:                 revert Errors.CreatePolicy_ConsiderationCountNonZero(\n435:                     considerations.length\n436:                 );\n437:             }\n438:         }\n439:         \n440:         else if (orderType.isPayeeOrder()) {\n441:             \n442:             if (offers.length > 0) {\n443:                 revert Errors.CreatePolicy_OfferCountNonZero(offers.length);\n444:             }\n445: \n446:             \n447:             _processPayeeOrderConsideration(considerations);\n448:         }\n449:         \n450:         else {\n451:             revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n452:         }\n453:     }\n\n```\n",
          "loc": [
            "[411](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L411-L411)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Critical functions should be a two step procedure",
      "description": "Critical functions in Solidity contracts should follow a two-step procedure to enhance security, minimize human error, and ensure proper access control. By dividing sensitive operations into distinct phases, such as initiation and confirmation, developers can introduce a safeguard against unintended actions or unauthorized access.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n173:     function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[173](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L173-L173)"
          ]
        },
        {
          "content": "```solidity\n362:     function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L362-L362)"
          ]
        },
        {
          "content": "```solidity\n373:     function updateHookStatus( // <= FOUND\n374:         address hook,\n375:         uint8 bitmap\n376:     ) external onlyRole(\"GUARD_ADMIN\") \n\n```\n",
          "loc": [
            "[373](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L373-L373)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Arrays can grow in size without a way to shrink them",
      "description": "It's a good practice to maintain control over the size of array state variables in Solidity, especially if they are dynamically updated. If a contract includes a mechanism to push items into an array, it should ideally also provide a mechanism to remove items. This is because Solidity arrays don't automatically shrink when items are deleted - their length needs to be manually adjusted.\n\nIgnoring this can lead to bloated and inefficient contracts. For instance, iterating over a large array can cause your contract to hit the block gas limit. Additionally, if entries are only marked for deletion but never actually removed, you may end up dealing with stale or irrelevant data, which can cause logical errors.\n\nTherefore, implementing a method to 'pop' items from arrays helps manage contract's state, improve efficiency and prevent potential issues related to gas limits or stale data. Always ensure to handle potential underflow conditions when popping elements from the array. In this particular case, as 'allKeyCodes' is iterated upon, this could brick the functionality of '_migrateKernel function.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n212: Keycode[] public allKeycodes; // <= FOUND\n\n```\n",
          "loc": [
            "[212](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L212-L212)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Revert on Transfer to the Zero Address",
      "description": "Many ERC-20 and ERC-721 token contracts implement a safeguard that reverts transactions which attempt to transfer tokens to the zero address. This is because such transfers are often the result of programming errors. The OpenZeppelin library, a popular choice for implementing these standards, includes this safeguard. For token contract developers who want to avoid unintentional transfers to the zero address, it's good practice to include a condition that reverts the transaction if the recipient's address is the zero address. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n42:     function _transferERC1155(Item memory item, address recipient) private {\n43:         IERC1155(item.token).safeTransferFrom( // <= FOUND\n44:             address(this),\n45:             recipient,\n46:             item.identifier,\n47:             item.amount,\n48:             \"\"\n49:         );\n50:     }\n\n```\n",
          "loc": [
            "[42](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L42-L43)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Sweeping may break accounting if tokens with multiple addresses are used",
      "description": "In the realm of token contracts, there have been historical instances where a token inadvertently had two controlling addresses, such that transfers made via one would affect the balance of the other. This raises potential security concerns and anomalies in the balance of accounts. To guard against such potential scenarios in functions that \"sweep\" or transfer tokens, it is prudent to validate that the balance of any non-sweepable or exempt tokens remains unaffected post the sweep operation. This measure ensures integrity of the account balances and prevents unintended changes due to potential hidden correlations between different token addresses.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n107:     function _recoverSignerFromPayload( // <= FOUND\n108:         bytes32 payloadHash,\n109:         bytes memory signature\n110:     ) internal view returns (address) {\n111:         \n112:         bytes32 digest = _DOMAIN_SEPARATOR.toTypedDataHash(payloadHash);\n113: \n114:         \n115:         return digest.recover(signature); // <= FOUND\n116:     }\n\n```\n",
          "loc": [
            "[107](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L107-L115)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Missing zero address check in initializer",
      "description": "Initializer functions in contracts often set important parameters or addresses. Failing to check for the zero address (0x0000000000000000000000000000000000000000) in initializers can lead to unintended behavior, as this address typically signifies an unset or default value. Transfers to or interactions with the zero address can result in permanent loss of assets or broken functionality. It's crucial to add checks using `require(targetAddress != address(0), \"Address cannot be zero\")` in initializers to prevent accidentally setting important state variables or parameters to this address, ensuring the system's integrity and user asset safety.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n122:     function initializeRentalSafe(address _stopPolicy, address _guardPolicy) external {\n123:         \n124:         ISafe(address(this)).enableModule(_stopPolicy);\n125: \n126:         \n127:         ISafe(address(this)).setGuard(_guardPolicy);\n128:     }\n\n```\n",
          "loc": [
            "[122](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L122-L122)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Critical functions should have a timelock",
      "description": "Critical functions, especially those affecting protocol parameters or user funds, are potential points of failure or exploitation. To mitigate risks, incorporating a timelock on such functions can be beneficial. A timelock requires a waiting period between the time an action is initiated and when it's executed, giving stakeholders time to react, potentially vetoing malicious or erroneous changes. To implement, integrate a smart contract like OpenZeppelin's `TimelockController` or build a custom mechanism. This ensures governance decisions or administrative changes are transparent and allows for community or multi-signature interventions, enhancing protocol security and trustworthiness.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n173:     function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[173](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L173-L173)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Unbounded loop may run out of gas",
      "description": "Unbounded loops in smart contracts pose a risk because they iterate over an unknown number of elements, potentially consuming all available gas for a transaction. This can result in unintended transaction failures. Gas consumption increases linearly with the number of iterations, and if it surpasses the gas limit, the transaction reverts, wasting the gas spent. To mitigate this, developers should either set a maximum limit on loop iterations.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n215:     function _settlePayment(\n216:         Item[] calldata items,\n217:         OrderType orderType,\n218:         address lender,\n219:         address renter,\n220:         uint256 start,\n221:         uint256 end\n222:     ) internal {\n223:         \n224:         uint256 elapsedTime = block.timestamp - start;\n225:         uint256 totalTime = end - start;\n226: \n227:         \n228:         bool isRentalOver = elapsedTime >= totalTime;\n229: \n230:         \n231:         for (uint256 i = 0; i < items.length; ++i) {\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n281:             }\n282:         }\n283:     }\n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L215-L215)"
          ]
        },
        {
          "content": "```solidity\n337:     function settlePaymentBatch(\n338:         RentalOrder[] calldata orders\n339:     ) external onlyByProxy permissioned {\n340:         \n341:         for (uint256 i = 0; i < orders.length; ++i) {\n342:             \n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n352:     }\n\n```\n",
          "loc": [
            "[337](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L337-L337)"
          ]
        },
        {
          "content": "```solidity\n189:     function addRentals(\n190:         bytes32 orderHash,\n191:         RentalAssetUpdate[] memory rentalAssetUpdates\n192:     ) external onlyByProxy permissioned {\n193:         \n194:         orders[orderHash] = true;\n195: \n196:         \n197:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n198:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n199: \n200:             \n201:             rentedAssets[asset.rentalId] += asset.amount;\n202:         }\n203:     }\n\n```\n",
          "loc": [
            "[189](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L189-L189)"
          ]
        },
        {
          "content": "```solidity\n216:     function removeRentals(\n217:         bytes32 orderHash,\n218:         RentalAssetUpdate[] calldata rentalAssetUpdates\n219:     ) external onlyByProxy permissioned {\n220:         \n221:         if (!orders[orderHash]) {\n222:             revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n223:         } else {\n224:             \n225:             delete orders[orderHash];\n226:         }\n227: \n228:         \n229:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n230:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n231: \n232:             \n233:             rentedAssets[asset.rentalId] -= asset.amount;\n234:         }\n235:     }\n\n```\n",
          "loc": [
            "[216](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L216-L216)"
          ]
        },
        {
          "content": "```solidity\n244:     function removeRentalsBatch(\n245:         bytes32[] calldata orderHashes,\n246:         RentalAssetUpdate[] calldata rentalAssetUpdates\n247:     ) external onlyByProxy permissioned {\n248:         \n249:         for (uint256 i = 0; i < orderHashes.length; ++i) {\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n258: \n259:         \n260:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n261:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n262: \n263:             \n264:             rentedAssets[asset.rentalId] -= asset.amount;\n265:         }\n266:     }\n\n```\n",
          "loc": [
            "[244](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L244-L244)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) {\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) {\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)),\n187:                     keccak256(abi.encodePacked(hookHashes)),\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[162](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n218:     function _deriveOrderMetadataHash(\n219:         OrderMetadata memory metadata\n220:     ) internal view returns (bytes32) {\n221:         \n222:         bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n223: \n224:         \n225:         for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n226:             \n227:             hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n228:         }\n229: \n230:         \n231:         return\n232:             keccak256(\n233:                 abi.encode(\n234:                     _ORDER_METADATA_TYPEHASH,\n235:                     metadata.rentDuration,\n236:                     keccak256(abi.encodePacked(hookHashes))\n237:                 )\n238:             );\n239:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L218-L218)"
          ]
        },
        {
          "content": "```solidity\n195:     function _processBaseOrderOffer(\n196:         Item[] memory rentalItems,\n197:         SpentItem[] memory offers,\n198:         uint256 startIndex\n199:     ) internal pure {\n200:         \n201:         if (offers.length == 0) {\n202:             revert Errors.CreatePolicy_OfferCountZero();\n203:         }\n204: \n205:         \n206:         ItemType itemType;\n207: \n208:         \n209:         for (uint256 i; i < offers.length; ++i) {\n210:             \n211:             SpentItem memory offer = offers[i];\n212: \n213:             \n214:             if (offer.isERC721()) {\n215:                 itemType = ItemType.ERC721;\n216:             }\n217:             \n218:             else if (offer.isERC1155()) {\n219:                 itemType = ItemType.ERC1155;\n220:             }\n221:             \n222:             else {\n223:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n224:             }\n225: \n226:             \n227:             \n228:             rentalItems[i + startIndex] = Item({\n229:                 itemType: itemType,\n230:                 settleTo: SettleTo.LENDER,\n231:                 token: offer.token,\n232:                 amount: offer.amount,\n233:                 identifier: offer.identifier\n234:             });\n235:         }\n236:     }\n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L195-L195)"
          ]
        },
        {
          "content": "```solidity\n247:     function _processPayOrderOffer(\n248:         Item[] memory rentalItems,\n249:         SpentItem[] memory offers,\n250:         uint256 startIndex\n251:     ) internal pure {\n252:         \n253:         uint256 totalRentals;\n254:         uint256 totalPayments;\n255: \n256:         \n257:         ItemType itemType;\n258:         SettleTo settleTo;\n259: \n260:         \n261:         for (uint256 i; i < offers.length; ++i) {\n262:             \n263:             SpentItem memory offer = offers[i];\n264: \n265:             \n266:             if (offer.isERC721()) {\n267:                 \n268:                 \n269:                 itemType = ItemType.ERC721;\n270:                 settleTo = SettleTo.LENDER;\n271: \n272:                 \n273:                 totalRentals++;\n274:             }\n275:             \n276:             else if (offer.isERC1155()) {\n277:                 \n278:                 \n279:                 itemType = ItemType.ERC1155;\n280:                 settleTo = SettleTo.LENDER;\n281: \n282:                 \n283:                 totalRentals++;\n284:             }\n285:             \n286:             else if (offer.isERC20()) {\n287:                 \n288:                 \n289:                 itemType = ItemType.ERC20;\n290:                 settleTo = SettleTo.RENTER;\n291: \n292:                 \n293:                 totalPayments++;\n294:             }\n295:             \n296:             else {\n297:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n298:             }\n299: \n300:             \n301:             rentalItems[i + startIndex] = Item({\n302:                 itemType: itemType,\n303:                 settleTo: settleTo,\n304:                 token: offer.token,\n305:                 amount: offer.amount,\n306:                 identifier: offer.identifier\n307:             });\n308:         }\n309: \n310:         \n311:         if (totalRentals == 0 || totalPayments == 0) {\n312:             revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n313:         }\n314:     }\n\n```\n",
          "loc": [
            "[247](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L247-L247)"
          ]
        },
        {
          "content": "```solidity\n326:     function _processBaseOrderConsideration(\n327:         Item[] memory rentalItems,\n328:         ReceivedItem[] memory considerations,\n329:         uint256 startIndex\n330:     ) internal pure {\n331:         \n332:         if (considerations.length == 0) {\n333:             revert Errors.CreatePolicy_ConsiderationCountZero();\n334:         }\n335: \n336:         \n337:         for (uint256 i; i < considerations.length; ++i) {\n338:             \n339:             ReceivedItem memory consideration = considerations[i];\n340: \n341:             \n342:             if (!consideration.isERC20()) {\n343:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n344:                     consideration.itemType\n345:                 );\n346:             }\n347: \n348:             \n349:             \n350:             rentalItems[i + startIndex] = Item({\n351:                 itemType: ItemType.ERC20,\n352:                 settleTo: SettleTo.LENDER,\n353:                 token: consideration.token,\n354:                 amount: consideration.amount,\n355:                 identifier: consideration.identifier\n356:             });\n357:         }\n358:     }\n\n```\n",
          "loc": [
            "[326](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L326-L326)"
          ]
        },
        {
          "content": "```solidity\n367:     function _processPayeeOrderConsideration(\n368:         ReceivedItem[] memory considerations\n369:     ) internal pure {\n370:         \n371:         uint256 totalRentals;\n372:         uint256 totalPayments;\n373: \n374:         \n375:         for (uint256 i; i < considerations.length; ++i) {\n376:             \n377:             ReceivedItem memory consideration = considerations[i];\n378: \n379:             \n380:             if (consideration.isERC20()) {\n381:                 totalPayments++;\n382:             }\n383:             \n384:             else if (consideration.isRental()) {\n385:                 totalRentals++;\n386:             }\n387:             \n388:             else {\n389:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n390:                     consideration.itemType\n391:                 );\n392:             }\n393:         }\n394: \n395:         \n396:         if (totalRentals == 0 || totalPayments == 0) {\n397:             revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n398:         }\n399:     }\n\n```\n",
          "loc": [
            "[367](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L367-L367)"
          ]
        },
        {
          "content": "```solidity\n464:     function _addHooks(\n465:         Hook[] memory hooks,\n466:         SpentItem[] memory offerItems,\n467:         address rentalWallet\n468:     ) internal {\n469:         \n470:         address target;\n471:         uint256 itemIndex;\n472:         SpentItem memory offer;\n473: \n474:         \n475:         for (uint256 i = 0; i < hooks.length; ++i) {\n476:             \n477:             target = hooks[i].target;\n478: \n479:             \n480:             if (!STORE.hookOnStart(target)) {\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             \n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             \n488:             offer = offerItems[itemIndex];\n489: \n490:             \n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             \n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 \n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) {\n508:                 \n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 \n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n514:                 );\n515:             } catch (bytes memory revertData) {\n516:                 \n517:                 revert Errors.Shared_HookFailBytes(revertData);\n518:             }\n519:         }\n520:     }\n\n```\n",
          "loc": [
            "[464](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L464-L464)"
          ]
        },
        {
          "content": "```solidity\n530:     function _rentFromZone(\n531:         RentPayload memory payload,\n532:         SeaportPayload memory seaportPayload\n533:     ) internal {\n534:         \n535:         _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n536: \n537:         \n538:         _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n539: \n540:         \n541:         _executionInvariantChecks(\n542:             seaportPayload.totalExecutions,\n543:             payload.fulfillment.recipient\n544:         );\n545: \n546:         \n547:         \n548:         Item[] memory items = _convertToItems(\n549:             seaportPayload.offer,\n550:             seaportPayload.consideration,\n551:             payload.metadata.orderType\n552:         );\n553: \n554:         \n555:         \n556:         if (\n557:             payload.metadata.orderType.isBaseOrder() ||\n558:             payload.metadata.orderType.isPayOrder()\n559:         ) {\n560:             \n561:             \n562:             \n563:             bytes memory rentalAssetUpdates = new bytes(0);\n564: \n565:             \n566:             \n567:             for (uint256 i; i < items.length; ++i) {\n568:                 if (items[i].isRental()) {\n569:                     \n570:                     _insert(\n571:                         rentalAssetUpdates,\n572:                         items[i].toRentalId(payload.fulfillment.recipient),\n573:                         items[i].amount\n574:                     );\n575:                 }\n576:             }\n577: \n578:             \n579:             RentalOrder memory order = RentalOrder({\n580:                 seaportOrderHash: seaportPayload.orderHash,\n581:                 items: items,\n582:                 hooks: payload.metadata.hooks,\n583:                 orderType: payload.metadata.orderType,\n584:                 lender: seaportPayload.offerer,\n585:                 renter: payload.intendedFulfiller,\n586:                 rentalWallet: payload.fulfillment.recipient,\n587:                 startTimestamp: block.timestamp,\n588:                 endTimestamp: block.timestamp + payload.metadata.rentDuration\n589:             });\n590: \n591:             \n592:             bytes32 orderHash = _deriveRentalOrderHash(order);\n593: \n594:             \n595:             STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n596: \n597:             \n598:             \n599:             for (uint256 i = 0; i < items.length; ++i) {\n600:                 if (items[i].isERC20()) {\n601:                     ESCRW.increaseDeposit(items[i].token, items[i].amount);\n602:                 }\n603:             }\n604: \n605:             \n606:             if (payload.metadata.hooks.length > 0) {\n607:                 _addHooks(\n608:                     payload.metadata.hooks,\n609:                     seaportPayload.offer,\n610:                     payload.fulfillment.recipient\n611:                 );\n612:             }\n613: \n614:             \n615:             _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n616:         }\n617:     }\n\n```\n",
          "loc": [
            "[530](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530-L530)"
          ]
        },
        {
          "content": "```solidity\n691:     function _executionInvariantChecks(\n692:         ReceivedItem[] memory executions,\n693:         address expectedRentalSafe\n694:     ) internal view {\n695:         for (uint256 i = 0; i < executions.length; ++i) { // <= FOUND\n696:             ReceivedItem memory execution = executions[i];\n697: \n698:             \n699:             if (execution.isERC20()) {\n700:                 _checkExpectedRecipient(execution, address(ESCRW));\n701:             }\n702:             \n703:             \n704:             else if (execution.isRental()) {\n705:                 _checkExpectedRecipient(execution, expectedRentalSafe);\n706:             }\n707:             \n708:             else {\n709:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n710:                     execution.itemType\n711:                 );\n712:             }\n713:         }\n714:     }\n\n```\n",
          "loc": [
            "[691](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L691-L695)"
          ]
        },
        {
          "content": "```solidity\n194:     function _removeHooks(\n195:         Hook[] calldata hooks,\n196:         Item[] calldata rentalItems,\n197:         address rentalWallet\n198:     ) internal {\n199:         \n200:         address target;\n201:         uint256 itemIndex;\n202:         Item memory item;\n203: \n204:         \n205:         for (uint256 i = 0; i < hooks.length; ++i) {\n206:             \n207:             target = hooks[i].target;\n208: \n209:             \n210:             if (!STORE.hookOnStop(target)) {\n211:                 revert Errors.Shared_DisabledHook(target);\n212:             }\n213: \n214:             \n215:             itemIndex = hooks[i].itemIndex;\n216: \n217:             \n218:             item = rentalItems[itemIndex];\n219: \n220:             \n221:             if (!item.isRental()) {\n222:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n223:             }\n224: \n225:             \n226:             try\n227:                 IHook(target).onStop(\n228:                     rentalWallet,\n229:                     item.token,\n230:                     item.identifier,\n231:                     item.amount,\n232:                     hooks[i].extraData\n233:                 )\n234:             {} catch Error(string memory revertReason) {\n235:                 \n236:                 revert Errors.Shared_HookFailString(revertReason);\n237:             } catch Panic(uint256 errorCode) {\n238:                 \n239:                 string memory stringErrorCode = LibString.toString(errorCode);\n240: \n241:                 \n242:                 revert Errors.Shared_HookFailString(\n243:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n244:                 );\n245:             } catch (bytes memory revertData) {\n246:                 \n247:                 revert Errors.Shared_HookFailBytes(revertData);\n248:             }\n249:         }\n250:     }\n\n```\n",
          "loc": [
            "[194](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L194-L194)"
          ]
        },
        {
          "content": "```solidity\n265:     function stopRent(RentalOrder calldata order) external { // <= FOUND\n266:         \n267:         _validateRentalCanBeStoped(order.orderType, order.endTimestamp, order.lender);\n268: \n269:         \n270:         \n271:         \n272:         bytes memory rentalAssetUpdates = new bytes(0);\n273: \n274:         \n275:         \n276:         for (uint256 i; i < order.items.length; ++i) {\n277:             if (order.items[i].isRental()) {\n278:                 \n279:                 _insert(\n280:                     rentalAssetUpdates,\n281:                     order.items[i].toRentalId(order.rentalWallet),\n282:                     order.items[i].amount\n283:                 );\n284:             }\n285:         }\n286: \n287:         \n288:         if (order.hooks.length > 0) {\n289:             _removeHooks(order.hooks, order.items, order.rentalWallet);\n290:         }\n291: \n292:         \n293:         _reclaimRentedItems(order);\n294: \n295:         \n296:         ESCRW.settlePayment(order);\n297: \n298:         \n299:         STORE.removeRentals(\n300:             _deriveRentalOrderHash(order),\n301:             _convertToStatic(rentalAssetUpdates)\n302:         );\n303: \n304:         \n305:         _emitRentalOrderStopped(order.seaportOrderHash, msg.sender);\n306:     }\n\n```\n",
          "loc": [
            "[265](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265-L265)"
          ]
        },
        {
          "content": "```solidity\n313:     function stopRentBatch(RentalOrder[] calldata orders) external { // <= FOUND\n314:         \n315:         bytes32[] memory orderHashes = new bytes32[](orders.length);\n316: \n317:         \n318:         \n319:         \n320:         bytes memory rentalAssetUpdates = new bytes(0);\n321: \n322:         \n323:         \n324:         for (uint256 i = 0; i < orders.length; ++i) {\n325:             \n326:             _validateRentalCanBeStoped(\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             \n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) {\n334:                 \n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert(\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             \n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n346: \n347:             \n348:             if (orders[i].hooks.length > 0) {\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n350:             }\n351: \n352:             \n353:             _reclaimRentedItems(orders[i]);\n354: \n355:             \n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:         }\n358: \n359:         \n360:         ESCRW.settlePaymentBatch(orders);\n361: \n362:         \n\n```\n",
          "loc": [
            "[313](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L313-L313)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Mapping arrays can grow in size without a way to shrink them",
      "description": "It's a good practice to maintain control over the size of array mappings in Solidity, especially if they are dynamically updated. If a contract includes a mechanism to push items into an array, it should ideally also provide a mechanism to remove items. This is because Solidity arrays don't automatically shrink when items are deleted - their length needs to be manually adjusted.\n\nIgnoring this can lead to bloated and inefficient contracts. For instance, iterating over a large array can cause your contract to hit the block gas limit. Additionally, if entries are only marked for deletion but never actually removed, you may end up dealing with stale or irrelevant data, which can cause logical errors.\n\nTherefore, implementing a method to 'pop' items from mapping arrays helps manage contract's state, improve efficiency and prevent potential issues related to gas limits or stale data. Always ensure to handle potential underflow conditions when popping elements from the mapping array.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n217:     mapping(Keycode => Policy[]) public moduleDependents; // <= FOUND\n\n```\n",
          "loc": [
            "[217](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L217-L217)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Consider implementing two-step procedure for updating protocol addresses",
      "description": "Implementing a two-step procedure for updating protocol addresses adds an extra layer of security. In such a system, the first step initiates the change, and the second step, after a predefined delay, confirms and finalizes it. This delay allows stakeholders or monitoring tools to observe and react to unintended or malicious changes. If an unauthorized change is detected, corrective actions can be taken before the change is finalized. To achieve this, introduce a \"proposed address\" state variable and a \"delay period\". Upon an update request, set the \"proposed address\". After the delay, if not contested, the main protocol address can be updated.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n362:     function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") { // <= FOUND\n363:         STORE.updateHookPath(to, hook);\n364:     }\n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L362-L362)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Unbounded state array which is iterated upon",
      "description": "Reason: In Solidity, iteration over large arrays can lead to excessive gas consumption. In the worst case scenario, if the array size exceeds the block gas limit, it could make the operation unfeasible. This is a common problem for operations like token distribution, where one might iterate over an array of holders.\n\nResolution: To prevent gas problems, limit the size of arrays that will be iterated over. Implement an alternative data structure, such as a linked list, which allows for partial iteration. Another solution could be paginated processing, where elements are processed in smaller batches over multiple transactions. Lastly, the use of 'state array' with a separate index-tracking array can also help manage large datasets.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n418:     function _activatePolicy(Policy policy_) internal { // <= FOUND\n419:         \n420:         if (policy_.isActive())\n421:             revert Errors.Kernel_PolicyAlreadyApproved(address(policy_));\n422: \n423:         \n424:         Permissions[] memory requests = policy_.requestPermissions();\n425:         _setPolicyPermissions(policy_, requests, true);\n426: \n427:         \n428:         activePolicies.push(policy_);\n429: \n430:         \n431:         getPolicyIndex[policy_] = activePolicies.length - 1;\n432: \n433:         \n434:         Keycode[] memory dependencies = policy_.configureDependencies();\n435:         uint256 depLength = dependencies.length;\n436: \n437:         \n438:         for (uint256 i; i < depLength; ++i) {\n439:             Keycode keycode = dependencies[i];\n440: \n441:             \n442:             moduleDependents[keycode].push(policy_);\n443: \n444:             \n445:             getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n446:         }\n447: \n448:         \n449:         policy_.setActiveStatus(true);\n450:     }\n\n```\n",
          "loc": [
            "[418](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L418-L418)"
          ]
        },
        {
          "content": "```solidity\n508:     function _migrateKernel(Kernel newKernel_) internal { // <= FOUND\n509:         uint256 keycodeLen = allKeycodes.length;\n510: \n511:         \n512:         for (uint256 i; i < keycodeLen; ++i) {\n513:             \n514:             Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n515:             \n516:             module.changeKernel(newKernel_);\n517:         }\n518: \n519:         \n520:         uint256 policiesLen = activePolicies.length;\n521:         for (uint256 j; j < policiesLen; ++j) {\n522:             \n523:             Policy policy = activePolicies[j];\n524: \n525:             \n526:             policy.setActiveStatus(false);\n527: \n528:             \n529:             policy.changeKernel(newKernel_);\n530:         }\n531:     }\n\n```\n",
          "loc": [
            "[508](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L508-L508)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "External calls in modifiers should be avoided",
      "description": "External calls within modifiers can introduce unintended reentrancy risks and obscure the flow of a contract's logic. Modifiers are designed to perform checks before executing function logic, and using external calls can make the flow unpredictable due to the potential for state changes or reentrancy by the called contract. Such ambiguity makes code harder to audit and understand. To ensure clarity and security, avoid external calls in modifiers. Instead, place them in the function body, where their execution order and effects are more explicit. This practice enhances contract readability, aids auditors, and minimizes unexpected behaviors.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n77:     modifier permissioned() { // <= FOUND\n78:         if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig)) {\n79:             revert Errors.Module_PolicyNotAuthorized(msg.sender); // <= FOUND\n80:         }\n81:         _;\n82:     }\n\n```\n",
          "loc": [
            "[77](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L77-L79)"
          ]
        },
        {
          "content": "```solidity\n130:     modifier onlyRole(bytes32 role_) { // <= FOUND\n131:         Role role = toRole(role_);\n132:         if (!kernel.hasRole(msg.sender, role)) {\n133:             revert Errors.Policy_OnlyRole(role); // <= FOUND\n134:         }\n135:         _;\n136:     }\n\n```\n",
          "loc": [
            "[130](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L130-L133)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Prefer skip over revert model in iteration",
      "description": "It is preferable to skip operations on an array index when a condition is not met rather than reverting the whole transaction as reverting can introduce the possiblity of malicous actors purposefully introducing array objects which fail conditional checks within for/while loops so group operations fail. As such it is recommended to simply skip such array indices over reverting unless there is a valid security or logic reason behind not doing so.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n249:        for (uint256 i = 0; i < orderHashes.length; ++i) { // <= FOUND\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]); // <= FOUND\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n\n```\n",
          "loc": [
            "[249](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L249-L252)"
          ]
        },
        {
          "content": "```solidity\n475:        for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n476:             \n477:             target = hooks[i].target;\n478: \n479:             \n480:             if (!STORE.hookOnStart(target)) {\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             \n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             \n488:             offer = offerItems[itemIndex];\n489: \n490:             \n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             \n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 \n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) {\n508:                 \n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 \n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n514:                 );\n515:             } catch (bytes memory revertData) {\n516:                 \n517:                 revert Errors.Shared_HookFailBytes(revertData);\n518:             }\n519:         }\n\n```\n",
          "loc": [
            "[475](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L475-L475)"
          ]
        },
        {
          "content": "```solidity\n205:        for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n206:             \n207:             target = hooks[i].target;\n208: \n209:             \n210:             if (!STORE.hookOnStop(target)) {\n211:                 revert Errors.Shared_DisabledHook(target);\n212:             }\n213: \n214:             \n215:             itemIndex = hooks[i].itemIndex;\n216: \n217:             \n218:             item = rentalItems[itemIndex];\n219: \n220:             \n221:             if (!item.isRental()) {\n222:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n223:             }\n224: \n225:             \n226:             try\n227:                 IHook(target).onStop(\n228:                     rentalWallet,\n229:                     item.token,\n230:                     item.identifier,\n231:                     item.amount,\n232:                     hooks[i].extraData\n233:                 )\n234:             {} catch Error(string memory revertReason) {\n235:                 \n236:                 revert Errors.Shared_HookFailString(revertReason);\n237:             } catch Panic(uint256 errorCode) {\n238:                 \n239:                 string memory stringErrorCode = LibString.toString(errorCode);\n240: \n241:                 \n242:                 revert Errors.Shared_HookFailString(\n243:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n244:                 );\n245:             } catch (bytes memory revertData) {\n246:                 \n247:                 revert Errors.Shared_HookFailBytes(revertData);\n248:             }\n249:         }\n\n```\n",
          "loc": [
            "[205](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L205-L205)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Address collision possible due to upcast",
      "description": "Upcasting addresses and comparing them to larger uint types can risk address collisions in smart contracts, potentially introducing vulnerabilities. Specifically, if a uint160 address is upcast to a uint256 and compared with larger values, the comparison may pass incorrectly if the larger value, when cast back down, matches the address. Therefore, checks designed to gate access to certain addresses might erroneously permit access when larger values are used. To mitigate this, ensure type consistency during comparisonsâ€”compare uint160 to uint160 and utilize explicit type conversions cautiously.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n94: \n95:         \n96:         return address(uint160(uint256(addressHash))); // <= FOUND\n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L94-L96)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Use of abi.encodePacked with dynamic types inside keccak256",
      "description": "Using abi.encodePacked with dynamic types for hashing functions like keccak256 can be risky due to the potential for hash collisions. This function concatenates arguments tightly, without padding, which might lead to different inputs producing the same hash. This is especially problematic with dynamic types, where the boundaries between inputs can blur. To mitigate this, use abi.encode instead. abi.encode pads its arguments to 32 bytes, creating clear distinctions between different inputs and significantly reducing the chance of hash collisions. This approach ensures more reliable and collision-resistant hashing, crucial for maintaining data integrity and security in smart contracts.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n181: \n182:         return\n183:             keccak256(\n184:                 abi.encode(\n185:                     _RENTAL_ORDER_TYPEHASH,\n186:                     order.seaportOrderHash,\n187:                     keccak256(abi.encodePacked(itemHashes)), // <= FOUND\n188:                     keccak256(abi.encodePacked(hookHashes)), // <= FOUND\n189:                     order.orderType,\n190:                     order.lender,\n191:                     order.renter,\n192:                     order.startTimestamp,\n193:                     order.endTimestamp\n194:                 )\n195:             );\n\n```\n",
          "loc": [
            "[187](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L187-L188)"
          ]
        },
        {
          "content": "```solidity\n231: \n232:         \n233:         return\n234:             keccak256(\n235:                 abi.encode(\n236:                     _ORDER_METADATA_TYPEHASH,\n237:                     metadata.rentDuration,\n238:                     keccak256(abi.encodePacked(hookHashes)) // <= FOUND\n239:                 )\n240:             );\n\n```\n",
          "loc": [
            "[238](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L238-L238)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Constructors missing validation",
      "description": "In Solidity, when values are being assigned in constructors to unsigned or integer variables, it's crucial to ensure the provided values adhere to the protocol's specific operational boundaries as laid out in the project specifications and documentation. If the constructors lack appropriate validation checks, there's a risk of setting state variables with values that could cause unexpected and potentially detrimental behavior within the contract's operations, violating the intended logic of the protocol. This can compromise the contract's security and impact the maintainability and reliability of the system. In order to avoid such issues, it is recommended to incorporate rigorous validation checks in constructors. These checks should align with the project's defined rules and constraints, making use of Solidity's built-in require function to enforce these conditions. If the validation checks fail, the require function will cause the transaction to revert, ensuring the integrity and adherence to the protocol's expected behavior.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n49:     constructor(\n50:         Kernel kernel_,\n51:         Stop stopPolicy_,\n52:         Guard guardPolicy_,\n53:         TokenCallbackHandler fallbackHandler_,\n54:         SafeProxyFactory safeProxyFactory_,\n55:         SafeL2 safeSingleton_\n56:     ) Policy(kernel_) {\n57:         stopPolicy = stopPolicy_; // <= FOUND ' = stopPolicy_;'\n58:         guardPolicy = guardPolicy_; // <= FOUND ' = guardPolicy_;'\n59:         fallbackHandler = fallbackHandler_; // <= FOUND ' = fallbackHandler_;'\n60:         safeProxyFactory = safeProxyFactory_; // <= FOUND ' = safeProxyFactory_;'\n61:         safeSingleton = safeSingleton_; // <= FOUND ' = safeSingleton_;'\n62:     }\n\n```\n",
          "loc": [
            "[49](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L49-L61)"
          ]
        },
        {
          "content": "```solidity\n33:     constructor(Kernel kernel_) {\n34:         kernel = kernel_; // <= FOUND ' = kernel_;'\n35:     }\n\n```\n",
          "loc": [
            "[33](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L33-L34)"
          ]
        },
        {
          "content": "```solidity\n242:     constructor(address _executor, address _admin) {\n243:         executor = _executor; // <= FOUND ' = _executor;'\n244:         admin = _admin; // <= FOUND ' = _admin;'\n245:     }\n\n```\n",
          "loc": [
            "[242](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L242-L244)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Functions calling contracts/addresses with transfer hooks are missing reentrancy guards",
      "description": "While adherence to the check-effects-interaction pattern is commendable, the absence of a reentrancy guard in functions, especially where transfer hooks might be present, can expose the protocol users to risks of read-only reentrancies. Such reentrancy vulnerabilities can be exploited to execute malicious actions even without altering the contract state. Without a reentrancy guard, the only potential mitigation would be to blocklist the entire protocol - an extreme and disruptive measure. Therefore, incorporating a reentrancy guard into these functions is vital to bolster security, as it helps protect against both traditional reentrancy attacks and read-only reentrancies, ensuring robust and safe protocol operations.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n159:     function _settlePaymentProRata(\n160:         address token,\n161:         uint256 amount,\n162:         address lender,\n163:         address renter,\n164:         uint256 elapsedTime,\n165:         uint256 totalTime\n166:     ) internal {\n167:         \n168:         (uint256 renterAmount, uint256 lenderAmount) = _calculatePaymentProRata(\n169:             amount,\n170:             elapsedTime,\n171:             totalTime\n172:         );\n173: \n174:         \n175:         _safeTransfer(token, lender, lenderAmount);\n176: \n177:         \n178:         _safeTransfer(token, renter, renterAmount);\n179:     }\n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n190:     function _settlePaymentInFull(\n191:         address token,\n192:         uint256 amount,\n193:         SettleTo settleTo,\n194:         address lender,\n195:         address renter\n196:     ) internal {\n197:         \n198:         address settleToAddress = settleTo == SettleTo.LENDER ? lender : renter;\n199: \n200:         \n201:         _safeTransfer(token, settleToAddress, amount);\n202:     }\n\n```\n",
          "loc": [
            "[190](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L190-L190)"
          ]
        },
        {
          "content": "```solidity\n397:     function skim(address token, address to) external onlyByProxy permissioned { // <= FOUND\n398:         \n399:         uint256 syncedBalance = balanceOf[token];\n400: \n401:         \n402:         uint256 trueBalance = IERC20(token).balanceOf(address(this));\n403: \n404:         \n405:         uint256 skimmedBalance = trueBalance - syncedBalance;\n406: \n407:         \n408:         _safeTransfer(token, to, skimmedBalance);\n409: \n410:         \n411:         emit Events.FeeTaken(token, skimmedBalance);\n412:     }\n\n```\n",
          "loc": [
            "[397](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L397-L397)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Inconsistent checks of address params against address(0)",
      "description": "Only some address parameters are checked against address(0), to ensure consistency ensure all address parameters are checked.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n309:     function checkTransaction(\n310:         address to, // <= FOUND 'address to'\n311:         uint256 value,\n312:         bytes memory data,\n313:         Enum.Operation operation,\n314:         uint256,\n315:         uint256,\n316:         uint256,\n317:         address,\n318:         address payable, // <= FOUND 'address payable'\n319:         bytes memory,\n320:         address\n321:     ) external override {\n322:         \n323:         \n324:         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n325:             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n326:         }\n327: \n328:         \n329:         if (data.length < 4) {\n330:             revert Errors.GuardPolicy_FunctionSelectorRequired();\n331:         }\n332: \n333:         \n334:         address hook = STORE.contractToHook(to); // <= FOUND 'address hook'\n335:         bool isActive = STORE.hookOnTransaction(hook);\n336: \n337:         \n338:         if (hook != address(0) && isActive) {\n339:             _forwardToHook(hook, msg.sender, to, value, data);\n340:         }\n341:         \n342:         else {\n343:             _checkTransaction(msg.sender, to, data);\n344:         }\n345:     }\n\n```\n",
          "loc": [
            "[309](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L309-L334)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Upgradeable contract uses non-upgradeable version of the OpenZeppelin libraries/contracts",
      "description": "Using the upgradeable counterpart of the OpenZeppelin (OZ) library in Solidity is beneficial for creating contracts that can be updated in the future. OpenZeppelin's upgradeable contracts library is designed with proxy patterns in mind, which allow the logic of contracts to be upgraded while preserving the contract's state and address. This can be crucial for long-lived contracts where future requirements or improvements may not be fully known at the time of deployment. The upgradeable OZ contracts also include protection against a class of vulnerabilities related to initialization of storage variables in upgradeable contracts. Hence, it's a good idea to use them when developing contracts that may need to be upgraded in the future, as they provide a solid foundation for secure and upgradeable smart contracts.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n4: import {IERC721} from \"@openzeppelin-contracts/token/ERC721/IERC721.sol\"; // <= FOUND 'openzeppelin'\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n4: import {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\"; // <= FOUND 'openzeppelin'\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n5: import {IERC1155} from \"@openzeppelin-contracts/token/ERC1155/IERC1155.sol\"; // <= FOUND 'openzeppelin'\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n4: import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\"; // <= FOUND 'openzeppelin'\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L4-L4)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Functions calling contracts/addresses with transfer hooks are missing reentrancy guards",
      "description": "While adherence to the check-effects-interaction pattern is commendable, the absence of a reentrancy guard in functions, especially where transfer hooks might be present, can expose the protocol users to risks of read-only reentrancies. Such reentrancy vulnerabilities can be exploited to execute malicious actions even without altering the contract state. Without a reentrancy guard, the only potential mitigation would be to blocklist the entire protocol - an extreme and disruptive measure. Therefore, incorporating a reentrancy guard into these functions is vital to bolster security, as it helps protect against both traditional reentrancy attacks and read-only reentrancies, ensuring robust and safe protocol operations.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n159:     function _settlePaymentProRata(\n160:         address token,\n161:         uint256 amount,\n162:         address lender,\n163:         address renter,\n164:         uint256 elapsedTime,\n165:         uint256 totalTime\n166:     ) internal {\n167:         \n168:         (uint256 renterAmount, uint256 lenderAmount) = _calculatePaymentProRata(\n169:             amount,\n170:             elapsedTime,\n171:             totalTime\n172:         );\n173: \n174:         \n175:         _safeTransfer(token, lender, lenderAmount); // <= FOUND\n176: \n177:         \n178:         _safeTransfer(token, renter, renterAmount); // <= FOUND\n179:     }\n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L159-L178)"
          ]
        },
        {
          "content": "```solidity\n190:     function _settlePaymentInFull(\n191:         address token,\n192:         uint256 amount,\n193:         SettleTo settleTo,\n194:         address lender,\n195:         address renter\n196:     ) internal {\n197:         \n198:         address settleToAddress = settleTo == SettleTo.LENDER ? lender : renter;\n199: \n200:         \n201:         _safeTransfer(token, settleToAddress, amount); // <= FOUND\n202:     }\n\n```\n",
          "loc": [
            "[190](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L190-L201)"
          ]
        },
        {
          "content": "```solidity\n397:     function skim(address token, address to) external onlyByProxy permissioned {\n398:         \n399:         uint256 syncedBalance = balanceOf[token];\n400: \n401:         \n402:         uint256 trueBalance = IERC20(token).balanceOf(address(this));\n403: \n404:         \n405:         uint256 skimmedBalance = trueBalance - syncedBalance;\n406: \n407:         \n408:         _safeTransfer(token, to, skimmedBalance); // <= FOUND\n409: \n410:         \n411:         emit Events.FeeTaken(token, skimmedBalance);\n412:     }\n\n```\n",
          "loc": [
            "[397](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L397-L408)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Upgradable contracts not taken into account",
      "description": "When wrapping a token address with interfaces like IERC20 for external calls, especially in the context of upgradable contracts, it's essential to account for the potential changes these tokens might undergo. Upgrades can modify a token's behavior or interface, which could introduce compatibility issues or vulnerabilities in the interacting protocol.\n\n**Resolution:**\nTo manage this risk, integrate an allowlist system in your protocol. This system would monitor for upgrades in token contracts. Upon detecting an upgrade, the corresponding token contract would be automatically removed from the allowlist, suspending its interaction with your protocol. The contract can only be re-added to the allowlist after a thorough review to confirm its continued compatibility and safety post-upgrade. This approach helps maintain a secure and adaptable protocol, ensuring it only interacts with verified, stable versions of external contracts. Regular audits and ongoing monitoring of these external contracts are vital for maintaining the integrity and security of the protocol.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n397:     function skim(address token, address to) external onlyByProxy permissioned { // <= FOUND\n398:         \n399:         uint256 syncedBalance = balanceOf[token];\n400: \n401:         \n402:         uint256 trueBalance = IERC20(token).balanceOf(address(this));\n403: \n404:         \n405:         uint256 skimmedBalance = trueBalance - syncedBalance;\n406: \n407:         \n408:         _safeTransfer(token, to, skimmedBalance);\n409: \n410:         \n411:         emit Events.FeeTaken(token, skimmedBalance);\n412:     }\n\n```\n",
          "loc": [
            "[397](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L397-L397)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Floating pragma should be avoided",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: pragma solidity ^0.8.20; // <= FOUND\n\n```\n",
          "loc": [
            "[2](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L2-L2)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Empty function blocks",
      "description": "Empty code blocks (i.e., {}) in a Solidity contract can be harmful as they can lead to ambiguity, misinterpretation, and unintended behavior. When developers encounter empty code blocks, it may be unclear whether the absence of code is intentional or the result of an oversight. This uncertainty can cause confusion during development, testing, and debugging, increasing the likelihood of introducing errors or vulnerabilities. Moreover, empty code blocks may give a false impression of implemented functionality or security measures, creating a misleading sense of assurance. To ensure clarity and maintainability, it is essential to avoid empty code blocks and explicitly document the intended behavior or any intentional omissions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n353:     function checkAfterExecution(bytes32 txHash, bool success) external override {}\n\n```\n",
          "loc": [
            "[353](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L353-L353)"
          ]
        },
        {
          "content": "```solidity\n100:     function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L100-L100)"
          ]
        },
        {
          "content": "```solidity\n106:     function INIT() external virtual onlyKernel {}\n\n```\n",
          "loc": [
            "[106](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L106-L106)"
          ]
        },
        {
          "content": "```solidity\n148:     function configureDependencies()\n149:         external\n150:         virtual\n151:         onlyKernel\n152:         returns (Keycode[] memory dependencies)\n153:     {}\n\n```\n",
          "loc": [
            "[148](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L148-L148)"
          ]
        },
        {
          "content": "```solidity\n166:     function requestPermissions()\n167:         external\n168:         view\n169:         virtual\n170:         onlyKernel\n171:         returns (Permissions[] memory requests)\n172:     {}\n\n```\n",
          "loc": [
            "[166](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L166-L166)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "In functions which accept an address as a parameter, there should be a zero address check to prevent bugs",
      "description": "In smart contract development, especially with Solidity, it's crucial to validate inputs to functions. When a function accepts an Ethereum address as a parameter, implementing a zero address check (i.e., ensuring the address is not `0x0`) is a best practice to prevent potential bugs and vulnerabilities. The zero address (`0x0`) is a default value and generally indicates an uninitialized or invalid state. Passing the zero address to certain functions can lead to unintended behaviors, like funds getting locked permanently or transactions failing silently. By checking for and rejecting the zero address, developers can ensure that the function operates as intended and interacts only with valid Ethereum addresses. This check enhances the contract's robustness and security.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n100:     function _safeTransfer(address token, address to, uint256 value) internal \n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L100-L100)"
          ]
        },
        {
          "content": "```solidity\n159:     function _settlePaymentProRata(\n160:         address token,\n161:         uint256 amount,\n162:         address lender,\n163:         address renter,\n164:         uint256 elapsedTime,\n165:         uint256 totalTime\n166:     ) internal \n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n190:     function _settlePaymentInFull(\n191:         address token,\n192:         uint256 amount,\n193:         SettleTo settleTo,\n194:         address lender,\n195:         address renter\n196:     ) internal \n\n```\n",
          "loc": [
            "[190](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L190-L190)"
          ]
        },
        {
          "content": "```solidity\n215:     function _settlePayment(\n216:         Item[] calldata items,\n217:         OrderType orderType,\n218:         address lender,\n219:         address renter,\n220:         uint256 start,\n221:         uint256 end\n222:     ) internal \n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L215-L215)"
          ]
        },
        {
          "content": "```solidity\n292:     function _decreaseDeposit(address token, uint256 amount) internal \n\n```\n",
          "loc": [
            "[292](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L292-L292)"
          ]
        },
        {
          "content": "```solidity\n304:     function _increaseDeposit(address token, uint256 amount) internal \n\n```\n",
          "loc": [
            "[304](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L304-L304)"
          ]
        },
        {
          "content": "```solidity\n361:     function increaseDeposit(\n362:         address token,\n363:         uint256 amount\n364:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[361](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L361-L361)"
          ]
        },
        {
          "content": "```solidity\n397:     function skim(address token, address to) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[397](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L397-L397)"
          ]
        },
        {
          "content": "```solidity\n360:     function upgrade(address newImplementation) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[360](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L360-L360)"
          ]
        },
        {
          "content": "```solidity\n118:     function isRentedOut(\n119:         address recipient,\n120:         address token,\n121:         uint256 identifier\n122:     ) external view returns (bool) \n\n```\n",
          "loc": [
            "[118](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L118-L118)"
          ]
        },
        {
          "content": "```solidity\n135:     function contractToHook(address to) external view returns (address) \n\n```\n",
          "loc": [
            "[135](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L135-L135)"
          ]
        },
        {
          "content": "```solidity\n149:     function hookOnTransaction(address hook) external view returns (bool) \n\n```\n",
          "loc": [
            "[149](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L149-L149)"
          ]
        },
        {
          "content": "```solidity\n159:     function hookOnStart(address hook) external view returns (bool) \n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n169:     function hookOnStop(address hook) external view returns (bool) \n\n```\n",
          "loc": [
            "[169](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L169-L169)"
          ]
        },
        {
          "content": "```solidity\n274:     function addRentalSafe(address safe) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[274](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L274-L274)"
          ]
        },
        {
          "content": "```solidity\n294:     function updateHookPath(address to, address hook) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[294](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L294-L294)"
          ]
        },
        {
          "content": "```solidity\n313:     function updateHookStatus(\n314:         address hook,\n315:         uint8 bitmap\n316:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[313](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n334:     function toggleWhitelistDelegate(\n335:         address delegate,\n336:         bool isEnabled\n337:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[334](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L334-L334)"
          ]
        },
        {
          "content": "```solidity\n347:     function toggleWhitelistExtension(\n348:         address extension,\n349:         bool isEnabled\n350:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[347](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L347-L347)"
          ]
        },
        {
          "content": "```solidity\n32:     function _transferERC721(Item memory item, address recipient) private \n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L32-L32)"
          ]
        },
        {
          "content": "```solidity\n42:     function _transferERC1155(Item memory item, address recipient) private \n\n```\n",
          "loc": [
            "[42](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L42-L42)"
          ]
        },
        {
          "content": "```solidity\n76:     function _validateFulfiller(\n77:         address intendedFulfiller,\n78:         address actualFulfiller\n79:     ) internal pure \n\n```\n",
          "loc": [
            "[76](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L76-L76)"
          ]
        },
        {
          "content": "```solidity\n99:     function toggleWhitelistDelegate(\n100:         address delegate,\n101:         bool isEnabled\n102:     ) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[99](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L99-L99)"
          ]
        },
        {
          "content": "```solidity\n113:     function toggleWhitelistExtension(\n114:         address extension,\n115:         bool isEnabled\n116:     ) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[113](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n126:     function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n144:     function upgradePaymentEscrow(\n145:         address newImplementation\n146:     ) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[144](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L144-L144)"
          ]
        },
        {
          "content": "```solidity\n164:     function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[164](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L164-L164)"
          ]
        },
        {
          "content": "```solidity\n464:     function _addHooks(\n465:         Hook[] memory hooks,\n466:         SpentItem[] memory offerItems,\n467:         address rentalWallet\n468:     ) internal \n\n```\n",
          "loc": [
            "[464](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L464-L464)"
          ]
        },
        {
          "content": "```solidity\n647:     function _isValidSafeOwner(address owner, address safe) internal view \n\n```\n",
          "loc": [
            "[647](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L647-L647)"
          ]
        },
        {
          "content": "```solidity\n666:     function _checkExpectedRecipient(\n667:         ReceivedItem memory execution,\n668:         address expectedRecipient\n669:     ) internal pure \n\n```\n",
          "loc": [
            "[666](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L666-L666)"
          ]
        },
        {
          "content": "```solidity\n691:     function _executionInvariantChecks(\n692:         ReceivedItem[] memory executions,\n693:         address expectedRentalSafe\n694:     ) internal view \n\n```\n",
          "loc": [
            "[691](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L691-L691)"
          ]
        },
        {
          "content": "```solidity\n122:     function initializeRentalSafe(address _stopPolicy, address _guardPolicy) external \n\n```\n",
          "loc": [
            "[122](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L122-L122)"
          ]
        },
        {
          "content": "```solidity\n138:     function deployRentalSafe(\n139:         address[] calldata owners,\n140:         uint256 threshold\n141:     ) external returns (address safe) \n\n```\n",
          "loc": [
            "[138](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138-L138)"
          ]
        },
        {
          "content": "```solidity\n126:     function _revertSelectorOnActiveRental(\n127:         bytes4 selector,\n128:         address safe,\n129:         address token,\n130:         uint256 tokenId\n131:     ) private view \n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n143:     function _revertNonWhitelistedExtension(address extension) private view \n\n```\n",
          "loc": [
            "[143](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L143-L143)"
          ]
        },
        {
          "content": "```solidity\n159:     function _forwardToHook(\n160:         address hook,\n161:         address safe,\n162:         address to,\n163:         uint256 value,\n164:         bytes memory data\n165:     ) private \n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n195:     function _checkTransaction(address from, address to, bytes memory data) private view \n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L195)"
          ]
        },
        {
          "content": "```solidity\n362:     function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") \n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L362-L362)"
          ]
        },
        {
          "content": "```solidity\n373:     function updateHookStatus(\n374:         address hook,\n375:         uint8 bitmap\n376:     ) external onlyRole(\"GUARD_ADMIN\") \n\n```\n",
          "loc": [
            "[373](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L373-L373)"
          ]
        },
        {
          "content": "```solidity\n111:     function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal \n\n```\n",
          "loc": [
            "[111](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L111-L111)"
          ]
        },
        {
          "content": "```solidity\n126:     function _validateRentalCanBeStoped(\n127:         OrderType orderType,\n128:         uint256 endTimestamp,\n129:         address expectedLender\n130:     ) internal view \n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n194:     function _removeHooks(\n195:         Hook[] calldata hooks,\n196:         Item[] calldata rentalItems,\n197:         address rentalWallet\n198:     ) internal \n\n```\n",
          "loc": [
            "[194](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L194-L194)"
          ]
        },
        {
          "content": "```solidity\n107:     function generateSaltWithSender(\n108:         address sender,\n109:         bytes12 data\n110:     ) public pure returns (bytes32 salt) \n\n```\n",
          "loc": [
            "[107](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L107-L107)"
          ]
        },
        {
          "content": "```solidity\n277:     function executeAction(Actions action_, address target_) external onlyExecutor \n\n```\n",
          "loc": [
            "[277](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L277-L277)"
          ]
        },
        {
          "content": "```solidity\n310:     function grantRole(Role role_, address addr_) public onlyAdmin \n\n```\n",
          "loc": [
            "[310](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L310-L310)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin \n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L333)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Enum values should be used in place of constant array indexes",
      "description": "Create a commented enum value to use in place of constant array indexes, this makes the code far easier to understand",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n81: \n82:         dependencies[0] = toKeycode(\"STORE\"); // <= FOUND\n\n```\n",
          "loc": [
            "[81](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L81-L82)"
          ]
        },
        {
          "content": "```solidity\n72:         requests[0] = Permissions( // <= FOUND\n73:             toKeycode(\"STORE\"),\n74:             STORE.toggleWhitelistExtension.selector\n75:         );\n\n```\n",
          "loc": [
            "[72](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L72-L72)"
          ]
        },
        {
          "content": "```solidity\n104:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentals.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[104](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L104-L104)"
          ]
        },
        {
          "content": "```solidity\n102:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentalSafe.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[102](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L102-L102)"
          ]
        },
        {
          "content": "```solidity\n92:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[92](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L92-L92)"
          ]
        },
        {
          "content": "```solidity\n95:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[95](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L95-L95)"
          ]
        },
        {
          "content": "```solidity\n83: \n84:         dependencies[1] = toKeycode(\"ESCRW\"); // <= FOUND\n\n```\n",
          "loc": [
            "[83](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L83-L84)"
          ]
        },
        {
          "content": "```solidity\n76:         requests[1] = Permissions( // <= FOUND\n77:             toKeycode(\"STORE\"),\n78:             STORE.toggleWhitelistDelegate.selector\n79:         );\n\n```\n",
          "loc": [
            "[76](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L76-L76)"
          ]
        },
        {
          "content": "```solidity\n105:         requests[1] = Permissions(toKeycode(\"ESCRW\"), ESCRW.increaseDeposit.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[105](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L105-L105)"
          ]
        },
        {
          "content": "```solidity\n93:         requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[93](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L93-L93)"
          ]
        },
        {
          "content": "```solidity\n96:         requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n80:         requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[80](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L80-L80)"
          ]
        },
        {
          "content": "```solidity\n97:         requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[97](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L97-L97)"
          ]
        },
        {
          "content": "```solidity\n81:         requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[81](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L81-L81)"
          ]
        },
        {
          "content": "```solidity\n98:         requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[98](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L98-L98)"
          ]
        },
        {
          "content": "```solidity\n83: \n84:         requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[83](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L83-L84)"
          ]
        },
        {
          "content": "```solidity\n84:         requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[84](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L84-L84)"
          ]
        },
        {
          "content": "```solidity\n85:         requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[85](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L85-L85)"
          ]
        },
        {
          "content": "```solidity\n86:         requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector); // <= FOUND\n\n```\n",
          "loc": [
            "[86](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L86-L86)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Default int values are manually set",
      "description": "In instances where a new variable is defined, there is no need to set it to it's default value.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n599: \n600:         \n601:         for (uint256 i = 0; i < items.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[599](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L599-L601)"
          ]
        },
        {
          "content": "```solidity\n324:         \n325:         for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L325)"
          ]
        },
        {
          "content": "```solidity\n197: \n198:         \n199:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[197](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L197-L199)"
          ]
        },
        {
          "content": "```solidity\n249:         \n250:         for (uint256 i = 0; i < orderHashes.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[249](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L249-L250)"
          ]
        },
        {
          "content": "```solidity\n120: \n121:         \n122:         \n123:         for (uint256 i = 0; i < rentalAssetUpdateLength; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[120](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L120-L123)"
          ]
        },
        {
          "content": "```solidity\n90: \n91:         \n92:         for (uint256 i = 0; i < itemCount; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L90-L92)"
          ]
        },
        {
          "content": "```solidity\n170: \n171:         \n172:         for (uint256 i = 0; i < order.items.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[170](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L170-L172)"
          ]
        },
        {
          "content": "```solidity\n176: \n177:         \n178:         for (uint256 i = 0; i < order.hooks.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[176](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L176-L178)"
          ]
        },
        {
          "content": "```solidity\n225: \n226:         \n227:         for (uint256 i = 0; i < metadata.hooks.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[225](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L225-L227)"
          ]
        },
        {
          "content": "```solidity\n475: \n476:         \n477:         for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[475](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L475-L477)"
          ]
        },
        {
          "content": "```solidity\n599: \n600:             \n601:             \n602:             for (uint256 i = 0; i < items.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[599](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L599-L602)"
          ]
        },
        {
          "content": "```solidity\n695:         for (uint256 i = 0; i < executions.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[695](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L695-L695)"
          ]
        },
        {
          "content": "```solidity\n324: \n325:         \n326:         \n327:         for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L327)"
          ]
        },
        {
          "content": "```solidity\n333: \n334:             \n335:             for (uint256 j = 0; j < orders[i].items.length; ++j) { // <= FOUND\n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L333-L335)"
          ]
        },
        {
          "content": "```solidity\n566:         for (uint256 i = 0; i < reqLength; ++i) { // <= FOUND\n\n```\n",
          "loc": [
            "[566](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L566-L566)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Revert statements within external and public functions can be used to perform DOS attacks",
      "description": "In Solidity, 'revert' statements are used to undo changes and throw an exception when certain conditions are not met. However, in public and external functions, improper use of `revert` can be exploited for Denial of Service (DoS) attacks. An attacker can intentionally trigger these 'revert' conditions, causing legitimate transactions to consistently fail. For example, if a function relies on specific conditions from user input or contract state, an attacker could manipulate these to continually force reverts, blocking the function's execution. Therefore, it's crucial to design contract logic to handle exceptions properly and avoid scenarios where `revert` can be predictably triggered by malicious actors. This includes careful input validation and considering alternative design patterns that are less susceptible to such abuses.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n361:     function increaseDeposit(\n362:         address token,\n363:         uint256 amount\n364:     ) external onlyByProxy permissioned {\n365:         \n366:         if (amount == 0) {\n367:             revert Errors.PaymentEscrow_ZeroPayment(); // <= FOUND\n368:         }\n369: \n370:         \n371:         _increaseDeposit(token, amount);\n372:     }\n\n```\n",
          "loc": [
            "[367](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L367-L367)"
          ]
        },
        {
          "content": "```solidity\n380:     function setFee(uint256 feeNumerator) external onlyByProxy permissioned {\n381:         \n382:         if (feeNumerator > 10000) {\n383:             revert Errors.PaymentEscrow_InvalidFeeNumerator(); // <= FOUND\n384:         }\n385: \n386:         \n387:         fee = feeNumerator;\n388:     }\n\n```\n",
          "loc": [
            "[383](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L383-L383)"
          ]
        },
        {
          "content": "```solidity\n216:     function removeRentals(\n217:         bytes32 orderHash,\n218:         RentalAssetUpdate[] calldata rentalAssetUpdates\n219:     ) external onlyByProxy permissioned {\n220:         \n221:         if (!orders[orderHash]) {\n222:             revert Errors.StorageModule_OrderDoesNotExist(orderHash); // <= FOUND\n223:         } else {\n224:             \n225:             delete orders[orderHash];\n226:         }\n227: \n228:         \n229:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n230:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n231: \n232:             \n233:             rentedAssets[asset.rentalId] -= asset.amount;\n234:         }\n235:     }\n\n```\n",
          "loc": [
            "[222](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L222-L222)"
          ]
        },
        {
          "content": "```solidity\n244:     function removeRentalsBatch(\n245:         bytes32[] calldata orderHashes,\n246:         RentalAssetUpdate[] calldata rentalAssetUpdates\n247:     ) external onlyByProxy permissioned {\n248:         \n249:         for (uint256 i = 0; i < orderHashes.length; ++i) {\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]); // <= FOUND\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n258: \n259:         \n260:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n261:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n262: \n263:             \n264:             rentedAssets[asset.rentalId] -= asset.amount;\n265:         }\n266:     }\n\n```\n",
          "loc": [
            "[252](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L252-L252)"
          ]
        },
        {
          "content": "```solidity\n294:     function updateHookPath(address to, address hook) external onlyByProxy permissioned {\n295:         \n296:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to); // <= FOUND\n297: \n298:         \n299:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n300: \n301:         \n302:         _contractToHook[to] = hook;\n303:     }\n\n```\n",
          "loc": [
            "[296](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L296-L299)"
          ]
        },
        {
          "content": "```solidity\n313:     function updateHookStatus(\n314:         address hook,\n315:         uint8 bitmap\n316:     ) external onlyByProxy permissioned {\n317:         \n318:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n319: \n320:         \n321:         if (bitmap > uint8(7))\n322:             revert Errors.StorageModule_InvalidHookStatusBitmap(bitmap); // <= FOUND\n323: \n324:         \n325:         hookStatus[hook] = bitmap;\n326:     }\n\n```\n",
          "loc": [
            "[318](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L318-L322)"
          ]
        },
        {
          "content": "```solidity\n71:     function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n72:         \n73:         if (address(this) == original) {\n74:             revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed(); // <= FOUND\n75:         }\n76: \n77:         \n78:         \n79:         \n80:         if (address(this) != rentalOrder.rentalWallet) {\n81:             revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed( // <= FOUND\n82:                 rentalOrder.rentalWallet\n83:             );\n84:         }\n85: \n86:         \n87:         uint256 itemCount = rentalOrder.items.length;\n88: \n89:         \n90:         for (uint256 i = 0; i < itemCount; ++i) {\n91:             Item memory item = rentalOrder.items[i];\n92: \n93:             \n94:             if (item.itemType == ItemType.ERC721)\n95:                 _transferERC721(item, rentalOrder.lender);\n96: \n97:             \n98:             if (item.itemType == ItemType.ERC1155)\n99:                 _transferERC1155(item, rentalOrder.lender);\n100:         }\n101:     }\n\n```\n",
          "loc": [
            "[74](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L74-L81)"
          ]
        },
        {
          "content": "```solidity\n733:     function validateOrder(\n734:         ZoneParameters calldata zoneParams\n735:     ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue) {\n736:         \n737:         (RentPayload memory payload, bytes memory signature) = abi.decode(\n738:             zoneParams.extraData,\n739:             (RentPayload, bytes)\n740:         );\n741: \n742:         \n743:         SeaportPayload memory seaportPayload = SeaportPayload({\n744:             orderHash: zoneParams.orderHash,\n745:             zoneHash: zoneParams.zoneHash,\n746:             offer: zoneParams.offer,\n747:             consideration: zoneParams.consideration,\n748:             totalExecutions: zoneParams.totalExecutions,\n749:             fulfiller: zoneParams.fulfiller,\n750:             offerer: zoneParams.offerer\n751:         });\n752: \n753:         \n754:         _validateProtocolSignatureExpiration(payload.expiration);\n755: \n756:         \n757:         _validateFulfiller(payload.intendedFulfiller, seaportPayload.fulfiller);\n758: \n759:         \n760:         address signer = _recoverSignerFromPayload(\n761:             _deriveRentPayloadHash(payload),\n762:             signature\n763:         );\n764: \n765:         \n766:         if (!kernel.hasRole(signer, toRole(\"CREATE_SIGNER\"))) {\n767:             revert Errors.CreatePolicy_UnauthorizedCreatePolicySigner(); // <= FOUND\n768:         }\n769: \n770:         \n771:         _rentFromZone(payload, seaportPayload);\n772: \n773:         \n774:         validOrderMagicValue = ZoneInterface.validateOrder.selector;\n775:     }\n\n```\n",
          "loc": [
            "[767](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L767-L767)"
          ]
        },
        {
          "content": "```solidity\n138:     function deployRentalSafe(\n139:         address[] calldata owners,\n140:         uint256 threshold\n141:     ) external returns (address safe) {\n142:         \n143:         if (threshold == 0 || threshold > owners.length) {\n144:             revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length); // <= FOUND\n145:         }\n146: \n147:         \n148:         \n149:         bytes memory data = abi.encodeCall(\n150:             Factory.initializeRentalSafe,\n151:             (address(stopPolicy), address(guardPolicy))\n152:         );\n153: \n154:         \n155:         bytes memory initializerPayload = abi.encodeCall(\n156:             ISafe.setup,\n157:             (\n158:                 \n159:                 owners,\n160:                 \n161:                 threshold,\n162:                 \n163:                 address(this),\n164:                 \n165:                 data,\n166:                 \n167:                 address(fallbackHandler),\n168:                 \n169:                 address(0),\n170:                 \n171:                 0,\n172:                 \n173:                 payable(address(0))\n174:             )\n175:         );\n176: \n177:         \n178:         \n179:         \n180:         safe = address(\n181:             safeProxyFactory.createProxyWithNonce(\n182:                 address(safeSingleton),\n183:                 initializerPayload,\n184:                 uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))\n185:             )\n186:         );\n187: \n188:         \n189:         STORE.addRentalSafe(safe);\n190: \n191:         \n192:         emit Events.RentalSafeDeployment(safe, owners, threshold);\n193:     }\n\n```\n",
          "loc": [
            "[144](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L144-L144)"
          ]
        },
        {
          "content": "```solidity\n309:     function checkTransaction(\n310:         address to,\n311:         uint256 value,\n312:         bytes memory data,\n313:         Enum.Operation operation,\n314:         uint256,\n315:         uint256,\n316:         uint256,\n317:         address,\n318:         address payable,\n319:         bytes memory,\n320:         address\n321:     ) external override {\n322:         \n323:         \n324:         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n325:             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to); // <= FOUND\n326:         }\n327: \n328:         \n329:         if (data.length < 4) {\n330:             revert Errors.GuardPolicy_FunctionSelectorRequired(); // <= FOUND\n331:         }\n332: \n333:         \n334:         address hook = STORE.contractToHook(to);\n335:         bool isActive = STORE.hookOnTransaction(hook);\n336: \n337:         \n338:         if (hook != address(0) && isActive) {\n339:             _forwardToHook(hook, msg.sender, to, value, data);\n340:         }\n341:         \n342:         else {\n343:             _checkTransaction(msg.sender, to, data);\n344:         }\n345:     }\n\n```\n",
          "loc": [
            "[325](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L325-L330)"
          ]
        },
        {
          "content": "```solidity\n32:     function deploy(\n33:         bytes32 salt,\n34:         bytes memory initCode\n35:     ) external payable returns (address deploymentAddress) {\n36:         \n37:         if (address(bytes20(salt)) != msg.sender) {\n38:             revert Errors.Create2Deployer_UnauthorizedSender(msg.sender, salt); // <= FOUND\n39:         }\n40: \n41:         \n42:         address targetDeploymentAddress = getCreate2Address(salt, initCode);\n43: \n44:         \n45:         if (deployed[targetDeploymentAddress]) {\n46:             revert Errors.Create2Deployer_AlreadyDeployed(targetDeploymentAddress, salt); // <= FOUND\n47:         }\n48: \n49:         \n50:         deployed[targetDeploymentAddress] = true;\n51: \n52:         \n53:         assembly {\n54:             deploymentAddress := create2(\n55:                 \n56:                 callvalue(),\n57:                 \n58:                 add(initCode, 0x20),\n59:                 \n60:                 mload(initCode),\n61:                 \n62:                 salt\n63:             )\n64:         }\n65: \n66:         \n67:         if (deploymentAddress != targetDeploymentAddress) {\n68:             revert Errors.Create2Deployer_MismatchedDeploymentAddress( // <= FOUND\n69:                 targetDeploymentAddress,\n70:                 deploymentAddress\n71:             );\n72:         }\n73:     }\n\n```\n",
          "loc": [
            "[38](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L38-L68)"
          ]
        },
        {
          "content": "```solidity\n310:     function grantRole(Role role_, address addr_) public onlyAdmin {\n311:         \n312:         if (hasRole[addr_][role_])\n313:             revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_); // <= FOUND\n314: \n315:         \n316:         ensureValidRole(role_);\n317: \n318:         \n319:         if (!isRole[role_]) isRole[role_] = true;\n320: \n321:         \n322:         hasRole[addr_][role_] = true;\n323: \n324:         emit Events.RoleGranted(role_, addr_);\n325:     }\n\n```\n",
          "loc": [
            "[313](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin {\n334:         \n335:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_); // <= FOUND\n336: \n337:         \n338:         if (!hasRole[addr_][role_])\n339:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_); // <= FOUND\n340: \n341:         \n342:         hasRole[addr_][role_] = false;\n343: \n344:         emit Events.RoleRevoked(role_, addr_);\n345:     }\n\n```\n",
          "loc": [
            "[335](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L335-L339)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Functions which are either private or internal should have a preceding _ in their name",
      "description": "Add a preceding underscore to the function name, take care to refactor where there functions are called",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n180:     function getModuleAddress(Keycode keycode_) internal view returns (address) \n\n```\n",
          "loc": [
            "[180](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L180-L180)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Private and internal state variables should have a preceding _ in their name unless they are constants",
      "description": "Add a preceding underscore to the state variable name, take care to refactor where there variables are read/wrote",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n17: address private immutable original; // <= FOUND\n\n```\n",
          "loc": [
            "[17](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L17-L17)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Contract lines should not be longer than 120 characters for readability",
      "description": "Consider spreading these lines over multiple lines to aid in readability and the support of VIM users everywhere.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n363:             \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\" // <= FOUND\n\n```\n",
          "loc": [
            "[363](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L363-L363)"
          ]
        },
        {
          "content": "```solidity\n390:                 \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\" // <= FOUND\n\n```\n",
          "loc": [
            "[390](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L390-L390)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Setters should prevent re-setting of the same value",
      "description": "In Solidity, manipulating contract storage comes with significant gas costs. One can optimize gas usage by preventing unnecessary storage updates when the new value is the same as the existing one. If an existing value is the same as the new one, not reassigning it to the storage could potentially save substantial amounts of gas, notably 2900 gas for a 'Gsreset'. This saving may come at the expense of a cold storage load operation ('Gcoldsload'), which costs 2100 gas, or a warm storage access operation ('Gwarmaccess'), which costs 100 gas. Therefore, the gas efficiency of your contract can be significantly improved by adding a check that compares the new value with the current one before any storage update operation. If the values are the same, you can bypass the storage operation, thereby saving gas.",
      "gasSavings": 2400,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n173:     function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") {\n174:         ESCRW.setFee(feeNumerator);\n175:     }\n\n```\n",
          "loc": [
            "[173](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L173-L173)"
          ]
        },
        {
          "content": "```solidity\n362:     function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") {\n363:         STORE.updateHookPath(to, hook);\n364:     }\n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L362-L362)"
          ]
        },
        {
          "content": "```solidity\n373:     function updateHookStatus(\n374:         address hook,\n375:         uint8 bitmap\n376:     ) external onlyRole(\"GUARD_ADMIN\") {\n377:         STORE.updateHookStatus(hook, bitmap);\n378:     }\n\n```\n",
          "loc": [
            "[373](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L373-L373)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Function names should differ to make the code more readable",
      "description": "In Solidity, while function overriding allows for functions with the same name to coexist, it is advisable to avoid this practice to enhance code readability and maintainability. Having multiple functions with the same name, even with different parameters or in inherited contracts, can cause confusion and increase the likelihood of errors during development, testing, and debugging. Using distinct and descriptive function names not only clarifies the purpose and behavior of each function, but also helps prevent unintended function calls or incorrect overriding. By adopting a clear and consistent naming convention, developers can create more comprehensible and maintainable smart contracts.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n86:     function MODULE_PROXY_INSTANTIATION( // <= FOUND\n87:         Kernel kernel_\n88:     ) external onlyByProxy onlyUninitialized \n\n```\n",
          "loc": [
            "[86](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L86-L86)"
          ]
        },
        {
          "content": "```solidity\n96:     function VERSION() external pure override returns (uint8 major, uint8 minor)  // <= FOUND\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n100:     function VERSION() external pure virtual returns (uint8 major, uint8 minor)  // <= FOUND\n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L100-L100)"
          ]
        },
        {
          "content": "```solidity\n103:     function KEYCODE() public pure override returns (Keycode)  // <= FOUND\n\n```\n",
          "loc": [
            "[103](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n360:     function upgrade(address newImplementation) external onlyByProxy permissioned  // <= FOUND\n\n```\n",
          "loc": [
            "[360](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L360-L360)"
          ]
        },
        {
          "content": "```solidity\n369:     function freeze() external onlyByProxy permissioned  // <= FOUND\n\n```\n",
          "loc": [
            "[369](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L369-L369)"
          ]
        },
        {
          "content": "```solidity\n334:     function toggleWhitelistDelegate( // <= FOUND\n335:         address delegate,\n336:         bool isEnabled\n337:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[334](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L334-L334)"
          ]
        },
        {
          "content": "```solidity\n99:     function toggleWhitelistDelegate( // <= FOUND\n100:         address delegate,\n101:         bool isEnabled\n102:     ) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[99](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L99-L99)"
          ]
        },
        {
          "content": "```solidity\n347:     function toggleWhitelistExtension( // <= FOUND\n348:         address extension,\n349:         bool isEnabled\n350:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[347](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L347-L347)"
          ]
        },
        {
          "content": "```solidity\n113:     function toggleWhitelistExtension( // <= FOUND\n114:         address extension,\n115:         bool isEnabled\n116:     ) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[113](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n397:     function skim(address token, address to) external onlyByProxy permissioned  // <= FOUND\n\n```\n",
          "loc": [
            "[397](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L397-L397)"
          ]
        },
        {
          "content": "```solidity\n164:     function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[164](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L164-L164)"
          ]
        },
        {
          "content": "```solidity\n380:     function setFee(uint256 feeNumerator) external onlyByProxy permissioned  // <= FOUND\n\n```\n",
          "loc": [
            "[380](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L380-L380)"
          ]
        },
        {
          "content": "```solidity\n173:     function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\")  // <= FOUND\n\n```\n",
          "loc": [
            "[173](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L173-L173)"
          ]
        },
        {
          "content": "```solidity\n73:     function configureDependencies() // <= FOUND\n74:         external\n75:         override\n76:         onlyKernel\n77:         returns (Keycode[] memory dependencies)\n78:     \n\n```\n",
          "loc": [
            "[73](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L73-L73)"
          ]
        },
        {
          "content": "```solidity\n148:     function configureDependencies() // <= FOUND\n149:         external\n150:         virtual\n151:         onlyKernel\n152:         returns (Keycode[] memory dependencies)\n153:     \n\n```\n",
          "loc": [
            "[148](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L148-L148)"
          ]
        },
        {
          "content": "```solidity\n94:     function requestPermissions() // <= FOUND\n95:         external\n96:         view\n97:         override\n98:         onlyKernel\n99:         returns (Permissions[] memory requests)\n100:     \n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L94-L94)"
          ]
        },
        {
          "content": "```solidity\n166:     function requestPermissions() // <= FOUND\n167:         external\n168:         view\n169:         virtual\n170:         onlyKernel\n171:         returns (Permissions[] memory requests)\n172:     \n\n```\n",
          "loc": [
            "[166](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L166-L166)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Functions within contracts are not ordered according to the solidity style guide",
      "description": "The following order should be used within contracts\n\nconstructor\n\nreceive function (if exists)\n\nfallback function (if exists)\n\nexternal\n\npublic\n\ninternal\n\nprivate\n\nRearrange the contract functions and contructors to fit this ordering",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard  // <= FOUND\n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use SafeCast to safely downcast variables",
      "description": "Downcasting int/uints in Solidity can be unsafe due to the potential for data loss and unintended behavior. When downcasting a larger integer type to a smaller one (e.g., uint256 to uint128), the value may exceed the range of the target type, leading to truncation and loss of significant digits. This data loss can result in unexpected state changes, incorrect calculations, or other contract vulnerabilities, ultimately compromising the contracts functionality and reliability. To prevent these risks, developers should carefully consider the range of values their variables may hold and ensure that proper checks are in place to prevent out-of-range values before performing downcasting. Also consider using OZ SafeCast functionality.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n149:     function hookOnTransaction(address hook) external view returns (bool) {\n150:         \n151:         return (uint8(1) & hookStatus[hook]) != 0; // <= FOUND\n152:     }\n\n```\n",
          "loc": [
            "[151](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L151-L151)"
          ]
        },
        {
          "content": "```solidity\n159:     function hookOnStart(address hook) external view returns (bool) {\n160:         \n161:         return uint8(2) & hookStatus[hook] != 0; // <= FOUND\n162:     }\n\n```\n",
          "loc": [
            "[161](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L161-L161)"
          ]
        },
        {
          "content": "```solidity\n169:     function hookOnStop(address hook) external view returns (bool) {\n170:         \n171:         return uint8(4) & hookStatus[hook] != 0; // <= FOUND\n172:     }\n\n```\n",
          "loc": [
            "[171](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L171-L171)"
          ]
        },
        {
          "content": "```solidity\n313:     function updateHookStatus(\n314:         address hook,\n315:         uint8 bitmap\n316:     ) external onlyByProxy permissioned {\n317:         \n318:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n319: \n320:         \n321:         if (bitmap > uint8(7)) // <= FOUND\n322:             revert Errors.StorageModule_InvalidHookStatusBitmap(bitmap);\n323: \n324:         \n325:         hookStatus[hook] = bitmap;\n326:     }\n\n```\n",
          "loc": [
            "[321](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L321-L321)"
          ]
        },
        {
          "content": "```solidity\n411:     function _convertToItems(\n412:         SpentItem[] memory offers,\n413:         ReceivedItem[] memory considerations,\n414:         OrderType orderType\n415:     ) internal pure returns (Item[] memory items) {\n416:         \n417:         items = new Item[](offers.length + considerations.length);\n418: \n419:         \n420:         if (orderType.isBaseOrder()) {\n421:             \n422:             _processBaseOrderOffer(items, offers, 0);\n423: \n424:             \n425:             _processBaseOrderConsideration(items, considerations, offers.length);\n426:         }\n427:         \n428:         else if (orderType.isPayOrder()) {\n429:             \n430:             _processPayOrderOffer(items, offers, 0);\n431: \n432:             \n433:             if (considerations.length > 0) {\n434:                 revert Errors.CreatePolicy_ConsiderationCountNonZero(\n435:                     considerations.length\n436:                 );\n437:             }\n438:         }\n439:         \n440:         else if (orderType.isPayeeOrder()) {\n441:             \n442:             if (offers.length > 0) {\n443:                 revert Errors.CreatePolicy_OfferCountNonZero(offers.length);\n444:             }\n445: \n446:             \n447:             _processPayeeOrderConsideration(considerations);\n448:         }\n449:         \n450:         else {\n451:             revert Errors.Shared_OrderTypeNotSupported(uint8(orderType)); // <= FOUND\n452:         }\n453:     }\n\n```\n",
          "loc": [
            "[451](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L451-L451)"
          ]
        },
        {
          "content": "```solidity\n84:     function getCreate2Address(\n85:         bytes32 salt,\n86:         bytes memory initCode\n87:     ) public view returns (address) {\n88:         \n89:         bytes32 addressHash = keccak256(\n90:             abi.encodePacked(create2_ff, address(this), salt, keccak256(initCode))\n91:         );\n92: \n93:         \n94:         return address(uint160(uint256(addressHash))); // <= FOUND\n95:     }\n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L94-L94)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Functions which set address state variables should have zero address checks",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n159:     function _settlePaymentProRata(\n160:         address token,\n161:         uint256 amount,\n162:         address lender,\n163:         address renter,\n164:         uint256 elapsedTime,\n165:         uint256 totalTime\n166:     ) internal {\n167:         \n168:         (uint256 renterAmount, uint256 lenderAmount) = _calculatePaymentProRata(\n169:             amount,\n170:             elapsedTime,\n171:             totalTime\n172:         );\n173: \n174:         \n175:         _safeTransfer(token, lender, lenderAmount);\n176: \n177:         \n178:         _safeTransfer(token, renter, renterAmount);\n179:     }\n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n190:     function _settlePaymentInFull(\n191:         address token,\n192:         uint256 amount,\n193:         SettleTo settleTo,\n194:         address lender,\n195:         address renter\n196:     ) internal {\n197:         \n198:         address settleToAddress = settleTo == SettleTo.LENDER ? lender : renter;\n199: \n200:         \n201:         _safeTransfer(token, settleToAddress, amount);\n202:     }\n\n```\n",
          "loc": [
            "[190](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L190-L190)"
          ]
        },
        {
          "content": "```solidity\n215:     function _settlePayment(\n216:         Item[] calldata items,\n217:         OrderType orderType,\n218:         address lender,\n219:         address renter,\n220:         uint256 start,\n221:         uint256 end\n222:     ) internal {\n223:         \n224:         uint256 elapsedTime = block.timestamp - start;\n225:         uint256 totalTime = end - start;\n226: \n227:         \n228:         bool isRentalOver = elapsedTime >= totalTime;\n229: \n230:         \n231:         for (uint256 i = 0; i < items.length; ++i) {\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n281:             }\n282:         }\n283:     }\n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L215-L215)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Interface imports should be declared first",
      "description": "Amend the ordering of imports to import interfaces first followed by other imports",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: \n3: pragma solidity ^0.8.20;\n4: \n5: import {SafeL2} from \"@safe-contracts/SafeL2.sol\"; // <= FOUND\n6: import {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\"; // <= FOUND\n7: import {TokenCallbackHandler} from \"@safe-contracts/handler/TokenCallbackHandler.sol\"; // <= FOUND\n8: \n9: import {ISafe} from \"@src/interfaces/ISafe.sol\"; // <= FOUND\n10: \n11: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\"; // <= FOUND\n12: import {toKeycode} from \"@src/libraries/KernelUtils.sol\"; // <= FOUND\n13: import {Errors} from \"@src/libraries/Errors.sol\"; // <= FOUND\n14: import {Events} from \"@src/libraries/Events.sol\"; // <= FOUND\n15: import {Storage} from \"@src/modules/Storage.sol\"; // <= FOUND\n16: import {Stop} from \"@src/policies/Stop.sol\"; // <= FOUND\n17: import {Guard} from \"@src/policies/Guard.sol\"; // <= FOUND\n18: \n23: contract Factory is Policy {\n24:     \n29:     Storage public STORE;\n30: \n32:     Stop public immutable stopPolicy;\n33:     Guard public immutable guardPolicy;\n34: \n36:     TokenCallbackHandler public immutable fallbackHandler;\n37:     SafeProxyFactory public immutable safeProxyFactory;\n38:     SafeL2 public immutable safeSingleton;\n39: \n50:     constructor(\n51:         Kernel kernel_,\n52:         Stop stopPolicy_,\n53:         Guard guardPolicy_,\n54:         TokenCallbackHandler fallbackHandler_,\n55:         SafeProxyFactory safeProxyFactory_,\n56:         SafeL2 safeSingleton_\n57:     ) Policy(kernel_) {\n58:         stopPolicy = stopPolicy_;\n59:         guardPolicy = guardPolicy_;\n60:         fallbackHandler = fallbackHandler_;\n61:         safeProxyFactory = safeProxyFactory_;\n62:         safeSingleton = safeSingleton_;\n63:     }\n64: \n74:     function configureDependencies()\n75:         external\n76:         override\n77:         onlyKernel\n78:         returns (Keycode[] memory dependencies)\n79:     {\n80:         dependencies = new Keycode[](1);\n81: \n82:         dependencies[0] = toKeycode(\"STORE\");\n83:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n84:     }\n85: \n95:     function requestPermissions()\n96:         external\n97:         view\n98:         override\n99:         onlyKernel\n100:         returns (Permissions[] memory requests)\n101:     {\n102:         requests = new Permissions[](1);\n103:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentalSafe.selector);\n104:     }\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L5-L17)"
          ]
        },
        {
          "content": "```solidity\n2: \n3: pragma solidity ^0.8.20;\n4: \n5: import {ZoneParameters} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\"; // <= FOUND\n6: import {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\"; // <= FOUND\n7: import {LibString} from \"@solady/utils/LibString.sol\"; // <= FOUND\n8: \n9: import {ISafe} from \"@src/interfaces/ISafe.sol\"; // <= FOUND\n10: import {IHook} from \"@src/interfaces/IHook.sol\"; // <= FOUND\n11: import {ZoneInterface} from \"@src/interfaces/IZone.sol\"; // <= FOUND\n12: \n13: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\"; // <= FOUND\n14: import {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\"; // <= FOUND\n15: import {RentalUtils} from \"@src/libraries/RentalUtils.sol\"; // <= FOUND\n16: import {Signer} from \"@src/packages/Signer.sol\"; // <= FOUND\n17: import {Zone} from \"@src/packages/Zone.sol\"; // <= FOUND\n18: import {Accumulator} from \"@src/packages/Accumulator.sol\"; // <= FOUND\n19: import {Storage} from \"@src/modules/Storage.sol\"; // <= FOUND\n20: import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\"; // <= FOUND\n21: import { // <= FOUND\n22:     RentalOrder,\n23:     RentPayload,\n24:     SeaportPayload,\n25:     Hook,\n26:     OrderFulfillment,\n27:     OrderMetadata,\n28:     OrderType,\n29:     Item,\n30:     ItemType,\n31:     SettleTo,\n32:     RentalId,\n33:     RentalAssetUpdate\n34: } from \"@src/libraries/RentalStructs.sol\";\n35: import {Errors} from \"@src/libraries/Errors.sol\"; // <= FOUND\n36: import {Events} from \"@src/libraries/Events.sol\"; // <= FOUND\n37: \n42: contract Create is Policy, Signer, Zone, Accumulator {\n43:     using RentalUtils for Item;\n44:     using RentalUtils for Item[];\n45:     using RentalUtils for SpentItem;\n46:     using RentalUtils for ReceivedItem;\n47:     using RentalUtils for OrderType;\n48: \n54:     Storage public STORE;\n55:     PaymentEscrow public ESCRW;\n56: \n62:     constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n63: \n73:     function configureDependencies()\n74:         external\n75:         override\n76:         onlyKernel\n77:         returns (Keycode[] memory dependencies)\n78:     {\n79:         dependencies = new Keycode[](2);\n80: \n81:         dependencies[0] = toKeycode(\"STORE\");\n82:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n83: \n84:         dependencies[1] = toKeycode(\"ESCRW\");\n85:         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n86:     }\n87: \n97:     function requestPermissions()\n98:         external\n99:         view\n100:         override\n101:         onlyKernel\n102:         returns (Permissions[] memory requests)\n103:     {\n104:         requests = new Permissions[](2);\n105:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentals.selector);\n106:         requests[1] = Permissions(toKeycode(\"ESCRW\"), ESCRW.increaseDeposit.selector);\n107:     }\n108: \n118:     function domainSeparator() external view returns (bytes32) {\n119:         return _DOMAIN_SEPARATOR;\n120:     }\n121: \n127:     function getRentalOrderHash(\n128:         RentalOrder memory order\n129:     ) external view returns (bytes32) {\n130:         return _deriveRentalOrderHash(order);\n131:     }\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L5-L36)"
          ]
        },
        {
          "content": "```solidity\n2: \n3: pragma solidity ^0.8.20;\n4: \n5: import {Enum} from \"@safe-contracts/common/Enum.sol\"; // <= FOUND\n6: import {LibString} from \"@solady/utils/LibString.sol\"; // <= FOUND\n7: \n8: import {ISafe} from \"@src/interfaces/ISafe.sol\"; // <= FOUND\n9: import {IHook} from \"@src/interfaces/IHook.sol\"; // <= FOUND\n10: \n11: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\"; // <= FOUND\n12: import {toKeycode} from \"@src/libraries/KernelUtils.sol\"; // <= FOUND\n13: import {RentalUtils} from \"@src/libraries/RentalUtils.sol\"; // <= FOUND\n14: import {Signer} from \"@src/packages/Signer.sol\"; // <= FOUND\n15: import {Reclaimer} from \"@src/packages/Reclaimer.sol\"; // <= FOUND\n16: import {Accumulator} from \"@src/packages/Accumulator.sol\"; // <= FOUND\n17: import {Storage} from \"@src/modules/Storage.sol\"; // <= FOUND\n18: import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\"; // <= FOUND\n19: import {Errors} from \"@src/libraries/Errors.sol\"; // <= FOUND\n20: import {Events} from \"@src/libraries/Events.sol\"; // <= FOUND\n21: import { // <= FOUND\n22:     Item,\n23:     RentalOrder,\n24:     Hook,\n25:     OrderType,\n26:     ItemType,\n27:     RentalId,\n28:     RentalAssetUpdate\n29: } from \"@src/libraries/RentalStructs.sol\";\n30: \n35: contract Stop is Policy, Signer, Reclaimer, Accumulator {\n36:     using RentalUtils for Item;\n37:     using RentalUtils for Item[];\n38:     using RentalUtils for OrderType;\n39: \n45:     Storage public STORE;\n46:     PaymentEscrow public ESCRW;\n47: \n53:     constructor(Kernel kernel_) Policy(kernel_) Signer() Reclaimer() {}\n54: \n64:     function configureDependencies()\n65:         external\n66:         override\n67:         onlyKernel\n68:         returns (Keycode[] memory dependencies)\n69:     {\n70:         dependencies = new Keycode[](2);\n71: \n72:         dependencies[0] = toKeycode(\"STORE\");\n73:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n74: \n75:         dependencies[1] = toKeycode(\"ESCRW\");\n76:         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n77:     }\n78: \n88:     function requestPermissions()\n89:         external\n90:         view\n91:         override\n92:         onlyKernel\n93:         returns (Permissions[] memory requests)\n94:     {\n95:         requests = new Permissions[](4);\n96:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);\n97:         requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);\n98:         requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);\n99:         requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);\n100:     }\n101: \n112:     function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal {\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L5-L21)"
          ]
        },
        {
          "content": "```solidity\n2: \n3: pragma solidity ^0.8.20;\n4: \n5: import {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\"; // <= FOUND\n6: import {Enum} from \"@safe-contracts/common/Enum.sol\"; // <= FOUND\n7: import {LibString} from \"@solady/utils/LibString.sol\"; // <= FOUND\n8: \n9: import {IHook} from \"@src/interfaces/IHook.sol\"; // <= FOUND\n10: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\"; // <= FOUND\n11: import {toKeycode} from \"@src/libraries/KernelUtils.sol\"; // <= FOUND\n12: import {Storage} from \"@src/modules/Storage.sol\"; // <= FOUND\n13: import { // <= FOUND\n14:     shared_set_approval_for_all_selector,\n15:     e721_approve_selector,\n16:     e721_safe_transfer_from_1_selector,\n17:     e721_safe_transfer_from_2_selector,\n18:     e721_transfer_from_selector,\n19:     e721_approve_token_id_offset,\n20:     e721_safe_transfer_from_1_token_id_offset,\n21:     e721_safe_transfer_from_2_token_id_offset,\n22:     e721_transfer_from_token_id_offset,\n23:     e1155_safe_transfer_from_selector,\n24:     e1155_safe_batch_transfer_from_selector,\n25:     e1155_safe_transfer_from_token_id_offset,\n26:     e1155_safe_batch_transfer_from_token_id_offset,\n27:     gnosis_safe_set_guard_selector,\n28:     gnosis_safe_enable_module_selector,\n29:     gnosis_safe_disable_module_selector,\n30:     gnosis_safe_enable_module_offset,\n31:     gnosis_safe_disable_module_offset\n32: } from \"@src/libraries/RentalConstants.sol\";\n33: import {Errors} from \"@src/libraries/Errors.sol\"; // <= FOUND\n34: \n40: contract Guard is Policy, BaseGuard {\n41:     \n46:     Storage public STORE;\n47: \n53:     constructor(Kernel kernel_) Policy(kernel_) {}\n54: \n64:     function configureDependencies()\n65:         external\n66:         override\n67:         onlyKernel\n68:         returns (Keycode[] memory dependencies)\n69:     {\n70:         dependencies = new Keycode[](1);\n71: \n72:         dependencies[0] = toKeycode(\"STORE\");\n73:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n74:     }\n75: \n85:     function requestPermissions()\n86:         external\n87:         view\n88:         override\n89:         onlyKernel\n90:         returns (Permissions[] memory requests)\n91:     {\n92:         requests = new Permissions[](2);\n93:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n94:         requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n95:     }\n96: \n109:     function _loadValueFromCalldata(\n110:         bytes memory data,\n111:         uint256 offset\n112:     ) private pure returns (bytes32 value) {\n113:         \n114:         assembly {\n115:             value := mload(add(data, offset))\n116:         }\n117:     }\n118: \n127:     function _revertSelectorOnActiveRental(\n128:         bytes4 selector,\n129:         address safe,\n130:         address token,\n131:         uint256 tokenId\n132:     ) private view {\n133:         \n134:         if (STORE.isRentedOut(safe, token, tokenId)) {\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L5-L33)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "A function which defines named returns in it's declaration doesn't need to use return ",
      "description": "Remove the return statement once ensuring it is safe to do so",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n96:     function VERSION() external pure override returns (uint8 major, uint8 minor) {\n97:         return (1, 0); // <= FOUND\n98:     }\n\n```\n",
          "loc": [
            "[97](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L97-L97)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use allowlist/denylist rather than whitelist/blacklist",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n55: \n62:     mapping(address delegate => bool isWhitelisted) public whitelistedDelegates; // <= FOUND\n\n```\n",
          "loc": [
            "[62](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L62-L62)"
          ]
        },
        {
          "content": "```solidity\n58: \n60:     mapping(address extension => bool isWhitelisted) public whitelistedExtensions; // <= FOUND\n\n```\n",
          "loc": [
            "[60](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L60-L60)"
          ]
        },
        {
          "content": "```solidity\n338:         whitelistedDelegates[delegate] = isEnabled; // <= FOUND\n\n```\n",
          "loc": [
            "[338](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L338-L338)"
          ]
        },
        {
          "content": "```solidity\n351:         whitelistedExtensions[extension] = isEnabled; // <= FOUND\n\n```\n",
          "loc": [
            "[351](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L351-L351)"
          ]
        },
        {
          "content": "```solidity\n145:         \n146:         if (!STORE.whitelistedExtensions(extension)) { // <= FOUND\n\n```\n",
          "loc": [
            "[146](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L146-L146)"
          ]
        },
        {
          "content": "```solidity\n324:         \n325:         \n326:         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) { // <= FOUND\n\n```\n",
          "loc": [
            "[326](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L326-L326)"
          ]
        },
        {
          "content": "```solidity\n334: \n341:     function toggleWhitelistDelegate( // <= FOUND\n342:         address delegate,\n343:         bool isEnabled\n344:     ) external onlyByProxy permissioned {\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L341-L341)"
          ]
        },
        {
          "content": "```solidity\n347: \n354:     function toggleWhitelistExtension( // <= FOUND\n355:         address extension,\n356:         bool isEnabled\n357:     ) external onlyByProxy permissioned {\n\n```\n",
          "loc": [
            "[354](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L354-L354)"
          ]
        },
        {
          "content": "```solidity\n72:         requests[0] = Permissions(\n73:             toKeycode(\"STORE\"),\n74:             STORE.toggleWhitelistExtension.selector // <= FOUND\n75:         );\n\n```\n",
          "loc": [
            "[74](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L74-L74)"
          ]
        },
        {
          "content": "```solidity\n76:         requests[1] = Permissions(\n77:             toKeycode(\"STORE\"),\n78:             STORE.toggleWhitelistDelegate.selector // <= FOUND\n79:         );\n\n```\n",
          "loc": [
            "[78](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L78-L78)"
          ]
        },
        {
          "content": "```solidity\n99: \n110:     function toggleWhitelistDelegate( // <= FOUND\n111:         address delegate,\n112:         bool isEnabled\n113:     ) external onlyRole(\"ADMIN_ADMIN\") {\n\n```\n",
          "loc": [
            "[110](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L110-L110)"
          ]
        },
        {
          "content": "```solidity\n103:         STORE.toggleWhitelistDelegate(delegate, isEnabled); // <= FOUND\n\n```\n",
          "loc": [
            "[103](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n113: \n121:     function toggleWhitelistExtension( // <= FOUND\n122:         address extension,\n123:         bool isEnabled\n124:     ) external onlyRole(\"ADMIN_ADMIN\") {\n\n```\n",
          "loc": [
            "[121](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L121-L121)"
          ]
        },
        {
          "content": "```solidity\n117:         STORE.toggleWhitelistExtension(extension, isEnabled); // <= FOUND\n\n```\n",
          "loc": [
            "[117](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n143: \n149:     function _revertNonWhitelistedExtension(address extension) private view { // <= FOUND\n\n```\n",
          "loc": [
            "[149](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L149-L149)"
          ]
        },
        {
          "content": "```solidity\n254: \n255:             \n256:             _revertNonWhitelistedExtension(extension); // <= FOUND\n\n```\n",
          "loc": [
            "[256](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L256-L256)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Multiple mappings can be replaced with a single struct mapping",
      "description": "Using a single struct mapping in place of multiple defined mappings in a Solidity contract can lead to improved code organization, better readability, and easier maintainability. By consolidating related data into a single struct, developers can create a more cohesive data structure that logically groups together relevant pieces of information, thus reducing redundancy and clutter. This approach simplifies the codebase, making it easier to understand, navigate, and modify. Additionally, it can result in more efficient gas usage when accessing or updating multiple related data points simultaneously. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n14: contract StorageBase {\n15:     \n20:     mapping(bytes32 orderHash => bool isActive) public orders; // <= FOUND\n21: \n26:     mapping(RentalId itemId => uint256 amount) public rentedAssets; // <= FOUND\n27: \n33:     mapping(address safe => uint256 nonce) public deployedSafes; // <= FOUND\n34: \n36:     uint256 public totalSafes;\n37: \n44:     mapping(address to => address hook) internal _contractToHook; // <= FOUND\n45: \n47:     mapping(address hook => uint8 enabled) public hookStatus; // <= FOUND\n48: \n55:     mapping(address delegate => bool isWhitelisted) public whitelistedDelegates; // <= FOUND\n56: \n58:     mapping(address extension => bool isWhitelisted) public whitelistedExtensions; // <= FOUND\n59: }\n\n```\n",
          "loc": [
            "[20](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L20-L58)"
          ]
        },
        {
          "content": "```solidity\n206: contract Kernel {\n207:     \n208:     address public executor;\n209:     address public admin;\n210: \n212:     Keycode[] public allKeycodes;\n213:     mapping(Keycode => Module) public getModuleForKeycode;  // <= FOUND\n214:     mapping(Module => Keycode) public getKeycodeForModule;  // <= FOUND\n215: \n217:     mapping(Keycode => Policy[]) public moduleDependents; // <= FOUND\n218:     mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex; // <= FOUND\n219: \n221:     mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) // <= FOUND\n222:         public modulePermissions; \n223: \n225:     Policy[] public activePolicies;\n226:     mapping(Policy => uint256) public getPolicyIndex; // <= FOUND\n227: \n229:     mapping(address => mapping(Role => bool)) public hasRole; // <= FOUND\n230:     mapping(Role => bool) public isRole; // <= FOUND\n231: \n362: }\n\n```\n",
          "loc": [
            "[213](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L213-L230)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Constants should be on the left side of the ",
      "description": "Putting constants on the left side of a comparison operator like `==` or `<` is a best practice known as \"Yoda conditions\", which can help prevent accidental assignment instead of comparison. In some programming languages, if a variable is mistakenly put on the left with a single `=` instead of `==`, it assigns the constant's value to the variable without any compiler error. However, doing this with the constant on the left would generate an error, as constants cannot be assigned values. Although Solidity's static typing system prevents accidental assignments within conditionals, adopting this practice enhances code readability and consistency, especially when developers are working across multiple languages that support this convention.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n115:         if (!success || (data.length != 0 && !abi.decode(data, (bool))))  // <= FOUND\n\n```\n",
          "loc": [
            "[115](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L115-L115)"
          ]
        },
        {
          "content": "```solidity\n366:         if (amount == 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[366](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L366-L366)"
          ]
        },
        {
          "content": "```solidity\n201:         if (offers.length == 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[201](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L201-L201)"
          ]
        },
        {
          "content": "```solidity\n311:         if (totalRentals == 0 || totalPayments == 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[311](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L311-L311)"
          ]
        },
        {
          "content": "```solidity\n332:         if (considerations.length == 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[332](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L332-L332)"
          ]
        },
        {
          "content": "```solidity\n631:         if (metadata.rentDuration == 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[631](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L631-L631)"
          ]
        },
        {
          "content": "```solidity\n649:         if (STORE.deployedSafes(safe) == 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[649](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L649-L649)"
          ]
        },
        {
          "content": "```solidity\n143:         if (threshold == 0 || threshold > owners.length)  // <= FOUND\n\n```\n",
          "loc": [
            "[143](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L143-L143)"
          ]
        },
        {
          "content": "```solidity\n242:                 if (fee != 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[242](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L242-L242)"
          ]
        },
        {
          "content": "```solidity\n433:             if (considerations.length > 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[433](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L433-L433)"
          ]
        },
        {
          "content": "```solidity\n442:             if (offers.length > 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[442](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L442-L442)"
          ]
        },
        {
          "content": "```solidity\n288:         if (order.hooks.length > 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[288](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L288-L288)"
          ]
        },
        {
          "content": "```solidity\n606:             if (payload.metadata.hooks.length > 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[606](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L606-L606)"
          ]
        },
        {
          "content": "```solidity\n348:             if (orders[i].hooks.length > 0)  // <= FOUND\n\n```\n",
          "loc": [
            "[348](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L348-L348)"
          ]
        },
        {
          "content": "```solidity\n382:         if (feeNumerator > 10000)  // <= FOUND\n\n```\n",
          "loc": [
            "[382](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L382-L382)"
          ]
        },
        {
          "content": "```solidity\n329:         if (data.length < 4)  // <= FOUND\n\n```\n",
          "loc": [
            "[329](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L329-L329)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Defined named returns not used within function ",
      "description": "Such instances can be replaced with unnamed returns",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n96:     function VERSION() external pure override returns (uint8 major, uint8 minor) { // <= FOUND\n97:         return (1, 0);\n98:     }\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n100:     function VERSION() external pure virtual returns (uint8 major, uint8 minor) {} // <= FOUND\n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L100-L100)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Both immutable and constant state variables should be CONSTANT_CASE",
      "description": "Make found instants CAPITAL_CASE",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n19: bytes1 constant create2_ff = 0xff; // <= FOUND\n\n```\n",
          "loc": [
            "[19](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L19-L19)"
          ]
        },
        {
          "content": "```solidity\n32: Guard public immutable guardPolicy; // <= FOUND\n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L32-L32)"
          ]
        },
        {
          "content": "```solidity\n35: TokenCallbackHandler public immutable fallbackHandler; // <= FOUND\n\n```\n",
          "loc": [
            "[35](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L35-L35)"
          ]
        },
        {
          "content": "```solidity\n36: SafeProxyFactory public immutable safeProxyFactory; // <= FOUND\n\n```\n",
          "loc": [
            "[36](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L36-L36)"
          ]
        },
        {
          "content": "```solidity\n37: SafeL2 public immutable safeSingleton; // <= FOUND\n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n17: address private immutable original; // <= FOUND\n\n```\n",
          "loc": [
            "[17](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L17-L17)"
          ]
        },
        {
          "content": "```solidity\n31: Stop public immutable stopPolicy; // <= FOUND\n\n```\n",
          "loc": [
            "[31](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L31-L31)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using named mappings",
      "description": "In Solidity version 0.8.18 and beyond mapping parameters can be named. This makes the purpose and function of a given mapping far clearer which in turn improves readability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n16:     mapping(address => bool) public deployed; // <= FOUND\n\n```\n",
          "loc": [
            "[16](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L16-L16)"
          ]
        },
        {
          "content": "```solidity\n221:     mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) // <= FOUND\n\n```\n",
          "loc": [
            "[221](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L221-L221)"
          ]
        },
        {
          "content": "```solidity\n229:     mapping(address => mapping(Role => bool)) public hasRole; // <= FOUND\n\n```\n",
          "loc": [
            "[229](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L229-L229)"
          ]
        },
        {
          "content": "```solidity\n230:     mapping(Role => bool) public isRole; // <= FOUND\n\n```\n",
          "loc": [
            "[230](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L230-L230)"
          ]
        },
        {
          "content": "```solidity\n218:     mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex; // <= FOUND\n\n```\n",
          "loc": [
            "[218](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L218-L218)"
          ]
        },
        {
          "content": "```solidity\n226:     mapping(Policy => uint256) public getPolicyIndex; // <= FOUND\n\n```\n",
          "loc": [
            "[226](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L226-L226)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Uses of EIP712 does not include a salt",
      "description": "It is standard for uses of EIP712 to include a salt, not doing so can cause future incompatibilities and in this instance cause hash collisions do to no salting",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n315: \n316:         \n317:         eip712DomainTypehash = keccak256(\n318:             abi.encodePacked(\n319:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\" // <= FOUND\n320:             )\n321:         );\n\n```\n",
          "loc": [
            "[315](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L315-L319)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Loss of precision",
      "description": "Dividing by large numbers in Solidity can cause a loss of precision due to the language's inherent integer division behavior. Solidity does not support floating-point arithmetic, and as a result, division between integers yields an integer result, truncating any fractional part. When dividing by a large number, the resulting value may become significantly smaller, leading to a loss of precision, as the fractional part is discarded.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n132:     function _calculatePaymentProRata(\n133:         uint256 amount,\n134:         uint256 elapsedTime,\n135:         uint256 totalTime\n136:     ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n137:         \n138:         uint256 numerator = (amount * elapsedTime) * 1000;\n139: \n140:         \n141:         \n142:         renterAmount = ((numerator / totalTime) + 500) / 1000;\n143: \n144:         \n145:         lenderAmount = amount - renterAmount;\n146:     }\n\n```\n",
          "loc": [
            "[132](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L132-L132)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use a single contract or library for system wide constants",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n14: contract Create2Deployer {\n15:     \n16:     mapping(address => bool) public deployed;\n17: \n19:     bytes1 constant create2_ff = 0xff; // <= FOUND\n20: \n56: }\n\n```\n",
          "loc": [
            "[19](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L19-L19)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using modifiers for address control",
      "description": "Modifiers in Solidity can improve code readability and modularity by encapsulating repetitive checks, such as address validity checks, into a reusable construct. For example, an `onlyOwner` modifier can be used to replace repetitive `require(msg.sender == owner)` checks across several functions, reducing code redundancy and enhancing maintainability. To implement, define a modifier with the check, then apply the modifier to relevant functions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n135: \n136:         \n137:         bool isLender = expectedLender == msg.sender; // <= FOUND\n\n```\n",
          "loc": [
            "[135](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L135-L137)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Default address(0) can be returned",
      "description": "Allowing a function in Solidity to return the default address (address(0)) can be problematic as it can represent uninitialized or invalid addresses. If such an address is utilized in transfer operations or other sensitive actions, it could lead to loss of funds or unpredicted behavior. It's prudent to include checks in your functions to prevent the return of the zero address, enhancing contract security.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n135:     function contractToHook(address to) external view returns (address) {\n136:         \n137:         address hook = _contractToHook[to];\n138: \n139:         \n140:         \n141:         return hookStatus[hook] != 0 ? hook : address(0);\n142:     }\n\n```\n",
          "loc": [
            "[135](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L135-L135)"
          ]
        },
        {
          "content": "```solidity\n107:     function _recoverSignerFromPayload(\n108:         bytes32 payloadHash,\n109:         bytes memory signature\n110:     ) internal view returns (address) {\n111:         \n112:         bytes32 digest = _DOMAIN_SEPARATOR.toTypedDataHash(payloadHash);\n113: \n114:         \n115:         return digest.recover(signature);\n116:     }\n\n```\n",
          "loc": [
            "[107](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L107-L107)"
          ]
        },
        {
          "content": "```solidity\n84:     function getCreate2Address(\n85:         bytes32 salt,\n86:         bytes memory initCode\n87:     ) public view returns (address) {\n88:         \n89:         bytes32 addressHash = keccak256(\n90:             abi.encodePacked(create2_ff, address(this), salt, keccak256(initCode))\n91:         );\n92: \n93:         \n94:         return address(uint160(uint256(addressHash)));\n95:     }\n\n```\n",
          "loc": [
            "[84](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L84-L84)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Variables should be used in place of magic numbers to improve readability",
      "description": "Magic numbers should be avoided in Solidity code to enhance readability, maintainability, and reduce the likelihood of errors. Magic numbers are hard-coded values with no clear meaning or context, which can create confusion and make the code harder to understand for developers. Using well-defined constants or variables with descriptive names instead of magic numbers not only clarifies the purpose and significance of the value but also simplifies code updates and modifications.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n90:         \n91:         return (amount * fee) / 10000; // <= FOUND\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L90-L91)"
          ]
        },
        {
          "content": "```solidity\n138:         \n139:         uint256 numerator = (amount * elapsedTime) * 1000; // <= FOUND\n\n```\n",
          "loc": [
            "[138](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L138-L139)"
          ]
        },
        {
          "content": "```solidity\n142: \n143:         \n144:         \n145:         renterAmount = ((numerator / totalTime) + 500) / 1000; // <= FOUND\n\n```\n",
          "loc": [
            "[142](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L142-L145)"
          ]
        },
        {
          "content": "```solidity\n382:         \n383:         if (feeNumerator > 10000) { // <= FOUND\n\n```\n",
          "loc": [
            "[382](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L382-L383)"
          ]
        },
        {
          "content": "```solidity\n329: \n330:         \n331:         if (data.length < 4) { // <= FOUND\n\n```\n",
          "loc": [
            "[329](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L329-L331)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Long powers of ten should use scientific notation 1eX",
      "description": "A large number such as 1000000 is far more readable as 1e6, this will help prevent unintended bugs in the code",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n90:         \n91:         return (amount * fee) / 10000; // <= FOUND\n\n```\n",
          "loc": [
            "[91](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L91-L91)"
          ]
        },
        {
          "content": "```solidity\n138:         \n139:         uint256 numerator = (amount * elapsedTime) * 1000; // <= FOUND\n\n```\n",
          "loc": [
            "[139](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L139-L139)"
          ]
        },
        {
          "content": "```solidity\n142: \n143:         \n144:         \n145:         renterAmount = ((numerator / totalTime) + 500) / 1000; // <= FOUND\n\n```\n",
          "loc": [
            "[145](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L145-L145)"
          ]
        },
        {
          "content": "```solidity\n382:         \n383:         if (feeNumerator > 10000) { // <= FOUND\n\n```\n",
          "loc": [
            "[383](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L383-L383)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use EIP-5767 to manage EIP712 domains",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n315: \n316:         \n317:         eip712DomainTypehash = keccak256(\n318:             abi.encodePacked(\n319:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\" // <= FOUND\n320:             )\n321:         );\n\n```\n",
          "loc": [
            "[319](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L319-L319)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Overridden function has no body",
      "description": "In Ethereum Solidity, functions can be overridden, meaning a contract can change the behavior of a function inherited from a base contract. Sometimes, the overriding function might not have a body. This could be due to a variety of reasons. For instance, the overriding function could be setting up a default behavior (like failing with an error) that can be further overridden in derived contracts, or it could be providing an optional hook that's left empty unless certain specific conditions are met.\n\nIn such cases, it can be extremely helpful to future developers, auditors, and users of the contract if a NatSpec comment is added to describe the function's purpose and the reason why it does not have a body. NatSpec, short for Natural Specification, is a form of documentation standard in Ethereum used for expressing what a function does in a human-readable format.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n353:     function checkAfterExecution(bytes32 txHash, bool success) external override {}\n\n```\n",
          "loc": [
            "[353](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L353-L353)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Empty bytes check is missing",
      "description": "When developing smart contracts in Solidity, it's crucial to validate the inputs of your functions. This includes ensuring that the bytes parameters are not empty, especially when they represent crucial data such as addresses, identifiers, or raw data that the contract needs to process.\n\nMissing empty bytes checks can lead to unexpected behaviour in your contract. For instance, certain operations might fail, produce incorrect results, or consume unnecessary gas when performed with empty bytes. Moreover, missing input validation can potentially expose your contract to malicious activity, including exploitation of unhandled edge cases.\n\nTo mitigate these issues, always validate that bytes parameters are not empty when the logic of your contract requires it.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n32:     function _insert(\n33:         bytes memory rentalAssets,\n34:         RentalId rentalId,\n35:         uint256 rentalAssetAmount\n36:     ) internal pure {\n37:         \n38:         bytes32 _rentalId = RentalId.unwrap(rentalId);\n39: \n40:         assembly {\n41:             \n42:             if eq(mload(rentalAssets), 0) {\n43:                 \n44:                 mstore(rentalAssets, 0x20)\n45: \n46:                 \n47:                 mstore(add(0x20, rentalAssets), 0x00)\n48:             }\n49: \n50:             \n51:             \n52:             let newByteDataSize := add(mload(rentalAssets), 0x40)\n53: \n54:             \n55:             let rentalAssetElementPtr := add(rentalAssets, 0x20)\n56: \n57:             \n58:             let elements := add(mload(rentalAssetElementPtr), 1)\n59: \n60:             \n61:             \n62:             \n63:             \n64:             let newItemPosition := add(\n65:                 rentalAssetElementPtr,\n66:                 sub(mul(elements, 0x40), 0x20)\n67:             )\n68: \n69:             \n70:             mstore(rentalAssets, newByteDataSize)\n71: \n72:             \n73:             mstore(rentalAssetElementPtr, elements)\n74: \n75:             \n76:             mstore(newItemPosition, _rentalId)\n77: \n78:             \n79:             mstore(add(newItemPosition, 0x20), rentalAssetAmount)\n80: \n81:             \n82:             \n83:             mstore(0x40, add(newItemPosition, 0x40))\n84:         }\n85:     }\n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L32-L32)"
          ]
        },
        {
          "content": "```solidity\n96:     function _convertToStatic(\n97:         bytes memory rentalAssetUpdates\n98:     ) internal pure returns (RentalAssetUpdate[] memory updates) {\n99:         \n100:         bytes32 rentalAssetUpdatePointer;\n101: \n102:         \n103:         uint256 rentalAssetUpdateLength;\n104:         assembly {\n105:             \n106:             \n107:             \n108:             \n109:             rentalAssetUpdatePointer := add(0x20, rentalAssetUpdates)\n110: \n111:             \n112:             rentalAssetUpdateLength := mload(rentalAssetUpdatePointer)\n113:         }\n114: \n115:         \n116:         updates = new RentalAssetUpdate[](rentalAssetUpdateLength);\n117: \n118:         \n119:         \n120:         for (uint256 i = 0; i < rentalAssetUpdateLength; ++i) {\n121:             \n122:             RentalId rentalId;\n123:             uint256 amount;\n124: \n125:             \n126:             assembly {\n127:                 \n128:                 \n129:                 \n130:                 \n131:                 let currentElementOffset := add(0x20, mul(i, 0x40))\n132: \n133:                 \n134:                 rentalId := mload(add(rentalAssetUpdatePointer, currentElementOffset))\n135: \n136:                 \n137:                 amount := mload(\n138:                     add(0x20, add(rentalAssetUpdatePointer, currentElementOffset))\n139:                 )\n140:             }\n141: \n142:             \n143:             updates[i] = RentalAssetUpdate(rentalId, amount);\n144:         }\n145:     }\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n107:     function _recoverSignerFromPayload(\n108:         bytes32 payloadHash,\n109:         bytes memory signature\n110:     ) internal view returns (address) {\n111:         \n112:         bytes32 digest = _DOMAIN_SEPARATOR.toTypedDataHash(payloadHash);\n113: \n114:         \n115:         return digest.recover(signature);\n116:     }\n\n```\n",
          "loc": [
            "[107](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L107-L107)"
          ]
        },
        {
          "content": "```solidity\n273:     function _deriveDomainSeparator(\n274:         bytes32 _eip712DomainTypeHash,\n275:         bytes32 _nameHash,\n276:         bytes32 _versionHash\n277:     ) internal view virtual returns (bytes32) {\n278:         return\n279:             keccak256(\n280:                 abi.encode(\n281:                     _eip712DomainTypeHash,\n282:                     _nameHash,\n283:                     _versionHash,\n284:                     block.chainid,\n285:                     address(this)\n286:                 )\n287:             );\n288:     }\n\n```\n",
          "loc": [
            "[273](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L273-L273)"
          ]
        },
        {
          "content": "```solidity\n165:     function _emitRentalOrderStarted(\n166:         RentalOrder memory order,\n167:         bytes32 orderHash,\n168:         bytes memory extraData\n169:     ) internal {\n170:         \n171:         emit Events.RentalOrderStarted(\n172:             orderHash,\n173:             extraData,\n174:             order.seaportOrderHash,\n175:             order.items,\n176:             order.hooks,\n177:             order.orderType,\n178:             order.lender,\n179:             order.renter,\n180:             order.rentalWallet,\n181:             order.startTimestamp,\n182:             order.endTimestamp\n183:         );\n184:     }\n\n```\n",
          "loc": [
            "[165](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L165-L165)"
          ]
        },
        {
          "content": "```solidity\n626:     function _isValidOrderMetadata(\n627:         OrderMetadata memory metadata,\n628:         bytes32 zoneHash\n629:     ) internal view {\n630:         \n631:         if (metadata.rentDuration == 0) {\n632:             revert Errors.CreatePolicy_RentDurationZero();\n633:         }\n634: \n635:         \n636:         if (_deriveOrderMetadataHash(metadata) != zoneHash) {\n637:             revert Errors.CreatePolicy_InvalidOrderMetadataHash();\n638:         }\n639:     }\n\n```\n",
          "loc": [
            "[626](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L626-L626)"
          ]
        },
        {
          "content": "```solidity\n126:     function _revertSelectorOnActiveRental(\n127:         bytes4 selector,\n128:         address safe,\n129:         address token,\n130:         uint256 tokenId\n131:     ) private view {\n132:         \n133:         if (STORE.isRentedOut(safe, token, tokenId)) {\n134:             revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n135:         }\n136:     }\n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n159:     function _forwardToHook(\n160:         address hook,\n161:         address safe,\n162:         address to,\n163:         uint256 value,\n164:         bytes memory data\n165:     ) private {\n166:         \n167:         try IHook(hook).onTransaction(safe, to, value, data) {} catch Error(\n168:             string memory revertReason\n169:         ) {\n170:             \n171:             revert Errors.Shared_HookFailString(revertReason);\n172:         } catch Panic(uint256 errorCode) {\n173:             \n174:             string memory stringErrorCode = LibString.toString(errorCode);\n175: \n176:             \n177:             revert Errors.Shared_HookFailString(\n178:                 string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n179:             );\n180:         } catch (bytes memory revertData) {\n181:             \n182:             revert Errors.Shared_HookFailBytes(revertData);\n183:         }\n184:     }\n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n195:     function _checkTransaction(address from, address to, bytes memory data) private view {\n196:         bytes4 selector;\n197: \n198:         \n199:         assembly {\n200:             selector := mload(add(data, 0x20))\n201:         }\n202: \n203:         if (selector == e721_safe_transfer_from_1_selector) {\n204:             \n205:             uint256 tokenId = uint256(\n206:                 _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset)\n207:             );\n208: \n209:             \n210:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n211:         } else if (selector == e721_safe_transfer_from_2_selector) {\n212:             \n213:             uint256 tokenId = uint256(\n214:                 _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset)\n215:             );\n216: \n217:             \n218:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n219:         } else if (selector == e721_transfer_from_selector) {\n220:             \n221:             uint256 tokenId = uint256(\n222:                 _loadValueFromCalldata(data, e721_transfer_from_token_id_offset)\n223:             );\n224: \n225:             \n226:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n227:         } else if (selector == e721_approve_selector) {\n228:             \n229:             uint256 tokenId = uint256(\n230:                 _loadValueFromCalldata(data, e721_approve_token_id_offset)\n231:             );\n232: \n233:             \n234:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n235:         } else if (selector == e1155_safe_transfer_from_selector) {\n236:             \n237:             uint256 tokenId = uint256(\n238:                 _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n239:             );\n240: \n241:             \n242:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n243:         } else if (selector == gnosis_safe_enable_module_selector) {\n244:             \n245:             address extension = address(\n246:                 uint160(\n247:                     uint256(\n248:                         _loadValueFromCalldata(data, gnosis_safe_enable_module_offset)\n249:                     )\n250:                 )\n251:             );\n252: \n253:             \n254:             _revertNonWhitelistedExtension(extension);\n255:         } else if (selector == gnosis_safe_disable_module_selector) {\n256:             \n257:             address extension = address(\n258:                 uint160(\n259:                     uint256(\n260:                         _loadValueFromCalldata(data, gnosis_safe_disable_module_offset)\n261:                     )\n262:                 )\n263:             );\n264: \n265:             \n266:             _revertNonWhitelistedExtension(extension);\n267:         } else {\n268:             \n269:             \n270:             if (selector == shared_set_approval_for_all_selector) {\n271:                 revert Errors.GuardPolicy_UnauthorizedSelector(\n272:                     shared_set_approval_for_all_selector\n273:                 );\n274:             }\n275: \n276:             \n277:             \n278:             \n279:             \n280:             if (selector == e1155_safe_batch_transfer_from_selector) {\n281:                 revert Errors.GuardPolicy_UnauthorizedSelector(\n282:                     e1155_safe_batch_transfer_from_selector\n283:                 );\n284:             }\n285: \n286:             \n287:             if (selector == gnosis_safe_set_guard_selector) {\n288:                 revert Errors.GuardPolicy_UnauthorizedSelector(\n289:                     gnosis_safe_set_guard_selector\n290:                 );\n291:             }\n292:         }\n293:     }\n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L195)"
          ]
        },
        {
          "content": "```solidity\n111:     function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal {\n112:         \n113:         emit Events.RentalOrderStopped(seaportOrderHash, stopper);\n114:     }\n\n```\n",
          "loc": [
            "[111](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L111-L111)"
          ]
        },
        {
          "content": "```solidity\n32:     function deploy(\n33:         bytes32 salt,\n34:         bytes memory initCode\n35:     ) external payable returns (address deploymentAddress) {\n36:         \n37:         if (address(bytes20(salt)) != msg.sender) {\n38:             revert Errors.Create2Deployer_UnauthorizedSender(msg.sender, salt);\n39:         }\n40: \n41:         \n42:         address targetDeploymentAddress = getCreate2Address(salt, initCode);\n43: \n44:         \n45:         if (deployed[targetDeploymentAddress]) {\n46:             revert Errors.Create2Deployer_AlreadyDeployed(targetDeploymentAddress, salt);\n47:         }\n48: \n49:         \n50:         deployed[targetDeploymentAddress] = true;\n51: \n52:         \n53:         assembly {\n54:             deploymentAddress := create2(\n55:                 \n56:                 callvalue(),\n57:                 \n58:                 add(initCode, 0x20),\n59:                 \n60:                 mload(initCode),\n61:                 \n62:                 salt\n63:             )\n64:         }\n65: \n66:         \n67:         if (deploymentAddress != targetDeploymentAddress) {\n68:             revert Errors.Create2Deployer_MismatchedDeploymentAddress(\n69:                 targetDeploymentAddress,\n70:                 deploymentAddress\n71:             );\n72:         }\n73:     }\n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L32-L32)"
          ]
        },
        {
          "content": "```solidity\n84:     function getCreate2Address(\n85:         bytes32 salt,\n86:         bytes memory initCode\n87:     ) public view returns (address) {\n88:         \n89:         bytes32 addressHash = keccak256(\n90:             abi.encodePacked(create2_ff, address(this), salt, keccak256(initCode))\n91:         );\n92: \n93:         \n94:         return address(uint160(uint256(addressHash)));\n95:     }\n\n```\n",
          "loc": [
            "[84](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L84-L84)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider adding a time delay to upgrade implementation functions",
      "description": "It's often considered a good practice to use a timelock on sensitive functions such as upgrading a contract, especially when these contracts handle user funds or critical system states.\n\nA timelock is a delay period that must pass between when an action (like an upgrade) is scheduled and when it can be executed. This provides a window of time for users or governance participants to observe the proposed change and potentially respond if they disagree with the action.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n360:     function upgrade(address newImplementation) external onlyByProxy permissioned { // <= FOUND\n361:         \n362:         _upgrade(newImplementation);\n363:     }\n\n```\n",
          "loc": [
            "[360](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L360-L360)"
          ]
        },
        {
          "content": "```solidity\n126:     function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") { // <= FOUND\n127:         STORE.upgrade(newImplementation);\n128:     }\n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n144:     function upgradePaymentEscrow( // <= FOUND\n145:         address newImplementation\n146:     ) external onlyRole(\"ADMIN_ADMIN\") {\n147:         ESCRW.upgrade(newImplementation);\n148:     }\n\n```\n",
          "loc": [
            "[144](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L144-L144)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use scopes sparingly",
      "description": "In Solidity programming, the use of scoped blocks, denoted by `{}` without a preceding control structure like `if`, `for`, etc., allows for the creation of isolated scopes within a function. While this can be useful for managing memory and preventing naming conflicts, it should be used sparingly. Excessive use of these scope blocks can obscure the code's logic flow and make it more difficult to understand, impeding code maintainability. As a best practice, only employ scoped blocks when necessary for memory management or to avoid clear naming conflicts. Otherwise, aim for clarity and simplicity in your code structure for optimal readability and maintainability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n377:         { // <= FOUND\n378:             \n379:             bytes memory orderFulfillmentTypeString = abi.encodePacked(\n380:                 \"OrderFulfillment(address recipient)\"\n381:             );\n382: \n383:             \n384:             bytes memory orderMetadataTypeString = abi.encodePacked(\n385:                 \"OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\"\n386:             );\n387: \n388:             \n389:             bytes memory rentPayloadTypeString = abi.encodePacked(\n390:                 \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\"\n391:             );\n392: \n393:             \n394:             rentPayloadTypeHash = keccak256(\n395:                 abi.encodePacked(\n396:                     rentPayloadTypeString,\n397:                     orderMetadataTypeString,\n398:                     orderFulfillmentTypeString\n399:                 )\n400:             );\n401: \n402:             \n403:             orderFulfillmentTypeHash = keccak256(orderFulfillmentTypeString);\n404: \n405:             \n406:             orderMetadataTypeHash = keccak256(orderMetadataTypeString);\n407:         }\n\n```\n",
          "loc": [
            "[377](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L377-L377)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "No equate comparison checks between to and from address parameters",
      "description": "The function lacks a standard check: it does not validate if the 'to' and 'from' addresses are identical. This omission can lead to unintended outcomes if the same address is used in both parameters. To rectify this, we recommend implementing a comparison check at the beginning of the function. In the context of Solidity, the command `require(to != from, \"To and From addresses can't be the same\");` could be utilized. This addition will generate an error if the 'to' and 'from' addresses are the same, thereby fortifying the function's robustness and security.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n195:     function _checkTransaction(address from, address to, bytes memory data) private view { // <= FOUND\n196:         bytes4 selector;\n197: \n198:         \n199:         assembly {\n200:             selector := mload(add(data, 0x20))\n201:         }\n202: \n203:         if (selector == e721_safe_transfer_from_1_selector) {\n204:             \n205:             uint256 tokenId = uint256(\n206:                 _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset)\n207:             );\n208: \n209:             \n210:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n211:         } else if (selector == e721_safe_transfer_from_2_selector) {\n212:             \n213:             uint256 tokenId = uint256(\n214:                 _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset)\n215:             );\n216: \n217:             \n218:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n219:         } else if (selector == e721_transfer_from_selector) {\n220:             \n221:             uint256 tokenId = uint256(\n222:                 _loadValueFromCalldata(data, e721_transfer_from_token_id_offset)\n223:             );\n224: \n225:             \n226:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n227:         } else if (selector == e721_approve_selector) {\n228:             \n229:             uint256 tokenId = uint256(\n230:                 _loadValueFromCalldata(data, e721_approve_token_id_offset)\n231:             );\n232: \n233:             \n234:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n235:         } else if (selector == e1155_safe_transfer_from_selector) {\n236:             \n237:             uint256 tokenId = uint256(\n238:                 _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n239:             );\n240: \n241:             \n242:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n243:         } else if (selector == gnosis_safe_enable_module_selector) {\n244:             \n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L195)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Do not use underscore at the end of variable name",
      "description": "Adopting a consistent and clear naming convention enhances code readability and maintainability. In Solidity, appending an underscore at the end of a variable name is unconventional and can lead to confusion. It is generally advisable to stick to accepted naming practices to promote ease of understanding and use.\n",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n278:         if (action_ == Actions.InstallModule) { // <= FOUND\n\n```\n",
          "loc": [
            "[278](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L278-L278)"
          ]
        },
        {
          "content": "```solidity\n282:         } else if (action_ == Actions.UpgradeModule) { // <= FOUND\n\n```\n",
          "loc": [
            "[282](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L282-L282)"
          ]
        },
        {
          "content": "```solidity\n286:         } else if (action_ == Actions.ActivatePolicy) { // <= FOUND\n\n```\n",
          "loc": [
            "[286](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L286-L286)"
          ]
        },
        {
          "content": "```solidity\n289:         } else if (action_ == Actions.DeactivatePolicy) { // <= FOUND\n\n```\n",
          "loc": [
            "[289](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L289-L289)"
          ]
        },
        {
          "content": "```solidity\n292:         } else if (action_ == Actions.MigrateKernel) { // <= FOUND\n\n```\n",
          "loc": [
            "[292](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L292-L292)"
          ]
        },
        {
          "content": "```solidity\n295:         } else if (action_ == Actions.ChangeExecutor) { // <= FOUND\n\n```\n",
          "loc": [
            "[295](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L295-L295)"
          ]
        },
        {
          "content": "```solidity\n297:         } else if (action_ == Actions.ChangeAdmin) { // <= FOUND\n\n```\n",
          "loc": [
            "[297](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L297-L297)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using SMTChecker",
      "description": "The SMTChecker is a valuable tool for Solidity developers as it helps detect potential vulnerabilities and logical errors in the contract's code. By utilizing Satisfiability Modulo Theories (SMT) solvers, it can reason about the potential states a contract can be in, and therefore, identify conditions that could lead to undesirable behavior. This automatic formal verification can catch issues that might otherwise be missed in manual code reviews or standard testing, enhancing the overall contract's security and reliability.",
      "gasSavings": 3000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {Errors} from \"@src/libraries/Errors.sol\";\n5: \n6: /**\n7:  * @title Create2Deployer\n8:  * @notice Deployment contract that uses the init code and a salt to perform a deployment.\n9:  *         There is added cross-chain safety as well because a particular salt can only be\n10:  *         used if the sender's address is contained within that salt. This prevents a\n11:  *         contract on one chain from being deployed by a non-admin account on\n12:  *         another chain.\n13:  */\n14: contract Create2Deployer {\n15:     // Determine if an address has already been deployed.\n16:     mapping(address => bool) public deployed;\n17: \n18:     // Byte used to prevent collision with CREATE.\n19:     bytes1 constant create2_ff = 0xff;\n20: \n21:     /**\n22:      * @notice Deploys a contract using the given salt and init code. Prevents\n23:      *         frontrunning of claiming a specific address by asserting that the first\n24:      *         20 bytes of the salt matches the sender. This check is especially useful\n25:      *         if trying to keep the same deployment addresses across chains.\n26:      *\n27:      * @param salt     A unique value which must contain the address of the sender.\n28:      * @param initCode The init code of the contract to deploy.\n29:      *\n30:      * @return deploymentAddress The addres of the deployed contract.\n31:      */\n32:     function deploy(\n33:         bytes32 salt,\n34:         bytes memory initCode\n35:     ) external payable returns (address deploymentAddress) {\n36:         // Ensure the salt is valid for the sender.\n37:         if (address(bytes20(salt)) != msg.sender) {\n38:             revert Errors.Create2Deployer_UnauthorizedSender(msg.sender, salt);\n39:         }\n40: \n41:         // Determine the target address for contract deployment.\n42:         address targetDeploymentAddress = getCreate2Address(salt, initCode);\n43: \n44:         // Ensure that a contract hasn't been previously deployed to target address.\n45:         if (deployed[targetDeploymentAddress]) {\n46:             revert Errors.Create2Deployer_AlreadyDeployed(targetDeploymentAddress, salt);\n47:         }\n48: \n49:         // Prevent redeploys of contracts at the same address.\n50:         deployed[targetDeploymentAddress] = true;\n51: \n52:         // Deploy the contract.\n53:         assembly {\n54:             deploymentAddress := create2(\n55:                 // ETH value to pass to the call.\n56:                 callvalue(),\n57:                 // Init code data.\n58:                 add(initCode, 0x20),\n59:                 // Init code data length.\n60:                 mload(initCode),\n61:                 // Unique salt value.\n62:                 salt\n63:             )\n64:         }\n65: \n66:         // Check address against target to ensure that deployment was successful.\n67:         if (deploymentAddress != targetDeploymentAddress) {\n68:             revert Errors.Create2Deployer_MismatchedDeploymentAddress(\n69:                 targetDeploymentAddress,\n70:                 deploymentAddress\n71:             );\n72:         }\n73:     }\n74: \n75:     /**\n76:      * @notice Calculate the target address for contract deployment using the\n77:      *         salt and init code.\n78:      *\n79:      * @param salt     A unique value which must contain the address of the sender.\n80:      * @param initCode The init code of the contract to deploy.\n81:      *\n82:      * @return The address that would be generated from the deployment.\n83:      */\n84:     function getCreate2Address(\n85:         bytes32 salt,\n86:         bytes memory initCode\n87:     ) public view returns (address) {\n88:         // Create the address hash.\n89:         bytes32 addressHash = keccak256(\n90:             abi.encodePacked(create2_ff, address(this), salt, keccak256(initCode))\n91:         );\n92: \n93:         // Cast the hash to an address.\n94:         return address(uint160(uint256(addressHash)));\n95:     }\n96: \n97:     /**\n98:      * @notice Allows the generation of a salt using the sender address.\n99:      *         This function ties the deployment sendder to the salt of the CREATE2\n100:      *         address so that it cannot be frontrun on a different chain. More details\n101:      *         about this can be found here:\n102:      *         https://github.com/martinetlee/create2-snippets#method-1-mixing-with-salt\n103:      *\n104:      * @param sender The address of the deployer.\n105:      * @param data   The added data to make the salt unique.\n106:      */\n107:     function generateSaltWithSender(\n108:         address sender,\n109:         bytes12 data\n110:     ) public pure returns (bytes32 salt) {\n111:         assembly {\n112:             // Use `or` to combine the bytes20 address and bytes12 data together.\n113:             salt := or(\n114:                 // Shift the address 12 bytes to the left.\n115:                 shl(0x60, sender),\n116:                 // Shift the extra data 20 bytes to the right.\n117:                 shr(0xA0, data)\n118:             )\n119:         }\n120:     }\n121: }\n122: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n5: import {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\n6: import {TokenCallbackHandler} from \"@safe-contracts/handler/TokenCallbackHandler.sol\";\n7: \n8: import {ISafe} from \"@src/interfaces/ISafe.sol\";\n9: \n10: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\n11: import {toKeycode} from \"@src/libraries/KernelUtils.sol\";\n12: import {Errors} from \"@src/libraries/Errors.sol\";\n13: import {Events} from \"@src/libraries/Events.sol\";\n14: import {Storage} from \"@src/modules/Storage.sol\";\n15: import {Stop} from \"@src/policies/Stop.sol\";\n16: import {Guard} from \"@src/policies/Guard.sol\";\n17: \n18: /**\n19:  * @title Factory\n20:  * @notice Acts as an interface for all behavior related to deploying rental safes.\n21:  */\n22: contract Factory is Policy {\n23:     /////////////////////////////////////////////////////////////////////////////////\n24:     //                         Kernel Policy Configuration                         //\n25:     /////////////////////////////////////////////////////////////////////////////////\n26: \n27:     // Modules that the policy depends on.\n28:     Storage public STORE;\n29: \n30:     // policies.\n31:     Stop public immutable stopPolicy;\n32:     Guard public immutable guardPolicy;\n33: \n34:     // External contracts.\n35:     TokenCallbackHandler public immutable fallbackHandler;\n36:     SafeProxyFactory public immutable safeProxyFactory;\n37:     SafeL2 public immutable safeSingleton;\n38: \n39:     /**\n40:      * @dev Instantiate this contract as a policy.\n41:      *\n42:      * @param kernel_           Address of the kernel contract.\n43:      * @param stopPolicy_       Address of the stop policy.\n44:      * @param guardPolicy_      Address of the guard policy.\n45:      * @param fallbackHandler_  Gnosis safe fallback handler address.\n46:      * @param safeProxyFactory_ Gnosis safe proxy factory address.\n47:      * @param safeSingleton_    Gnosis safe logic contract address.\n48:      */\n49:     constructor(\n50:         Kernel kernel_,\n51:         Stop stopPolicy_,\n52:         Guard guardPolicy_,\n53:         TokenCallbackHandler fallbackHandler_,\n54:         SafeProxyFactory safeProxyFactory_,\n55:         SafeL2 safeSingleton_\n56:     ) Policy(kernel_) {\n57:         stopPolicy = stopPolicy_;\n58:         guardPolicy = guardPolicy_;\n59:         fallbackHandler = fallbackHandler_;\n60:         safeProxyFactory = safeProxyFactory_;\n61:         safeSingleton = safeSingleton_;\n62:     }\n63: \n64:     /**\n65:      * @notice Upon policy activation, configures the modules that the policy depends on.\n66:      *         If a module is ever upgraded that this policy depends on, the kernel will\n67:      *         call this function again to ensure this policy has the current address\n68:      *         of the module.\n69:      *\n70:      * @return dependencies Array of keycodes which represent modules that\n71:      *                      this policy depends on.\n72:      */\n73:     function configureDependencies()\n74:         external\n75:         override\n76:         onlyKernel\n77:         returns (Keycode[] memory dependencies)\n78:     {\n79:         dependencies = new Keycode[](1);\n80: \n81:         dependencies[0] = toKeycode(\"STORE\");\n82:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n83:     }\n84: \n85:     /**\n86:      * @notice Upon policy activation, permissions are requested from the kernel to access\n87:      *         particular keycode <> function selector pairs. Once these permissions are\n88:      *         granted, they do not change and can only be revoked when the policy is\n89:      *         deactivated by the kernel.\n90:      *\n91:      * @return requests Array of keycode <> function selector pairs which represent\n92:      *                  permissions for the policy.\n93:      */\n94:     function requestPermissions()\n95:         external\n96:         view\n97:         override\n98:         onlyKernel\n99:         returns (Permissions[] memory requests)\n100:     {\n101:         requests = new Permissions[](1);\n102:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentalSafe.selector);\n103:     }\n104: \n105:     /////////////////////////////////////////////////////////////////////////////////\n106:     //                            External Functions                               //\n107:     /////////////////////////////////////////////////////////////////////////////////\n108: \n109:     /**\n110:      * @notice Initializes a rental safe by setting it up with the stop policy and\n111:      *         rental guard during deployment.\n112:      *\n113:      *          Warning: This function assumes the invariant that delegate call will be\n114:      *          disabled or restricted by the guard policy. If delegate call were to be\n115:      *          freely allowed, then a safe could call this function after deployment\n116:      *          and change the module/guard contacts which would allow transferring\n117:      *          of rented assets out of the safe.\n118:      *\n119:      * @param _stopPolicy  Address of the stop policy to add as a module to the safe.\n120:      * @param _guardPolicy Address of the guard policy to add as a guard on the safe.\n121:      */\n122:     function initializeRentalSafe(address _stopPolicy, address _guardPolicy) external {\n123:         // Enable the module.\n124:         ISafe(address(this)).enableModule(_stopPolicy);\n125: \n126:         // Set the guard.\n127:         ISafe(address(this)).setGuard(_guardPolicy);\n128:     }\n129: \n130:     /**\n131:      * @notice Deploys and initializes a rental safe.\n132:      *\n133:      * @param owners    Array of owner addresses which will have the ability to sign\n134:      *                  transactions for the safe.\n135:      * @param threshold Number of signatures required to executed a transaction\n136:      *                  on the safe.\n137:      */\n138:     function deployRentalSafe(\n139:         address[] calldata owners,\n140:         uint256 threshold\n141:     ) external returns (address safe) {\n142:         // Require that the threshold is valid.\n143:         if (threshold == 0 || threshold > owners.length) {\n144:             revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length);\n145:         }\n146: \n147:         // Delegate call from the safe so that the rental manager module can be enabled\n148:         // right after the safe is deployed.\n149:         bytes memory data = abi.encodeCall(\n150:             Factory.initializeRentalSafe,\n151:             (address(stopPolicy), address(guardPolicy))\n152:         );\n153: \n154:         // Create gnosis initializer payload.\n155:         bytes memory initializerPayload = abi.encodeCall(\n156:             ISafe.setup,\n157:             (\n158:                 // owners array.\n159:                 owners,\n160:                 // number of signatures needed to execute transactions.\n161:                 threshold,\n162:                 // Address to direct the payload to.\n163:                 address(this),\n164:                 // Encoded call to execute.\n165:                 data,\n166:                 // Fallback manager address.\n167:                 address(fallbackHandler),\n168:                 // Payment token.\n169:                 address(0),\n170:                 // Payment amount.\n171:                 0,\n172:                 // Payment receiver\n173:                 payable(address(0))\n174:             )\n175:         );\n176: \n177:         // Deploy a safe proxy using initializer values for the Safe.setup() call\n178:         // with a salt nonce that is unique to each chain to guarantee cross-chain\n179:         // unique safe addresses.\n180:         safe = address(\n181:             safeProxyFactory.createProxyWithNonce(\n182:                 address(safeSingleton),\n183:                 initializerPayload,\n184:                 uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))\n185:             )\n186:         );\n187: \n188:         // Store the deployed safe.\n189:         STORE.addRentalSafe(safe);\n190: \n191:         // Emit the event.\n192:         emit Events.RentalSafeDeployment(safe, owners, threshold);\n193:     }\n194: }\n195: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\n5: import {Proxiable} from \"@src/proxy/Proxiable.sol\";\n6: import {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n7: import {RentalId, RentalAssetUpdate} from \"@src/libraries/RentalStructs.sol\";\n8: import {Errors} from \"@src/libraries/Errors.sol\";\n9: \n10: /**\n11:  * @title StorageBase\n12:  * @notice Storage exists in its own base contract to avoid storage slot mismatch during upgrades.\n13:  */\n14: contract StorageBase {\n15:     /////////////////////////////////////////////////////////////////////////////////\n16:     //                                Rental Storage                               //\n17:     /////////////////////////////////////////////////////////////////////////////////\n18: \n19:     // Points an order hash to whether it is active.\n20:     mapping(bytes32 orderHash => bool isActive) public orders;\n21: \n22:     // Points an item ID to its number of actively rented tokens. This is used to\n23:     // determine if an item is actively rented within the protocol. For ERC721, this\n24:     // value will always be 1 when actively rented. Any inactive rentals will have a\n25:     // value of 0.\n26:     mapping(RentalId itemId => uint256 amount) public rentedAssets;\n27: \n28:     /////////////////////////////////////////////////////////////////////////////////\n29:     //                            Deployed Safe Storage                            //\n30:     /////////////////////////////////////////////////////////////////////////////////\n31: \n32:     // Records all safes that have been deployed by the protocol.\n33:     mapping(address safe => uint256 nonce) public deployedSafes;\n34: \n35:     // Records the total amount of deployed safes.\n36:     uint256 public totalSafes;\n37: \n38:     /////////////////////////////////////////////////////////////////////////////////\n39:     //                                 Hook Storage                                //\n40:     /////////////////////////////////////////////////////////////////////////////////\n41: \n42:     // When interacting with the guard, any contracts that have hooks enabled\n43:     // should have the guard logic routed through them.\n44:     mapping(address to => address hook) internal _contractToHook;\n45: \n46:     // Mapping of a bitmap which denotes the hook functions that are enabled.\n47:     mapping(address hook => uint8 enabled) public hookStatus;\n48: \n49:     /////////////////////////////////////////////////////////////////////////////////\n50:     //                            Whitelist Storage                                //\n51:     /////////////////////////////////////////////////////////////////////////////////\n52: \n53:     // Allows the safe to delegate call to an approved address. For example, delegate\n54:     // call to a contract that would swap out an old gnosis safe module for a new one.\n55:     mapping(address delegate => bool isWhitelisted) public whitelistedDelegates;\n56: \n57:     // Allows for the safe registration of extensions that can be enabled on a safe.\n58:     mapping(address extension => bool isWhitelisted) public whitelistedExtensions;\n59: }\n60: \n61: /**\n62:  * @title Storage\n63:  * @notice Module dedicated to maintaining all the storage for the protocol. Includes\n64:  *         storage for active rentals, deployed rental safes, hooks, and whitelists.\n65:  */\n66: contract Storage is Proxiable, Module, StorageBase {\n67:     using RentalUtils for address;\n68: \n69:     /////////////////////////////////////////////////////////////////////////////////\n70:     //                         Kernel Module Configuration                         //\n71:     /////////////////////////////////////////////////////////////////////////////////\n72: \n73:     /**\n74:      * @dev Instantiate this contract as a module. When using a proxy, the kernel address\n75:      *      should be set to address(0).\n76:      *\n77:      * @param kernel_ Address of the kernel contract.\n78:      */\n79:     constructor(Kernel kernel_) Module(kernel_) {}\n80: \n81:     /**\n82:      * @notice Instantiates this contract as a module via a proxy.\n83:      *\n84:      * @param kernel_ Address of the kernel contract.\n85:      */\n86:     function MODULE_PROXY_INSTANTIATION(\n87:         Kernel kernel_\n88:     ) external onlyByProxy onlyUninitialized {\n89:         kernel = kernel_;\n90:         initialized = true;\n91:     }\n92: \n93:     /**\n94:      * @notice Specifies which version of a module is being implemented.\n95:      */\n96:     function VERSION() external pure override returns (uint8 major, uint8 minor) {\n97:         return (1, 0);\n98:     }\n99: \n100:     /**\n101:      * @notice Defines the keycode for this module.\n102:      */\n103:     function KEYCODE() public pure override returns (Keycode) {\n104:         return Keycode.wrap(\"STORE\");\n105:     }\n106: \n107:     /////////////////////////////////////////////////////////////////////////////////\n108:     //                              View Functions                                 //\n109:     /////////////////////////////////////////////////////////////////////////////////\n110: \n111:     /**\n112:      * @notice Determines if an asset is actively being rented by a wallet.\n113:      *\n114:      * @param recipient  Address of the wallet which rents the asset.\n115:      * @param token      Address of the token.\n116:      * @param identifier ID of the token.\n117:      */\n118:     function isRentedOut(\n119:         address recipient,\n120:         address token,\n121:         uint256 identifier\n122:     ) external view returns (bool) {\n123:         // calculate the rental ID\n124:         RentalId rentalId = RentalUtils.getItemPointer(recipient, token, identifier);\n125: \n126:         // Determine if there is a positive amount\n127:         return rentedAssets[rentalId] != 0;\n128:     }\n129: \n130:     /**\n131:      * @notice Fetches the hook address that is pointing at the the target.\n132:      *\n133:      * @param to Address which has a hook pointing to it.\n134:      */\n135:     function contractToHook(address to) external view returns (address) {\n136:         // Fetch the hook that the address currently points to.\n137:         address hook = _contractToHook[to];\n138: \n139:         // This hook may have been disabled without setting a new hook to take its place.\n140:         // So if the hook is disabled, then return the 0 address.\n141:         return hookStatus[hook] != 0 ? hook : address(0);\n142:     }\n143: \n144:     /**\n145:      * @notice Determines whether the `onTransaction()` function is enabled for the hook.\n146:      *\n147:      * @param hook Address of the hook contract.\n148:      */\n149:     function hookOnTransaction(address hook) external view returns (bool) {\n150:         // 1 is 0x00000001. Determines if the masked bit is enabled.\n151:         return (uint8(1) & hookStatus[hook]) != 0;\n152:     }\n153: \n154:     /**\n155:      * @notice Determines whether the `onStart()` function is enabled for the hook.\n156:      *\n157:      * @param hook Address of the hook contract.\n158:      */\n159:     function hookOnStart(address hook) external view returns (bool) {\n160:         // 2 is 0x00000010. Determines if the masked bit is enabled.\n161:         return uint8(2) & hookStatus[hook] != 0;\n162:     }\n163: \n164:     /**\n165:      * @notice Determines whether the `onStop()` function is enabled for the hook.\n166:      *\n167:      * @param hook Address of the hook contract.\n168:      */\n169:     function hookOnStop(address hook) external view returns (bool) {\n170:         // 4 is 0x00000100. Determines if the masked bit is enabled.\n171:         return uint8(4) & hookStatus[hook] != 0;\n172:     }\n173: \n174:     /////////////////////////////////////////////////////////////////////////////////\n175:     //                            External Functions                               //\n176:     /////////////////////////////////////////////////////////////////////////////////\n177: \n178:     /**\n179:      * @notice Adds an order hash to storage. Once an order hash is added to storage,\n180:      *         the assets contained within are considered actively rented. Additionally,\n181:      *         rental asset IDs are added to storage which creates a blocklist on those\n182:      *         assets. When the blocklist is active, the protocol guard becomes active on\n183:      *         them and prevents transfer or approval of the assets by the owner of the\n184:      *         safe.\n185:      *\n186:      * @param orderHash          Hash of the rental order which is added to storage.\n187:      * @param rentalAssetUpdates Asset update structs which are added to storage.\n188:      */\n189:     function addRentals(\n190:         bytes32 orderHash,\n191:         RentalAssetUpdate[] memory rentalAssetUpdates\n192:     ) external onlyByProxy permissioned {\n193:         // Add the order to storage.\n194:         orders[orderHash] = true;\n195: \n196:         // Add the rented items to storage.\n197:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n198:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n199: \n200:             // Update the order hash for that item.\n201:             rentedAssets[asset.rentalId] += asset.amount;\n202:         }\n203:     }\n204: \n205:     /**\n206:      * @notice Removes an order hash from storage. Once an order hash is removed from\n207:      *         storage, it can no longer be stopped since the protocol will have no\n208:      *         record of the order. Addtionally, rental asset IDs are removed from\n209:      *         storage. Once these hashes are removed, they are no longer blocklisted\n210:      *         from being transferred out of the rental wallet by the owner.\n211:      *\n212:      * @param orderHash          Hash of the rental order which will be removed from\n213:      *                           storage.\n214:      * @param rentalAssetUpdates Asset update structs which will be removed from storage.\n215:      */\n216:     function removeRentals(\n217:         bytes32 orderHash,\n218:         RentalAssetUpdate[] calldata rentalAssetUpdates\n219:     ) external onlyByProxy permissioned {\n220:         // The order must exist to be deleted.\n221:         if (!orders[orderHash]) {\n222:             revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n223:         } else {\n224:             // Delete the order from storage.\n225:             delete orders[orderHash];\n226:         }\n227: \n228:         // Process each rental asset.\n229:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n230:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n231: \n232:             // Reduce the amount of tokens for the particular rental ID.\n233:             rentedAssets[asset.rentalId] -= asset.amount;\n234:         }\n235:     }\n236: \n237:     /**\n238:      * @notice Behaves the same as `removeRentals()`, except that orders are processed in\n239:      *          a loop.\n240:      *\n241:      * @param orderHashes        All order hashes which will be removed from storage.\n242:      * @param rentalAssetUpdates Asset update structs which will be removed from storage.\n243:      */\n244:     function removeRentalsBatch(\n245:         bytes32[] calldata orderHashes,\n246:         RentalAssetUpdate[] calldata rentalAssetUpdates\n247:     ) external onlyByProxy permissioned {\n248:         // Delete the orders from storage.\n249:         for (uint256 i = 0; i < orderHashes.length; ++i) {\n250:             // The order must exist to be deleted.\n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:             } else {\n254:                 // Delete the order from storage.\n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n258: \n259:         // Process each rental asset.\n260:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n261:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n262: \n263:             // Reduce the amount of tokens for the particular rental ID.\n264:             rentedAssets[asset.rentalId] -= asset.amount;\n265:         }\n266:     }\n267: \n268:     /**\n269:      * @notice Adds the addresss of a rental safe to storage so that protocol-deployed\n270:      *         rental safes can be distinguished from those deployed elsewhere.\n271:      *\n272:      * @param safe Address of the rental safe to add to storage.\n273:      */\n274:     function addRentalSafe(address safe) external onlyByProxy permissioned {\n275:         // Get the new safe count.\n276:         uint256 newSafeCount = totalSafes + 1;\n277: \n278:         // Register the safe as deployed.\n279:         deployedSafes[safe] = newSafeCount;\n280: \n281:         // Increment nonce.\n282:         totalSafes = newSafeCount;\n283:     }\n284: \n285:     /**\n286:      * @notice Connects a hook to a destination address. Once an active path is made,\n287:      *         any transactions originating from a rental safe to the target address\n288:      *         will use a hook as middleware. The hook chosen is determined by the path\n289:      *         set.\n290:      *\n291:      * @param to   Target address which will use a hook as middleware.\n292:      * @param hook Address of the hook which will act as a middleware.\n293:      */\n294:     function updateHookPath(address to, address hook) external onlyByProxy permissioned {\n295:         // Require that the `to` address is a contract.\n296:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to);\n297: \n298:         // Require that the `hook` address is a contract.\n299:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n300: \n301:         // Point the `to` address to the `hook` address.\n302:         _contractToHook[to] = hook;\n303:     }\n304: \n305:     /**\n306:      * @notice Updates a hook with a bitmap that indicates its active functionality.\n307:      *         A valid bitmap is any decimal value that is less than or equal\n308:      *         to 7 (0x111).\n309:      *\n310:      * @param hook   Address of the hook contract.\n311:      * @param bitmap Decimal value that defines the active functionality on the hook.\n312:      */\n313:     function updateHookStatus(\n314:         address hook,\n315:         uint8 bitmap\n316:     ) external onlyByProxy permissioned {\n317:         // Require that the `hook` address is a contract.\n318:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n319: \n320:         // 7 is 0x00000111. This ensures that only a valid bitmap can be set.\n321:         if (bitmap > uint8(7))\n322:             revert Errors.StorageModule_InvalidHookStatusBitmap(bitmap);\n323: \n324:         // Update the status of the hook.\n325:         hookStatus[hook] = bitmap;\n326:     }\n327: \n328:     /**\n329:      * @notice Toggles whether an address can be delegate called.\n330:      *\n331:      * @param delegate  Address which can be delegate called.\n332:      * @param isEnabled Boolean indicating whether the address is enabled.\n333:      */\n334:     function toggleWhitelistDelegate(\n335:         address delegate,\n336:         bool isEnabled\n337:     ) external onlyByProxy permissioned {\n338:         whitelistedDelegates[delegate] = isEnabled;\n339:     }\n340: \n341:     /**\n342:      * @notice Toggles whether an extension is whitelisted.\n343:      *\n344:      * @param extension Gnosis safe module which can be added to a rental safe.\n345:      * @param isEnabled Boolean indicatingwhether the module is enabled.\n346:      */\n347:     function toggleWhitelistExtension(\n348:         address extension,\n349:         bool isEnabled\n350:     ) external onlyByProxy permissioned {\n351:         whitelistedExtensions[extension] = isEnabled;\n352:     }\n353: \n354:     /**\n355:      * @notice Upgrades the contract to a different implementation. This implementation\n356:      *         contract must be compatible with ERC-1822 or else the upgrade will fail.\n357:      *\n358:      * @param newImplementation Address of the implementation contract to upgrade to.\n359:      */\n360:     function upgrade(address newImplementation) external onlyByProxy permissioned {\n361:         // _upgrade is implemented in the Proxiable contract.\n362:         _upgrade(newImplementation);\n363:     }\n364: \n365:     /**\n366:      * @notice Freezes the contract which prevents upgrading the implementation contract.\n367:      *         There is no way to unfreeze once a contract has been frozen.\n368:      */\n369:     function freeze() external onlyByProxy permissioned {\n370:         // _freeze is implemented in the Proxiable contract.\n371:         _freeze();\n372:     }\n373: }\n374: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {RentalId, RentalAssetUpdate} from \"@src/libraries/RentalStructs.sol\";\n5: \n6: /**\n7:  * @title Accumulator\n8:  * @notice Package that implements functionality for managing dynamically allocated data\n9:  *         struct arrays directly in memory. The rationale for this was the need for an\n10:  *         array of structs where the total size is not known at instantiation.\n11:  */\n12: abstract contract Accumulator {\n13:     /**\n14:      * @dev Accumulates an intermediary representation of a dynamic array of\n15:      *      `RentalAssetUpdate` structs.\n16:      *\n17:      * In memory, the format of `rentalAssets` will be as follows:\n18:      *\n19:      * 0x00: Length of the intermediary representation bytes data\n20:      * 0x20: Number of `RentalAssetUpdate` elements stored\n21:      * 0x40: `rentalId` of the first element\n22:      * 0x60: `amount` of the first element\n23:      * 0x80: `rentalId` of the second element\n24:      * 0xa0: `amount` of the second element\n25:      * 0xc0: ...\n26:      *\n27:      * @param rentalAssets      Bytes value which will accumulate `RentalAssetUpdate`\n28:      *                          structs.\n29:      * @param rentalId          Rental ID to include in the next `RentalAssetUpdate`.\n30:      * @param rentalAssetAmount Amount to include in the next `RentalAssetUpdate`.\n31:      */\n32:     function _insert(\n33:         bytes memory rentalAssets,\n34:         RentalId rentalId,\n35:         uint256 rentalAssetAmount\n36:     ) internal pure {\n37:         // Place the rental ID on the stack.\n38:         bytes32 _rentalId = RentalId.unwrap(rentalId);\n39: \n40:         assembly {\n41:             // This is the first time inserting into this bytes data.\n42:             if eq(mload(rentalAssets), 0) {\n43:                 // Create some space for the initial element length word.\n44:                 mstore(rentalAssets, 0x20)\n45: \n46:                 // Zero out the number of elements.\n47:                 mstore(add(0x20, rentalAssets), 0x00)\n48:             }\n49: \n50:             // Calculate the new size of the bytes data by adding\n51:             // the size of a `RentalAssetUpdate` struct.\n52:             let newByteDataSize := add(mload(rentalAssets), 0x40)\n53: \n54:             // Get the pointer for where the element data begins.\n55:             let rentalAssetElementPtr := add(rentalAssets, 0x20)\n56: \n57:             // Increase the number of rental elements by one.\n58:             let elements := add(mload(rentalAssetElementPtr), 1)\n59: \n60:             // Calculate the position for the new rental ID.\n61:             // To do this, calculate the total length of the element portion, then\n62:             // subtract by the initial offset. In this case, the offset is the 32-byte\n63:             // word (0x20) which contains the length of the array.\n64:             let newItemPosition := add(\n65:                 rentalAssetElementPtr,\n66:                 sub(mul(elements, 0x40), 0x20)\n67:             )\n68: \n69:             // Store the new byte data size\n70:             mstore(rentalAssets, newByteDataSize)\n71: \n72:             // Store the new number of elements\n73:             mstore(rentalAssetElementPtr, elements)\n74: \n75:             // Store the rental ID\n76:             mstore(newItemPosition, _rentalId)\n77: \n78:             // Store the amount in the adjacent 32-byte word\n79:             mstore(add(newItemPosition, 0x20), rentalAssetAmount)\n80: \n81:             // Update the free memory pointer so that memory is safe\n82:             // once we stop doing dynamic memory array inserts\n83:             mstore(0x40, add(newItemPosition, 0x40))\n84:         }\n85:     }\n86: \n87:     /**\n88:      * @dev Converts an intermediary dynamic array of `RentalAssetUpdate` into a\n89:      *      conventional Solidity array.\n90:      *\n91:      * @param rentalAssetUpdates Bytes data that represents an array of\n92:      *                           `RentalAssetUpdate` structs.\n93:      *\n94:      * @return updates Solidity representation of a `RentalAssetUpdate` array.\n95:      */\n96:     function _convertToStatic(\n97:         bytes memory rentalAssetUpdates\n98:     ) internal pure returns (RentalAssetUpdate[] memory updates) {\n99:         // Pointer to the rental asset update data.\n100:         bytes32 rentalAssetUpdatePointer;\n101: \n102:         // Load the length of the rental asset update items.\n103:         uint256 rentalAssetUpdateLength;\n104:         assembly {\n105:             // Get a pointer to the number of elements in the bytes data.\n106:             // With the 0x20 offset, we would be loading the length of the entire\n107:             // byte string, but we want the element length which starts one\n108:             // word to the right.\n109:             rentalAssetUpdatePointer := add(0x20, rentalAssetUpdates)\n110: \n111:             // Load the number of elements.\n112:             rentalAssetUpdateLength := mload(rentalAssetUpdatePointer)\n113:         }\n114: \n115:         // Instantiate the update array.\n116:         updates = new RentalAssetUpdate[](rentalAssetUpdateLength);\n117: \n118:         // Iterate through each item in the byte data, and add it as\n119:         // an entry to the array.\n120:         for (uint256 i = 0; i < rentalAssetUpdateLength; ++i) {\n121:             // Define the placeholders.\n122:             RentalId rentalId;\n123:             uint256 amount;\n124: \n125:             // Extract the current element from the byte data.\n126:             assembly {\n127:                 // Determine element offset by multiplying the length of a\n128:                 // RentalAssetUpdate struct (0x40) by the current index, then\n129:                 // add a word to make sure the next word is accessed because the\n130:                 // offset defaults to being set to the length pointer.\n131:                 let currentElementOffset := add(0x20, mul(i, 0x40))\n132: \n133:                 // Load the rental ID starting at the data pointer.\n134:                 rentalId := mload(add(rentalAssetUpdatePointer, currentElementOffset))\n135: \n136:                 // Load the amount at the data pointer adjacent to it.\n137:                 amount := mload(\n138:                     add(0x20, add(rentalAssetUpdatePointer, currentElementOffset))\n139:                 )\n140:             }\n141: \n142:             // Set the items\n143:             updates[i] = RentalAssetUpdate(rentalId, amount);\n144:         }\n145:     }\n146: }\n147: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {ZoneParameters} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\";\n5: import {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\";\n6: import {LibString} from \"@solady/utils/LibString.sol\";\n7: \n8: import {ISafe} from \"@src/interfaces/ISafe.sol\";\n9: import {IHook} from \"@src/interfaces/IHook.sol\";\n10: import {ZoneInterface} from \"@src/interfaces/IZone.sol\";\n11: \n12: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\n13: import {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\";\n14: import {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n15: import {Signer} from \"@src/packages/Signer.sol\";\n16: import {Zone} from \"@src/packages/Zone.sol\";\n17: import {Accumulator} from \"@src/packages/Accumulator.sol\";\n18: import {Storage} from \"@src/modules/Storage.sol\";\n19: import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n20: import {\n21:     RentalOrder,\n22:     RentPayload,\n23:     SeaportPayload,\n24:     Hook,\n25:     OrderFulfillment,\n26:     OrderMetadata,\n27:     OrderType,\n28:     Item,\n29:     ItemType,\n30:     SettleTo,\n31:     RentalId,\n32:     RentalAssetUpdate\n33: } from \"@src/libraries/RentalStructs.sol\";\n34: import {Errors} from \"@src/libraries/Errors.sol\";\n35: import {Events} from \"@src/libraries/Events.sol\";\n36: \n37: /**\n38:  * @title Create\n39:  * @notice Acts as an interface for all behavior related to creating a rental.\n40:  */\n41: contract Create is Policy, Signer, Zone, Accumulator {\n42:     using RentalUtils for Item;\n43:     using RentalUtils for Item[];\n44:     using RentalUtils for SpentItem;\n45:     using RentalUtils for ReceivedItem;\n46:     using RentalUtils for OrderType;\n47: \n48:     /////////////////////////////////////////////////////////////////////////////////\n49:     //                         Kernel Policy Configuration                         //\n50:     /////////////////////////////////////////////////////////////////////////////////\n51: \n52:     // Modules that the policy depends on.\n53:     Storage public STORE;\n54:     PaymentEscrow public ESCRW;\n55: \n56:     /**\n57:      * @dev Instantiate this contract as a policy.\n58:      *\n59:      * @param kernel_ Address of the kernel contract.\n60:      */\n61:     constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n62: \n63:     /**\n64:      * @notice Upon policy activation, configures the modules that the policy depends on.\n65:      *         If a module is ever upgraded that this policy depends on, the kernel will\n66:      *         call this function again to ensure this policy has the current address\n67:      *         of the module.\n68:      *\n69:      * @return dependencies Array of keycodes which represent modules that\n70:      *                      this policy depends on.\n71:      */\n72:     function configureDependencies()\n73:         external\n74:         override\n75:         onlyKernel\n76:         returns (Keycode[] memory dependencies)\n77:     {\n78:         dependencies = new Keycode[](2);\n79: \n80:         dependencies[0] = toKeycode(\"STORE\");\n81:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n82: \n83:         dependencies[1] = toKeycode(\"ESCRW\");\n84:         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n85:     }\n86: \n87:     /**\n88:      * @notice Upon policy activation, permissions are requested from the kernel to access\n89:      *         particular keycode <> function selector pairs. Once these permissions are\n90:      *         granted, they do not change and can only be revoked when the policy is\n91:      *         deactivated by the kernel.\n92:      *\n93:      * @return requests Array of keycode <> function selector pairs which represent\n94:      *                  permissions for the policy.\n95:      */\n96:     function requestPermissions()\n97:         external\n98:         view\n99:         override\n100:         onlyKernel\n101:         returns (Permissions[] memory requests)\n102:     {\n103:         requests = new Permissions[](2);\n104:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentals.selector);\n105:         requests[1] = Permissions(toKeycode(\"ESCRW\"), ESCRW.increaseDeposit.selector);\n106:     }\n107: \n108:     /////////////////////////////////////////////////////////////////////////////////\n109:     //                              View Functions                                 //\n110:     /////////////////////////////////////////////////////////////////////////////////\n111: \n112:     /**\n113:      * @notice Retrieves the domain separator.\n114:      *\n115:      * @return The domain separator for the protocol.\n116:      */\n117:     function domainSeparator() external view returns (bytes32) {\n118:         return _DOMAIN_SEPARATOR;\n119:     }\n120: \n121:     /**\n122:      * @notice Derives the rental order EIP-712 compliant hash from a `RentalOrder`.\n123:      *\n124:      * @param order Rental order converted to a hash.\n125:      */\n126:     function getRentalOrderHash(\n127:         RentalOrder memory order\n128:     ) external view returns (bytes32) {\n129:         return _deriveRentalOrderHash(order);\n130:     }\n131: \n132:     /**\n133:      * @notice Derives the rent payload EIP-712 compliant hash from a `RentPayload`.\n134:      *\n135:      * @param payload Rent payload converted to a hash.\n136:      */\n137:     function getRentPayloadHash(\n138:         RentPayload memory payload\n139:     ) external view returns (bytes32) {\n140:         return _deriveRentPayloadHash(payload);\n141:     }\n142: \n143:     /**\n144:      * @notice Derives the order metadata EIP-712 compliant hash from an `OrderMetadata`.\n145:      *\n146:      * @param metadata Order metadata converted to a hash.\n147:      */\n148:     function getOrderMetadataHash(\n149:         OrderMetadata memory metadata\n150:     ) external view returns (bytes32) {\n151:         return _deriveOrderMetadataHash(metadata);\n152:     }\n153: \n154:     /////////////////////////////////////////////////////////////////////////////////\n155:     //                            Internal Functions                               //\n156:     /////////////////////////////////////////////////////////////////////////////////\n157: \n158:     /**\n159:      * @dev Helper function to emit an event which signals a rental order has started.\n160:      *\n161:      * @param order     Rental order to emit.\n162:      * @param orderHash Order hash of the seaport order.\n163:      * @param extraData Any extra data to be emitted which was supplied by the offerer.\n164:      */\n165:     function _emitRentalOrderStarted(\n166:         RentalOrder memory order,\n167:         bytes32 orderHash,\n168:         bytes memory extraData\n169:     ) internal {\n170:         // Emit the event.\n171:         emit Events.RentalOrderStarted(\n172:             orderHash,\n173:             extraData,\n174:             order.seaportOrderHash,\n175:             order.items,\n176:             order.hooks,\n177:             order.orderType,\n178:             order.lender,\n179:             order.renter,\n180:             order.rentalWallet,\n181:             order.startTimestamp,\n182:             order.endTimestamp\n183:         );\n184:     }\n185: \n186:     /**\n187:      * @dev Processes the offer items for inclusion in a BASE order. All offer items must\n188:      *      adhere to the BASE order format, else execution will revert.\n189:      *\n190:      * @param rentalItems Running array of items that comprise the rental order.\n191:      * @param offers      Array of offer items to include in the the order.\n192:      * @param startIndex  Index to begin adding the offer items to the\n193:      *                    `rentalItems` array.\n194:      */\n195:     function _processBaseOrderOffer(\n196:         Item[] memory rentalItems,\n197:         SpentItem[] memory offers,\n198:         uint256 startIndex\n199:     ) internal pure {\n200:         // Must be at least one offer item.\n201:         if (offers.length == 0) {\n202:             revert Errors.CreatePolicy_OfferCountZero();\n203:         }\n204: \n205:         // Define elements of the item which depend on the token type.\n206:         ItemType itemType;\n207: \n208:         // Process each offer item.\n209:         for (uint256 i; i < offers.length; ++i) {\n210:             // Get the offer item.\n211:             SpentItem memory offer = offers[i];\n212: \n213:             // Handle the ERC721 item.\n214:             if (offer.isERC721()) {\n215:                 itemType = ItemType.ERC721;\n216:             }\n217:             // Handle the ERC1155 item.\n218:             else if (offer.isERC1155()) {\n219:                 itemType = ItemType.ERC1155;\n220:             }\n221:             // ERC20s are not supported as offer items in a BASE order.\n222:             else {\n223:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n224:             }\n225: \n226:             // An ERC721 or ERC1155 offer item is considered a rented asset which will be\n227:             // returned to the lender upon expiration of the rental order.\n228:             rentalItems[i + startIndex] = Item({\n229:                 itemType: itemType,\n230:                 settleTo: SettleTo.LENDER,\n231:                 token: offer.token,\n232:                 amount: offer.amount,\n233:                 identifier: offer.identifier\n234:             });\n235:         }\n236:     }\n237: \n238:     /**\n239:      * @dev Processes the offer items for inclusion in a PAY order. All offer items must\n240:      *      adhere to the PAY order format, else execution will revert.\n241:      *\n242:      * @param rentalItems Running array of items that comprise the rental order.\n243:      * @param offers      Array of offer items to include in the the order.\n244:      * @param startIndex  Index to begin adding the offer items to the\n245:      *                    `rentalItems` array.\n246:      */\n247:     function _processPayOrderOffer(\n248:         Item[] memory rentalItems,\n249:         SpentItem[] memory offers,\n250:         uint256 startIndex\n251:     ) internal pure {\n252:         // Keep track of each item type.\n253:         uint256 totalRentals;\n254:         uint256 totalPayments;\n255: \n256:         // Define elements of the item which depend on the token type.\n257:         ItemType itemType;\n258:         SettleTo settleTo;\n259: \n260:         // Process each offer item.\n261:         for (uint256 i; i < offers.length; ++i) {\n262:             // Get the offer item.\n263:             SpentItem memory offer = offers[i];\n264: \n265:             // Handle the ERC721 item.\n266:             if (offer.isERC721()) {\n267:                 // The ERC721 will be returned to the lender upon expiration\n268:                 // of the rental order.\n269:                 itemType = ItemType.ERC721;\n270:                 settleTo = SettleTo.LENDER;\n271: \n272:                 // Increment rentals.\n273:                 totalRentals++;\n274:             }\n275:             // Handle the ERC1155 item.\n276:             else if (offer.isERC1155()) {\n277:                 // The ERC1155 will be returned to the lender upon expiration\n278:                 // of the rental order.\n279:                 itemType = ItemType.ERC1155;\n280:                 settleTo = SettleTo.LENDER;\n281: \n282:                 // Increment rentals.\n283:                 totalRentals++;\n284:             }\n285:             // Process an ERC20 offer item.\n286:             else if (offer.isERC20()) {\n287:                 // An ERC20 offer item is considered a payment to the renter upon\n288:                 // expiration of the rental order.\n289:                 itemType = ItemType.ERC20;\n290:                 settleTo = SettleTo.RENTER;\n291: \n292:                 // Increment payments.\n293:                 totalPayments++;\n294:             }\n295:             // Revert if unsupported item type.\n296:             else {\n297:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n298:             }\n299: \n300:             // Create the item.\n301:             rentalItems[i + startIndex] = Item({\n302:                 itemType: itemType,\n303:                 settleTo: settleTo,\n304:                 token: offer.token,\n305:                 amount: offer.amount,\n306:                 identifier: offer.identifier\n307:             });\n308:         }\n309: \n310:         // PAY order offer must have at least one rental and one payment.\n311:         if (totalRentals == 0 || totalPayments == 0) {\n312:             revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n313:         }\n314:     }\n315: \n316:     /**\n317:      * @dev Processes the consideration items for inclusion in a BASE order. All\n318:      *      consideration items must adhere to the BASE order format, else\n319:      *      execution will revert.\n320:      *\n321:      * @param rentalItems    Running array of items that comprise the rental order.\n322:      * @param considerations Array of consideration items to include in the the order.\n323:      * @param startIndex     Index to begin adding the offer items to the\n324:      *                       `rentalItems` array.\n325:      */\n326:     function _processBaseOrderConsideration(\n327:         Item[] memory rentalItems,\n328:         ReceivedItem[] memory considerations,\n329:         uint256 startIndex\n330:     ) internal pure {\n331:         // Must be at least one consideration item.\n332:         if (considerations.length == 0) {\n333:             revert Errors.CreatePolicy_ConsiderationCountZero();\n334:         }\n335: \n336:         // Process each consideration item.\n337:         for (uint256 i; i < considerations.length; ++i) {\n338:             // Get the consideration item.\n339:             ReceivedItem memory consideration = considerations[i];\n340: \n341:             // Only process an ERC20 item.\n342:             if (!consideration.isERC20()) {\n343:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n344:                     consideration.itemType\n345:                 );\n346:             }\n347: \n348:             // An ERC20 consideration item is considered a payment to the lender upon\n349:             // expiration of the rental order.\n350:             rentalItems[i + startIndex] = Item({\n351:                 itemType: ItemType.ERC20,\n352:                 settleTo: SettleTo.LENDER,\n353:                 token: consideration.token,\n354:                 amount: consideration.amount,\n355:                 identifier: consideration.identifier\n356:             });\n357:         }\n358:     }\n359: \n360:     /**\n361:      * @dev Processes the consideration items for inclusion in a PAYEE order. All\n362:      *      consideration items must adhere to the PAYEE order format, else\n363:      *      execution will revert.\n364:      *\n365:      * @param considerations Array of consideration items to include in the the order.\n366:      */\n367:     function _processPayeeOrderConsideration(\n368:         ReceivedItem[] memory considerations\n369:     ) internal pure {\n370:         // Keep track of each item type.\n371:         uint256 totalRentals;\n372:         uint256 totalPayments;\n373: \n374:         // Process each consideration item.\n375:         for (uint256 i; i < considerations.length; ++i) {\n376:             // Get the consideration item.\n377:             ReceivedItem memory consideration = considerations[i];\n378: \n379:             // Process an ERC20 item.\n380:             if (consideration.isERC20()) {\n381:                 totalPayments++;\n382:             }\n383:             // Process an ERC721 or ERC1155 consideration item.\n384:             else if (consideration.isRental()) {\n385:                 totalRentals++;\n386:             }\n387:             // Revert if unsupported item type.\n388:             else {\n389:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n390:                     consideration.itemType\n391:                 );\n392:             }\n393:         }\n394: \n395:         // PAYEE order consideration must have at least one rental and one payment.\n396:         if (totalRentals == 0 || totalPayments == 0) {\n397:             revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n398:         }\n399:     }\n400: \n401:     /**\n402:      * @dev Converts an offer array and a consideration array into a single array of\n403:      *      `Item` which comprise a rental order. The offers and considerations must\n404:      *      adhere to a specific set of rules depending on the type of order being\n405:      *      constructed.\n406:      *\n407:      * @param offers         Array of Seaport offer items.\n408:      * @param considerations Array of seaport consideration items.\n409:      * @param orderType      Order type of the rental.\n410:      */\n411:     function _convertToItems(\n412:         SpentItem[] memory offers,\n413:         ReceivedItem[] memory considerations,\n414:         OrderType orderType\n415:     ) internal pure returns (Item[] memory items) {\n416:         // Initialize an array of items.\n417:         items = new Item[](offers.length + considerations.length);\n418: \n419:         // Process items for a base order.\n420:         if (orderType.isBaseOrder()) {\n421:             // Process offer items.\n422:             _processBaseOrderOffer(items, offers, 0);\n423: \n424:             // Process consideration items.\n425:             _processBaseOrderConsideration(items, considerations, offers.length);\n426:         }\n427:         // Process items for a pay order.\n428:         else if (orderType.isPayOrder()) {\n429:             // Process offer items.\n430:             _processPayOrderOffer(items, offers, 0);\n431: \n432:             // Assert that no consideration items are provided.\n433:             if (considerations.length > 0) {\n434:                 revert Errors.CreatePolicy_ConsiderationCountNonZero(\n435:                     considerations.length\n436:                 );\n437:             }\n438:         }\n439:         // Process items for a payee order.\n440:         else if (orderType.isPayeeOrder()) {\n441:             // Assert that no offer items are provided.\n442:             if (offers.length > 0) {\n443:                 revert Errors.CreatePolicy_OfferCountNonZero(offers.length);\n444:             }\n445: \n446:             // Process consideration items.\n447:             _processPayeeOrderConsideration(considerations);\n448:         }\n449:         // Revert if order type is not supported.\n450:         else {\n451:             revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n452:         }\n453:     }\n454: \n455:     /**\n456:      * @dev When a rental order is created, process each hook one by one but only if\n457:      *      the hook's status is set to execute on a rental start.\n458:      *\n459:      * @param hooks        Array of hooks to process for the order.\n460:      * @param offerItems   Array of offer items which are referenced by the hooks\n461:      * @param rentalWallet Address of the rental wallet which is the recipient\n462:      *                     of the rented assets.\n463:      */\n464:     function _addHooks(\n465:         Hook[] memory hooks,\n466:         SpentItem[] memory offerItems,\n467:         address rentalWallet\n468:     ) internal {\n469:         // Define hook target, offer item index, and an offer item.\n470:         address target;\n471:         uint256 itemIndex;\n472:         SpentItem memory offer;\n473: \n474:         // Loop through each hook in the payload.\n475:         for (uint256 i = 0; i < hooks.length; ++i) {\n476:             // Get the hook's target address.\n477:             target = hooks[i].target;\n478: \n479:             // Check that the hook is reNFT-approved to execute on rental start.\n480:             if (!STORE.hookOnStart(target)) {\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             // Get the offer item index for this hook.\n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             // Get the offer item for this hook.\n488:             offer = offerItems[itemIndex];\n489: \n490:             // Make sure the offer item is an ERC721 or ERC1155.\n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             // Call the hook with data about the rented item.\n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 // Revert with reason given.\n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) {\n508:                 // Convert solidity panic code to string.\n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 // Revert with panic code.\n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n514:                 );\n515:             } catch (bytes memory revertData) {\n516:                 // Fallback to an error that returns the byte data.\n517:                 revert Errors.Shared_HookFailBytes(revertData);\n518:             }\n519:         }\n520:     }\n521: \n522:     /**\n523:      * @dev Initiates a rental order using a rental payload received by the fulfiller,\n524:      *      and a payload from seaport with data involving the assets that were\n525:      *      transferred in the order.\n526:      *\n527:      * @param payload Payload from the order fulfiller.\n528:      * @param seaportPayload Payload containing the result of a seaport order fulfillment.\n529:      */\n530:     function _rentFromZone(\n531:         RentPayload memory payload,\n532:         SeaportPayload memory seaportPayload\n533:     ) internal {\n534:         // Check: make sure order metadata is valid with the given seaport order zone hash.\n535:         _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n536: \n537:         // Check: verify the fulfiller of the order is an owner of the recipient safe.\n538:         _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n539: \n540:         // Check: verify each execution was sent to the expected destination.\n541:         _executionInvariantChecks(\n542:             seaportPayload.totalExecutions,\n543:             payload.fulfillment.recipient\n544:         );\n545: \n546:         // Check: validate and process seaport offer and consideration items based\n547:         // on the order type.\n548:         Item[] memory items = _convertToItems(\n549:             seaportPayload.offer,\n550:             seaportPayload.consideration,\n551:             payload.metadata.orderType\n552:         );\n553: \n554:         // PAYEE orders are considered mirror-images of a PAY order. So, PAYEE orders\n555:         // do not need to be processed in the same way that other order types do.\n556:         if (\n557:             payload.metadata.orderType.isBaseOrder() ||\n558:             payload.metadata.orderType.isPayOrder()\n559:         ) {\n560:             // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n561:             // the rented amount. From this point on, new memory cannot be safely allocated until the\n562:             // accumulator no longer needs to include elements.\n563:             bytes memory rentalAssetUpdates = new bytes(0);\n564: \n565:             // Check if each item is a rental. If so, then generate the rental asset update.\n566:             // Memory will become safe again after this block.\n567:             for (uint256 i; i < items.length; ++i) {\n568:                 if (items[i].isRental()) {\n569:                     // Insert the rental asset update into the dynamic array.\n570:                     _insert(\n571:                         rentalAssetUpdates,\n572:                         items[i].toRentalId(payload.fulfillment.recipient),\n573:                         items[i].amount\n574:                     );\n575:                 }\n576:             }\n577: \n578:             // Generate the rental order.\n579:             RentalOrder memory order = RentalOrder({\n580:                 seaportOrderHash: seaportPayload.orderHash,\n581:                 items: items,\n582:                 hooks: payload.metadata.hooks,\n583:                 orderType: payload.metadata.orderType,\n584:                 lender: seaportPayload.offerer,\n585:                 renter: payload.intendedFulfiller,\n586:                 rentalWallet: payload.fulfillment.recipient,\n587:                 startTimestamp: block.timestamp,\n588:                 endTimestamp: block.timestamp + payload.metadata.rentDuration\n589:             });\n590: \n591:             // Compute the order hash.\n592:             bytes32 orderHash = _deriveRentalOrderHash(order);\n593: \n594:             // Interaction: Update storage only if the order is a Base Order or Pay order.\n595:             STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n596: \n597:             // Interaction: Increase the deposit value on the payment escrow so\n598:             // it knows how many tokens were sent to it.\n599:             for (uint256 i = 0; i < items.length; ++i) {\n600:                 if (items[i].isERC20()) {\n601:                     ESCRW.increaseDeposit(items[i].token, items[i].amount);\n602:                 }\n603:             }\n604: \n605:             // Interaction: Process the hooks associated with this rental.\n606:             if (payload.metadata.hooks.length > 0) {\n607:                 _addHooks(\n608:                     payload.metadata.hooks,\n609:                     seaportPayload.offer,\n610:                     payload.fulfillment.recipient\n611:                 );\n612:             }\n613: \n614:             // Emit rental order started.\n615:             _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n616:         }\n617:     }\n618: \n619:     /**\n620:      * @dev Checks that the order metadata passed with the seaport order is expected.\n621:      *\n622:      * @param metadata Order metadata that was passed in with the fulfillment.\n623:      * @param zoneHash Hash of the order metadata that was passed in when the Seaport\n624:      *                 order was signed.\n625:      */\n626:     function _isValidOrderMetadata(\n627:         OrderMetadata memory metadata,\n628:         bytes32 zoneHash\n629:     ) internal view {\n630:         // Check that the rent duration specified is not zero.\n631:         if (metadata.rentDuration == 0) {\n632:             revert Errors.CreatePolicy_RentDurationZero();\n633:         }\n634: \n635:         // Check that the zone hash is equal to the derived hash of the metadata.\n636:         if (_deriveOrderMetadataHash(metadata) != zoneHash) {\n637:             revert Errors.CreatePolicy_InvalidOrderMetadataHash();\n638:         }\n639:     }\n640: \n641:     /**\n642:      * @dev Checks that an address is the owner of a protocol-deployed rental safe.\n643:      *\n644:      * @param owner Address of the potential safe owner.\n645:      * @param safe  Address of the potential protocol-deployed rental safe.\n646:      */\n647:     function _isValidSafeOwner(address owner, address safe) internal view {\n648:         // Make sure only protocol-deployed safes can rent.\n649:         if (STORE.deployedSafes(safe) == 0) {\n650:             revert Errors.CreatePolicy_InvalidRentalSafe(safe);\n651:         }\n652: \n653:         // Make sure the fulfiller is the owner of the recipient rental safe.\n654:         if (!ISafe(safe).isOwner(owner)) {\n655:             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);\n656:         }\n657:     }\n658: \n659:     /**\n660:      * @dev Helper function to check that an execution performed by Seaport resulting\n661:      *      in the expected address receiving the asset.\n662:      *\n663:      * @param execution Execution that was performed by Seaport.\n664:      * @param expectedRecipient Address which should now own the rented asset.\n665:      */\n666:     function _checkExpectedRecipient(\n667:         ReceivedItem memory execution,\n668:         address expectedRecipient\n669:     ) internal pure {\n670:         if (execution.recipient != expectedRecipient) {\n671:             revert Errors.CreatePolicy_UnexpectedTokenRecipient(\n672:                 execution.itemType,\n673:                 execution.token,\n674:                 execution.identifier,\n675:                 execution.amount,\n676:                 execution.recipient,\n677:                 expectedRecipient\n678:             );\n679:         }\n680:     }\n681: \n682:     /**\n683:      * @dev After a Seaport order has been executed, invariant checks are made to ensure\n684:      *      that all assets are owned by the correct addresses. More specifically, all\n685:      *      ERC20 tokens are sent to the payment escrow module, and all rental assets\n686:      *      are in the intended recipient's rental safe.\n687:      *\n688:      * @param executions Each execution that was performed by Seaport.\n689:      * @param expectedRentalSafe The intended recipient of the rental assets.\n690:      */\n691:     function _executionInvariantChecks(\n692:         ReceivedItem[] memory executions,\n693:         address expectedRentalSafe\n694:     ) internal view {\n695:         for (uint256 i = 0; i < executions.length; ++i) {\n696:             ReceivedItem memory execution = executions[i];\n697: \n698:             // ERC20 invariant where the recipient must be the payment escrow.\n699:             if (execution.isERC20()) {\n700:                 _checkExpectedRecipient(execution, address(ESCRW));\n701:             }\n702:             // ERC721 and ERC1155 invariants where the recipient must\n703:             // be the expected rental safe.\n704:             else if (execution.isRental()) {\n705:                 _checkExpectedRecipient(execution, expectedRentalSafe);\n706:             }\n707:             // Revert if unsupported item type.\n708:             else {\n709:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n710:                     execution.itemType\n711:                 );\n712:             }\n713:         }\n714:     }\n715: \n716:     /////////////////////////////////////////////////////////////////////////////////\n717:     //                            External Functions                               //\n718:     /////////////////////////////////////////////////////////////////////////////////\n719: \n720:     /**\n721:      * @notice Callback function implemented to make this contract a valid Seaport zone.\n722:      *         It can be considered the entrypoint to creating a rental. When a seaport\n723:      *         order specifies the create policy as its zone address, Seaport will call\n724:      *         this function after each order in the batch is processed. A call to\n725:      *         `validateOrder` is what kicks off the rental process, and performs steps\n726:      *         to convert a seaport order into a rental order which is stored\n727:      *         by the protocol.\n728:      *\n729:      * @param zoneParams Parameters from the seaport order.\n730:      *\n731:      * @return validOrderMagicValue A `bytes4` value to return back to Seaport.\n732:      */\n733:     function validateOrder(\n734:         ZoneParameters calldata zoneParams\n735:     ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue) {\n736:         // Decode the signed rental zone payload from the extra data.\n737:         (RentPayload memory payload, bytes memory signature) = abi.decode(\n738:             zoneParams.extraData,\n739:             (RentPayload, bytes)\n740:         );\n741: \n742:         // Create a payload of seaport data.\n743:         SeaportPayload memory seaportPayload = SeaportPayload({\n744:             orderHash: zoneParams.orderHash,\n745:             zoneHash: zoneParams.zoneHash,\n746:             offer: zoneParams.offer,\n747:             consideration: zoneParams.consideration,\n748:             totalExecutions: zoneParams.totalExecutions,\n749:             fulfiller: zoneParams.fulfiller,\n750:             offerer: zoneParams.offerer\n751:         });\n752: \n753:         // Check: The signature from the protocol signer has not expired.\n754:         _validateProtocolSignatureExpiration(payload.expiration);\n755: \n756:         // Check: The fulfiller is the intended fulfiller.\n757:         _validateFulfiller(payload.intendedFulfiller, seaportPayload.fulfiller);\n758: \n759:         // Recover the signer from the payload.\n760:         address signer = _recoverSignerFromPayload(\n761:             _deriveRentPayloadHash(payload),\n762:             signature\n763:         );\n764: \n765:         // Check: The data matches the signature and that the protocol signer is the one that signed.\n766:         if (!kernel.hasRole(signer, toRole(\"CREATE_SIGNER\"))) {\n767:             revert Errors.CreatePolicy_UnauthorizedCreatePolicySigner();\n768:         }\n769: \n770:         // Initiate the rental using the rental manager.\n771:         _rentFromZone(payload, seaportPayload);\n772: \n773:         // Return the selector of validateOrder as the magic value.\n774:         validOrderMagicValue = ZoneInterface.validateOrder.selector;\n775:     }\n776: }\n777: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {Enum} from \"@safe-contracts/common/Enum.sol\";\n5: import {LibString} from \"@solady/utils/LibString.sol\";\n6: \n7: import {ISafe} from \"@src/interfaces/ISafe.sol\";\n8: import {IHook} from \"@src/interfaces/IHook.sol\";\n9: \n10: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\n11: import {toKeycode} from \"@src/libraries/KernelUtils.sol\";\n12: import {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n13: import {Signer} from \"@src/packages/Signer.sol\";\n14: import {Reclaimer} from \"@src/packages/Reclaimer.sol\";\n15: import {Accumulator} from \"@src/packages/Accumulator.sol\";\n16: import {Storage} from \"@src/modules/Storage.sol\";\n17: import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n18: import {Errors} from \"@src/libraries/Errors.sol\";\n19: import {Events} from \"@src/libraries/Events.sol\";\n20: import {\n21:     Item,\n22:     RentalOrder,\n23:     Hook,\n24:     OrderType,\n25:     ItemType,\n26:     RentalId,\n27:     RentalAssetUpdate\n28: } from \"@src/libraries/RentalStructs.sol\";\n29: \n30: /**\n31:  * @title Stop\n32:  * @notice Acts as an interface for all behavior related to stoping a rental.\n33:  */\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator {\n35:     using RentalUtils for Item;\n36:     using RentalUtils for Item[];\n37:     using RentalUtils for OrderType;\n38: \n39:     /////////////////////////////////////////////////////////////////////////////////\n40:     //                         Kernel Policy Configuration                         //\n41:     /////////////////////////////////////////////////////////////////////////////////\n42: \n43:     // Modules that the policy depends on.\n44:     Storage public STORE;\n45:     PaymentEscrow public ESCRW;\n46: \n47:     /**\n48:      * @dev Instantiate this contract as a policy.\n49:      *\n50:      * @param kernel_ Address of the kernel contract.\n51:      */\n52:     constructor(Kernel kernel_) Policy(kernel_) Signer() Reclaimer() {}\n53: \n54:     /**\n55:      * @notice Upon policy activation, configures the modules that the policy depends on.\n56:      *         If a module is ever upgraded that this policy depends on, the kernel will\n57:      *         call this function again to ensure this policy has the current address\n58:      *         of the module.\n59:      *\n60:      * @return dependencies Array of keycodes which represent modules that\n61:      *                      this policy depends on.\n62:      */\n63:     function configureDependencies()\n64:         external\n65:         override\n66:         onlyKernel\n67:         returns (Keycode[] memory dependencies)\n68:     {\n69:         dependencies = new Keycode[](2);\n70: \n71:         dependencies[0] = toKeycode(\"STORE\");\n72:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n73: \n74:         dependencies[1] = toKeycode(\"ESCRW\");\n75:         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n76:     }\n77: \n78:     /**\n79:      * @notice Upon policy activation, permissions are requested from the kernel to access\n80:      *         particular keycode <> function selector pairs. Once these permissions are\n81:      *         granted, they do not change and can only be revoked when the policy is\n82:      *         deactivated by the kernel.\n83:      *\n84:      * @return requests Array of keycode <> function selector pairs which represent\n85:      *                  permissions for the policy.\n86:      */\n87:     function requestPermissions()\n88:         external\n89:         view\n90:         override\n91:         onlyKernel\n92:         returns (Permissions[] memory requests)\n93:     {\n94:         requests = new Permissions[](4);\n95:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);\n96:         requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);\n97:         requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);\n98:         requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);\n99:     }\n100: \n101:     /////////////////////////////////////////////////////////////////////////////////\n102:     //                            Internal Functions                               //\n103:     /////////////////////////////////////////////////////////////////////////////////\n104: \n105:     /**\n106:      * @dev Helper function to emit an event which signals a rental order has stopped.\n107:      *\n108:      * @param seaportOrderHash Order hash of the seaport order.\n109:      * @param stopper Address which stopped the rental order.\n110:      */\n111:     function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal {\n112:         // Wmit the event.\n113:         emit Events.RentalOrderStopped(seaportOrderHash, stopper);\n114:     }\n115: \n116:     /**\n117:      * @dev Validates that a rental order can be stopped. Whether an order\n118:      *      can be stopped is dependent on the type of order. BASE orders can\n119:      *      be stopped only when the rental has expired. PAY orders can be stopped\n120:      *      by the lender at any point in the time.\n121:      *\n122:      * @param orderType Order type of the rental order to stop.\n123:      * @param endTimestamp Timestamp that the rental will end.\n124:      * @param expectedLender Address of the initial lender in the order.\n125:      */\n126:     function _validateRentalCanBeStoped(\n127:         OrderType orderType,\n128:         uint256 endTimestamp,\n129:         address expectedLender\n130:     ) internal view {\n131:         // Determine if the order has expired.\n132:         bool hasExpired = endTimestamp <= block.timestamp;\n133: \n134:         // Determine if the fulfiller is the lender of the order.\n135:         bool isLender = expectedLender == msg.sender;\n136: \n137:         // BASE orders processing.\n138:         if (orderType.isBaseOrder()) {\n139:             // check that the period for the rental order has expired.\n140:             if (!hasExpired) {\n141:                 revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n142:             }\n143:         }\n144:         // PAY order processing.\n145:         else if (orderType.isPayOrder()) {\n146:             // If the stopper is the lender, then it doesnt matter whether the rental\n147:             // has expired. But if the stopper is not the lender, then the rental must have expired.\n148:             if (!isLender && (!hasExpired)) {\n149:                 revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n150:             }\n151:         }\n152:         // Revert if given an invalid order type.\n153:         else {\n154:             revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n155:         }\n156:     }\n157: \n158:     /**\n159:      * @dev Since the stop policy is an enabled Gnosis Safe module on all rental safes, it\n160:      *      can be used to execute a transaction directly from the rental safe which retrieves\n161:      *      the rented assets. This call bypasses the guard that prevents the assets from being\n162:      *      transferred.\n163:      *\n164:      * @param order Rental order to reclaim the items for.\n165:      */\n166:     function _reclaimRentedItems(RentalOrder memory order) internal {\n167:         // Transfer ERC721s from the renter back to lender.\n168:         bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n169:             // Stop policy inherits the reclaimer package.\n170:             address(this),\n171:             // value.\n172:             0,\n173:             // The encoded call to the `reclaimRentalOrder` function.\n174:             abi.encodeWithSelector(this.reclaimRentalOrder.selector, order),\n175:             // Safe must delegate call to the stop policy so that it is the msg.sender.\n176:             Enum.Operation.DelegateCall\n177:         );\n178: \n179:         // Assert that the transfer back to the lender was successful.\n180:         if (!success) {\n181:             revert Errors.StopPolicy_ReclaimFailed();\n182:         }\n183:     }\n184: \n185:     /**\n186:      * @dev When a rental order is stopped, process each hook one by one but only if\n187:      *      the hook's status is set to execute on a rental stop.\n188:      *\n189:      * @param hooks        Array of hooks to process for the order.\n190:      * @param rentalItems  Array of rental items which are referenced by the hooks\n191:      * @param rentalWallet Address of the rental wallet which is the current owner\n192:      *                     of the rented assets.\n193:      */\n194:     function _removeHooks(\n195:         Hook[] calldata hooks,\n196:         Item[] calldata rentalItems,\n197:         address rentalWallet\n198:     ) internal {\n199:         // Define hook target, item index, and item.\n200:         address target;\n201:         uint256 itemIndex;\n202:         Item memory item;\n203: \n204:         // Loop through each hook in the payload.\n205:         for (uint256 i = 0; i < hooks.length; ++i) {\n206:             // Get the hook address.\n207:             target = hooks[i].target;\n208: \n209:             // Check that the hook is reNFT-approved to execute on rental stop.\n210:             if (!STORE.hookOnStop(target)) {\n211:                 revert Errors.Shared_DisabledHook(target);\n212:             }\n213: \n214:             // Get the rental item index for this hook.\n215:             itemIndex = hooks[i].itemIndex;\n216: \n217:             // Get the rental item for this hook.\n218:             item = rentalItems[itemIndex];\n219: \n220:             // Make sure the item is a rented item.\n221:             if (!item.isRental()) {\n222:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n223:             }\n224: \n225:             // Call the hook with data about the rented item.\n226:             try\n227:                 IHook(target).onStop(\n228:                     rentalWallet,\n229:                     item.token,\n230:                     item.identifier,\n231:                     item.amount,\n232:                     hooks[i].extraData\n233:                 )\n234:             {} catch Error(string memory revertReason) {\n235:                 // Revert with reason given.\n236:                 revert Errors.Shared_HookFailString(revertReason);\n237:             } catch Panic(uint256 errorCode) {\n238:                 // Convert solidity panic code to string.\n239:                 string memory stringErrorCode = LibString.toString(errorCode);\n240: \n241:                 // Revert with panic code.\n242:                 revert Errors.Shared_HookFailString(\n243:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n244:                 );\n245:             } catch (bytes memory revertData) {\n246:                 // Fallback to an error that returns the byte data.\n247:                 revert Errors.Shared_HookFailBytes(revertData);\n248:             }\n249:         }\n250:     }\n251: \n252:     /////////////////////////////////////////////////////////////////////////////////\n253:     //                            External Functions                               //\n254:     /////////////////////////////////////////////////////////////////////////////////\n255: \n256:     /**\n257:      * @notice Stops a rental by providing a `RentalOrder` struct. This data does not\n258:      *         exist in protocol storage, only the hash of the rental order. However,\n259:      *         during rental creation, all data needed to construct the rental order\n260:      *         is emitted as an event. A check is then made to ensure that the passed\n261:      *         in rental order matches the hash of a rental order in storage.\n262:      *\n263:      * @param order Rental order to stop.\n264:      */\n265:     function stopRent(RentalOrder calldata order) external {\n266:         // Check that the rental can be stopped.\n267:         _validateRentalCanBeStoped(order.orderType, order.endTimestamp, order.lender);\n268: \n269:         // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n270:         // the rented amount. From this point on, new memory cannot be safely allocated until the\n271:         // accumulator no longer needs to include elements.\n272:         bytes memory rentalAssetUpdates = new bytes(0);\n273: \n274:         // Check if each item in the order is a rental. If so, then generate the rental asset update.\n275:         // Memory will become safe again after this block.\n276:         for (uint256 i; i < order.items.length; ++i) {\n277:             if (order.items[i].isRental()) {\n278:                 // Insert the rental asset update into the dynamic array.\n279:                 _insert(\n280:                     rentalAssetUpdates,\n281:                     order.items[i].toRentalId(order.rentalWallet),\n282:                     order.items[i].amount\n283:                 );\n284:             }\n285:         }\n286: \n287:         // Interaction: process hooks so they no longer exist for the renter.\n288:         if (order.hooks.length > 0) {\n289:             _removeHooks(order.hooks, order.items, order.rentalWallet);\n290:         }\n291: \n292:         // Interaction: Transfer rentals from the renter back to lender.\n293:         _reclaimRentedItems(order);\n294: \n295:         // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n296:         ESCRW.settlePayment(order);\n297: \n298:         // Interaction: Remove rentals from storage by computing the order hash.\n299:         STORE.removeRentals(\n300:             _deriveRentalOrderHash(order),\n301:             _convertToStatic(rentalAssetUpdates)\n302:         );\n303: \n304:         // Emit rental order stopped.\n305:         _emitRentalOrderStopped(order.seaportOrderHash, msg.sender);\n306:     }\n307: \n308:     /**\n309:      * @notice Stops a batch of rentals by providing an array of `RentalOrder` structs.\n310:      *\n311:      * @param orders Array of rental orders to stop.\n312:      */\n313:     function stopRentBatch(RentalOrder[] calldata orders) external {\n314:         // Create an array of rental order hashes which will be removed from storage.\n315:         bytes32[] memory orderHashes = new bytes32[](orders.length);\n316: \n317:         // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n318:         // the rented amount. From this point on, new memory cannot be safely allocated until the\n319:         // accumulator no longer needs to include elements.\n320:         bytes memory rentalAssetUpdates = new bytes(0);\n321: \n322:         // Process each rental order.\n323:         // Memory will become safe after this block.\n324:         for (uint256 i = 0; i < orders.length; ++i) {\n325:             // Check that the rental can be stopped.\n326:             _validateRentalCanBeStoped(\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             // Check if each item in the order is a rental. If so, then generate the rental asset update.\n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) {\n334:                 // Insert the rental asset update into the dynamic array.\n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert(\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             // Add the order hash to an array.\n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n346: \n347:             // Interaction: Process hooks so they no longer exist for the renter.\n348:             if (orders[i].hooks.length > 0) {\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n350:             }\n351: \n352:             // Interaction: Transfer rental assets from the renter back to lender.\n353:             _reclaimRentedItems(orders[i]);\n354: \n355:             // Emit rental order stopped.\n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:         }\n358: \n359:         // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n360:         ESCRW.settlePaymentBatch(orders);\n361: \n362:         // Interaction: Remove all rentals from storage.\n363:         STORE.removeRentalsBatch(orderHashes, _convertToStatic(rentalAssetUpdates));\n364:     }\n365: }\n366: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\n5: import {toKeycode} from \"@src/libraries/KernelUtils.sol\";\n6: import {Storage} from \"@src/modules/Storage.sol\";\n7: import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n8: \n9: /**\n10:  * @title Admin\n11:  * @notice Acts as an interface for all behavior in the protocol related\n12:  *         admin logic. Admin duties include fee management, proxy management,\n13:  *         and whitelist management.\n14:  */\n15: contract Admin is Policy {\n16:     /////////////////////////////////////////////////////////////////////////////////\n17:     //                         Kernel Policy Configuration                         //\n18:     /////////////////////////////////////////////////////////////////////////////////\n19: \n20:     // Modules that the policy depends on.\n21:     Storage public STORE;\n22:     PaymentEscrow public ESCRW;\n23: \n24:     /**\n25:      * @dev Instantiate this contract as a policy.\n26:      *\n27:      * @param kernel_ Address of the kernel contract.\n28:      */\n29:     constructor(Kernel kernel_) Policy(kernel_) {}\n30: \n31:     /**\n32:      * @notice Upon policy activation, configures the modules that the policy depends on.\n33:      *         If a module is ever upgraded that this policy depends on, the kernel will\n34:      *         call this function again to ensure this policy has the current address\n35:      *         of the module.\n36:      *\n37:      * @return dependencies Array of keycodes which represent modules that\n38:      *                      this policy depends on.\n39:      */\n40:     function configureDependencies()\n41:         external\n42:         override\n43:         onlyKernel\n44:         returns (Keycode[] memory dependencies)\n45:     {\n46:         dependencies = new Keycode[](2);\n47: \n48:         dependencies[0] = toKeycode(\"STORE\");\n49:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n50: \n51:         dependencies[1] = toKeycode(\"ESCRW\");\n52:         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n53:     }\n54: \n55:     /**\n56:      * @notice Upon policy activation, permissions are requested from the kernel to access\n57:      *         particular keycode <> function selector pairs. Once these permissions are\n58:      *         granted, they do not change and can only be revoked when the policy is\n59:      *         deactivated by the kernel.\n60:      *\n61:      * @return requests Array of keycode <> function selector pairs which represent\n62:      *                  permissions for the policy.\n63:      */\n64:     function requestPermissions()\n65:         external\n66:         view\n67:         override\n68:         onlyKernel\n69:         returns (Permissions[] memory requests)\n70:     {\n71:         requests = new Permissions[](8);\n72:         requests[0] = Permissions(\n73:             toKeycode(\"STORE\"),\n74:             STORE.toggleWhitelistExtension.selector\n75:         );\n76:         requests[1] = Permissions(\n77:             toKeycode(\"STORE\"),\n78:             STORE.toggleWhitelistDelegate.selector\n79:         );\n80:         requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n81:         requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n82: \n83:         requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n84:         requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n85:         requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n86:         requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n87:     }\n88: \n89:     /////////////////////////////////////////////////////////////////////////////////\n90:     //                            External Functions                               //\n91:     /////////////////////////////////////////////////////////////////////////////////\n92: \n93:     /**\n94:      * @notice Toggle whether an address can be delegate called by a rental safe.\n95:      *\n96:      * @param delegate  Target address for the delegate call.\n97:      * @param isEnabled Whether the address can be delegate called.\n98:      */\n99:     function toggleWhitelistDelegate(\n100:         address delegate,\n101:         bool isEnabled\n102:     ) external onlyRole(\"ADMIN_ADMIN\") {\n103:         STORE.toggleWhitelistDelegate(delegate, isEnabled);\n104:     }\n105: \n106:     /**\n107:      * @notice Toggle whether an extension is whitelisted. An extension is any contract\n108:      *         which can be added to a rental safe as a Safe module.\n109:      *\n110:      * @param extension Extension which can be added to a safe.\n111:      * @param isEnabled Whether the extension is enabled.\n112:      */\n113:     function toggleWhitelistExtension(\n114:         address extension,\n115:         bool isEnabled\n116:     ) external onlyRole(\"ADMIN_ADMIN\") {\n117:         STORE.toggleWhitelistExtension(extension, isEnabled);\n118:     }\n119: \n120:     /**\n121:      * @notice Upgrades the storage module to a newer implementation. The new\n122:      *         implementation contract must adhere to ERC-1822.\n123:      *\n124:      * @param newImplementation Address of the new implemention.\n125:      */\n126:     function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") {\n127:         STORE.upgrade(newImplementation);\n128:     }\n129: \n130:     /**\n131:      * @notice Freezes the storage module so that no proxy upgrades can take place. This\n132:      *         action is non-reversible.\n133:      */\n134:     function freezeStorage() external onlyRole(\"ADMIN_ADMIN\") {\n135:         STORE.freeze();\n136:     }\n137: \n138:     /**\n139:      * @notice Upgrades the payment escrow module to a newer implementation.\n140:      *         The new implementation contract must adhere to ERC-1822.\n141:      *\n142:      * @param newImplementation Address of the new implemention.\n143:      */\n144:     function upgradePaymentEscrow(\n145:         address newImplementation\n146:     ) external onlyRole(\"ADMIN_ADMIN\") {\n147:         ESCRW.upgrade(newImplementation);\n148:     }\n149: \n150:     /**\n151:      * @notice Freezes the payment escrow module so that no proxy upgrades can take\n152:      *         place. This action is non-reversible.\n153:      */\n154:     function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\") {\n155:         ESCRW.freeze();\n156:     }\n157: \n158:     /**\n159:      * @notice Skims all protocol fees from the escrow module to the target address.\n160:      *\n161:      * @param token Token address which denominates the fee.\n162:      * @param to    Destination address to send the tokens.\n163:      */\n164:     function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") {\n165:         ESCRW.skim(token, to);\n166:     }\n167: \n168:     /**\n169:      * @notice Sets the protocol fee numerator. Numerator cannot be greater than 10,000.\n170:      *\n171:      * @param feeNumerator Numerator for the fee.\n172:      */\n173:     function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") {\n174:         ESCRW.setFee(feeNumerator);\n175:     }\n176: }\n177: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\n5: \n6: import {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\n7: import {Proxiable} from \"@src/proxy/Proxiable.sol\";\n8: import {\n9:     RentalOrder,\n10:     Item,\n11:     ItemType,\n12:     SettleTo,\n13:     OrderType\n14: } from \"@src/libraries/RentalStructs.sol\";\n15: import {Errors} from \"@src/libraries/Errors.sol\";\n16: import {Events} from \"@src/libraries/Events.sol\";\n17: import {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n18: \n19: /**\n20:  * @title PaymentEscrowBase\n21:  * @notice Storage exists in its own base contract to avoid storage slot mismatch during upgrades.\n22:  */\n23: contract PaymentEscrowBase {\n24:     // Keeps a record of the current token balances in the escrow.\n25:     mapping(address token => uint256 amount) public balanceOf;\n26: \n27:     // Fee percentage taken from payments.\n28:     uint256 public fee;\n29: }\n30: \n31: /**\n32:  * @title PaymentEscrow\n33:  * @notice Module dedicated to escrowing rental payments while rentals are active. When\n34:  *         rentals are stopped, this module will determine payouts to all parties and a\n35:  *         fee will be reserved to be withdrawn later by a protocol admin.\n36:  */\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n38:     using RentalUtils for Item;\n39:     using RentalUtils for OrderType;\n40: \n41:     /////////////////////////////////////////////////////////////////////////////////\n42:     //                         Kernel Module Configuration                         //\n43:     /////////////////////////////////////////////////////////////////////////////////\n44: \n45:     /**\n46:      * @dev Instantiate this contract as a module. When using a proxy, the kernel address\n47:      *      should be set to address(0).\n48:      *\n49:      * @param kernel_ Address of the kernel contract.\n50:      */\n51:     constructor(Kernel kernel_) Module(kernel_) {}\n52: \n53:     /**\n54:      * @notice Instantiates this contract as a module via a proxy.\n55:      *\n56:      * @param kernel_ Address of the kernel contract.\n57:      */\n58:     function MODULE_PROXY_INSTANTIATION(\n59:         Kernel kernel_\n60:     ) external onlyByProxy onlyUninitialized {\n61:         kernel = kernel_;\n62:         initialized = true;\n63:     }\n64: \n65:     /**\n66:      * @notice Specifies which version of a module is being implemented.\n67:      */\n68:     function VERSION() external pure override returns (uint8 major, uint8 minor) {\n69:         return (1, 0);\n70:     }\n71: \n72:     /**\n73:      * @notice Defines the keycode for this module.\n74:      */\n75:     function KEYCODE() public pure override returns (Keycode) {\n76:         return Keycode.wrap(\"ESCRW\");\n77:     }\n78: \n79:     /////////////////////////////////////////////////////////////////////////////////\n80:     //                            Internal Functions                               //\n81:     /////////////////////////////////////////////////////////////////////////////////\n82: \n83:     /**\n84:      * @dev Calculates the fee based on the fee numerator set by an admin.\n85:      *\n86:      * @param amount Amount for which to calculate the fee.\n87:      */\n88:     function _calculateFee(uint256 amount) internal view returns (uint256) {\n89:         // Uses 10,000 as a denominator for the fee.\n90:         return (amount * fee) / 10000;\n91:     }\n92: \n93:     /**\n94:      * @dev Safe transfer for ERC20 tokens that do not consistently renturn true/false.\n95:      *\n96:      * @param token Asset address which is being sent.\n97:      * @param to    Destination address for the transfer.\n98:      * @param value Amount of the asset being transferred.\n99:      */\n100:     function _safeTransfer(address token, address to, uint256 value) internal {\n101:         // Call transfer() on the token.\n102:         (bool success, bytes memory data) = token.call(\n103:             abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n104:         );\n105: \n106:         // Because both reverting and returning false are allowed by the ERC20 standard\n107:         // to indicate a failed transfer, we must handle both cases.\n108:         //\n109:         // If success is false, the ERC20 contract reverted.\n110:         //\n111:         // If success is true, we must check if return data was provided. If no return\n112:         // data is provided, then no revert occurred. But, if return data is provided,\n113:         // then it must be decoded into a bool which will indicate the success of the\n114:         // transfer.\n115:         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n116:             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n117:         }\n118:     }\n119: \n120:     /**\n121:      * @dev Calculates the pro-rata split based on the amount of time that has elapsed in\n122:      *      a rental order. If there are not enough funds to split perfectly, rounding is\n123:      *      done to make the split as fair as possible.\n124:      *\n125:      * @param amount      Amount of tokens for which to calculate the split.\n126:      * @param elapsedTime Elapsed time since the rental started.\n127:      * @param totalTime   Total time window of the rental from start to end.\n128:      *\n129:      * @return renterAmount Payment amount to send to the renter.\n130:      * @return lenderAmount Payment amoutn to send to the lender.\n131:      */\n132:     function _calculatePaymentProRata(\n133:         uint256 amount,\n134:         uint256 elapsedTime,\n135:         uint256 totalTime\n136:     ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n137:         // Calculate the numerator and adjust by a multiple of 1000.\n138:         uint256 numerator = (amount * elapsedTime) * 1000;\n139: \n140:         // Calculate the result, but bump by 500 to add a rounding adjustment. Then,\n141:         // reduce by a multiple of 1000.\n142:         renterAmount = ((numerator / totalTime) + 500) / 1000;\n143: \n144:         // Calculate lender amount from renter amount so no tokens are left behind.\n145:         lenderAmount = amount - renterAmount;\n146:     }\n147: \n148:     /**\n149:      * @dev Settles a payment via a pro-rata split. After payments are calculated, they\n150:      *      are transferred to their respective recipients.\n151:      *\n152:      * @param token       Token address for which to settle a payment.\n153:      * @param amount      Amount of the token to settle.\n154:      * @param lender      Lender account.\n155:      * @param renter      Renter accoutn.\n156:      * @param elapsedTime Elapsed time since the rental started.\n157:      * @param totalTime   Total time window of the rental from start to end.\n158:      */\n159:     function _settlePaymentProRata(\n160:         address token,\n161:         uint256 amount,\n162:         address lender,\n163:         address renter,\n164:         uint256 elapsedTime,\n165:         uint256 totalTime\n166:     ) internal {\n167:         // Calculate the pro-rata payment for renter and lender.\n168:         (uint256 renterAmount, uint256 lenderAmount) = _calculatePaymentProRata(\n169:             amount,\n170:             elapsedTime,\n171:             totalTime\n172:         );\n173: \n174:         // Send the lender portion of the payment.\n175:         _safeTransfer(token, lender, lenderAmount);\n176: \n177:         // Send the renter portion of the payment.\n178:         _safeTransfer(token, renter, renterAmount);\n179:     }\n180: \n181:     /**\n182:      * @dev Settles a payment by sending the full amount to one address.\n183:      *\n184:      * @param token    Token address for which to settle a payment.\n185:      * @param amount   Amount of the token to settle.\n186:      * @param settleTo Specifies whether to settle to the lender or the renter.\n187:      * @param lender   Lender account.\n188:      * @param renter   Renter account.\n189:      */\n190:     function _settlePaymentInFull(\n191:         address token,\n192:         uint256 amount,\n193:         SettleTo settleTo,\n194:         address lender,\n195:         address renter\n196:     ) internal {\n197:         // Determine the address that this payment will settle to.\n198:         address settleToAddress = settleTo == SettleTo.LENDER ? lender : renter;\n199: \n200:         // Send the payment.\n201:         _safeTransfer(token, settleToAddress, amount);\n202:     }\n203: \n204:     /**\n205:      * @dev Settles alls payments contained in the given item. Uses a pro-rata or in full\n206:      *      scheme depending on the order type and when the order was stopped.\n207:      *\n208:      * @param items     Items present in the order.\n209:      * @param orderType Type of the order.\n210:      * @param lender    Lender account.\n211:      * @param renter    Renter account.\n212:      * @param start     Timestamp that the rental began.\n213:      * @param end       Timestamp that the rental expires at.\n214:      */\n215:     function _settlePayment(\n216:         Item[] calldata items,\n217:         OrderType orderType,\n218:         address lender,\n219:         address renter,\n220:         uint256 start,\n221:         uint256 end\n222:     ) internal {\n223:         // Calculate the time values.\n224:         uint256 elapsedTime = block.timestamp - start;\n225:         uint256 totalTime = end - start;\n226: \n227:         // Determine whether the rental order has ended.\n228:         bool isRentalOver = elapsedTime >= totalTime;\n229: \n230:         // Loop through each item in the order.\n231:         for (uint256 i = 0; i < items.length; ++i) {\n232:             // Get the item.\n233:             Item memory item = items[i];\n234: \n235:             // Check that the item is a payment.\n236:             if (item.isERC20()) {\n237:                 // Set a placeholder payment amount which can be reduced in the\n238:                 // presence of a fee.\n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 // Take a fee on the payment amount if the fee is on.\n242:                 if (fee != 0) {\n243:                     // Calculate the new fee.\n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     // Adjust the payment amount by the fee.\n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 // Effect: Decrease the token balance. Use the payment amount pre-fee\n251:                 // so that fees can be taken.\n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 // If its a PAY order but the rental hasn't ended yet.\n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     // Interaction: a PAY order which hasnt ended yet. Payout is pro-rata.\n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 // If its a PAY order and the rental is over, or, if its a BASE order.\n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     // Interaction: a pay order or base order which has ended. Payout is in full.\n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n281:             }\n282:         }\n283:     }\n284: \n285:     /**\n286:      * @dev Decreases the tracked token balance of a particular token on the payment\n287:      *      escrow contract.\n288:      *\n289:      * @param token  Token address.\n290:      * @param amount Amount to decrease the balance by.\n291:      */\n292:     function _decreaseDeposit(address token, uint256 amount) internal {\n293:         // Directly decrease the synced balance.\n294:         balanceOf[token] -= amount;\n295:     }\n296: \n297:     /**\n298:      * @dev Increases the tracked token balance of a particular token on the payment\n299:      *      escrow contract.\n300:      *\n301:      * @param token  Token address.\n302:      * @param amount Amount to increase the balance by.\n303:      */\n304:     function _increaseDeposit(address token, uint256 amount) internal {\n305:         // Directly increase the synced balance.\n306:         balanceOf[token] += amount;\n307:     }\n308: \n309:     /////////////////////////////////////////////////////////////////////////////////\n310:     //                            External Functions                               //\n311:     /////////////////////////////////////////////////////////////////////////////////\n312: \n313:     /**\n314:      * @notice Settles the payment for a rental order by transferring all items marked as\n315:      *         payments to their destination accounts. During the settlement process, if\n316:      *         active, a fee is taken on the payment.\n317:      *\n318:      * @param order Rental order for which to settle a payment.\n319:      */\n320:     function settlePayment(RentalOrder calldata order) external onlyByProxy permissioned {\n321:         // Settle all payments for the order.\n322:         _settlePayment(\n323:             order.items,\n324:             order.orderType,\n325:             order.lender,\n326:             order.renter,\n327:             order.startTimestamp,\n328:             order.endTimestamp\n329:         );\n330:     }\n331: \n332:     /**\n333:      * @notice Settles the payments for multiple orders by looping through each one.\n334:      *\n335:      * @param orders Rental ordesr for which to settle payments.\n336:      */\n337:     function settlePaymentBatch(\n338:         RentalOrder[] calldata orders\n339:     ) external onlyByProxy permissioned {\n340:         // Loop through each order.\n341:         for (uint256 i = 0; i < orders.length; ++i) {\n342:             // Settle all payments for the order.\n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n352:     }\n353: \n354:     /**\n355:      * @notice When fungible tokens are transferred to the payment escrow contract,\n356:      *         their balances should be increased.\n357:      *\n358:      * @param token  Token address for the asset.\n359:      * @param amount Amount of the token transferred to the escrow\n360:      */\n361:     function increaseDeposit(\n362:         address token,\n363:         uint256 amount\n364:     ) external onlyByProxy permissioned {\n365:         // Cannot accept a payment of zero.\n366:         if (amount == 0) {\n367:             revert Errors.PaymentEscrow_ZeroPayment();\n368:         }\n369: \n370:         // Increase the deposit\n371:         _increaseDeposit(token, amount);\n372:     }\n373: \n374:     /**\n375:      * @notice Sets the numerator for the fee. The denominator will always be set at\n376:      *         10,000.\n377:      *\n378:      * @param feeNumerator Numerator of the fee.\n379:      */\n380:     function setFee(uint256 feeNumerator) external onlyByProxy permissioned {\n381:         // Cannot accept a fee numerator greater than 10000.\n382:         if (feeNumerator > 10000) {\n383:             revert Errors.PaymentEscrow_InvalidFeeNumerator();\n384:         }\n385: \n386:         // Set the fee.\n387:         fee = feeNumerator;\n388:     }\n389: \n390:     /**\n391:      * @notice Used to collect protocol fees. In addition, if funds are accidentally sent\n392:      *         to the payment escrow contract, this function can be used to skim them off.\n393:      *\n394:      * @param token Address of the token to skim.\n395:      * @param to    Address to send the collected tokens.\n396:      */\n397:     function skim(address token, address to) external onlyByProxy permissioned {\n398:         // Fetch the currently synced balance of the escrow.\n399:         uint256 syncedBalance = balanceOf[token];\n400: \n401:         // Fetch the true token balance of the escrow.\n402:         uint256 trueBalance = IERC20(token).balanceOf(address(this));\n403: \n404:         // Calculate the amount to skim.\n405:         uint256 skimmedBalance = trueBalance - syncedBalance;\n406: \n407:         // Send the difference to the specified address.\n408:         _safeTransfer(token, to, skimmedBalance);\n409: \n410:         // Emit event with fees taken.\n411:         emit Events.FeeTaken(token, skimmedBalance);\n412:     }\n413: \n414:     /**\n415:      * @notice Upgrades the contract to a different implementation. This implementation\n416:      *         contract must be compatible with ERC-1822 or else the upgrade will fail.\n417:      *\n418:      * @param newImplementation Address of the implementation contract to upgrade to.\n419:      */\n420:     function upgrade(address newImplementation) external onlyByProxy permissioned {\n421:         // _upgrade is implemented in the Proxiable contract.\n422:         _upgrade(newImplementation);\n423:     }\n424: \n425:     /**\n426:      * @notice Freezes the contract which prevents upgrading the implementation contract.\n427:      *         There is no way to unfreeze once a contract has been frozen.\n428:      */\n429:     function freeze() external onlyByProxy permissioned {\n430:         // _freeze is implemented in the Proxiable contract.\n431:         _freeze();\n432:     }\n433: }\n434: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {IERC721} from \"@openzeppelin-contracts/token/ERC721/IERC721.sol\";\n5: import {IERC1155} from \"@openzeppelin-contracts/token/ERC1155/IERC1155.sol\";\n6: \n7: import {RentalOrder, Item, ItemType} from \"@src/libraries/RentalStructs.sol\";\n8: import {Errors} from \"@src/libraries/Errors.sol\";\n9: \n10: /**\n11:  * @title Reclaimer\n12:  * @notice Retrieves rented assets from a wallet contract once a rental has been\n13:  *         stopped, and transfers them to the proper recipient.\n14:  */\n15: abstract contract Reclaimer {\n16:     // The original address that this contract was deployed with\n17:     address private immutable original;\n18: \n19:     /**\n20:      * @dev Use the constructor to store the original deployment address.\n21:      */\n22:     constructor() {\n23:         original = address(this);\n24:     }\n25: \n26:     /**\n27:      * @dev Helper function to transfer an ERC721 token.\n28:      *\n29:      * @param item      Item which will be transferred.\n30:      * @param recipient Address which will receive the token.\n31:      */\n32:     function _transferERC721(Item memory item, address recipient) private {\n33:         IERC721(item.token).safeTransferFrom(address(this), recipient, item.identifier);\n34:     }\n35: \n36:     /**\n37:      * @dev Helper function to transfer an ERC1155 token.\n38:      *\n39:      * @param item      Item which will be transferred.\n40:      * @param recipient Address which will receive the token.\n41:      */\n42:     function _transferERC1155(Item memory item, address recipient) private {\n43:         IERC1155(item.token).safeTransferFrom(\n44:             address(this),\n45:             recipient,\n46:             item.identifier,\n47:             item.amount,\n48:             \"\"\n49:         );\n50:     }\n51: \n52:     /**\n53:      * @notice Reclaims the assets that are currently owned by a rental safe.\n54:      *         This function is intended to be delegate called by the safe.\n55:      *\n56:      *         NOTE: At first, it may seem that this function can be used to exploit\n57:      *         the safe, since this is an external function that can transfer tokens\n58:      *         out of a rental safe, so long as the caller is:\n59:      *             1) Using delegate call to extract the assets\n60:      *             2) The rental safe that holds those assets\n61:      *\n62:      *         This exploit is prevented because delegate calls from the rental safe can\n63:      *         only be made to addresses which have been explicitly whitelisted by the\n64:      *         Admin policy. Further, since the Stop policy is a whitelisted module on\n65:      *         the safe, `reclaimRentalOrder()` can only be called via the context of the\n66:      *         Stop policy contract, which prevents unauthorized reclaiming.\n67:      *\n68:      * @param rentalOrder Order which will have its contained items reclaimed by the\n69:      *                    recipient parties.\n70:      */\n71:     function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n72:         // This contract address must be in the context of another address.\n73:         if (address(this) == original) {\n74:             revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed();\n75:         }\n76: \n77:         // Only the rental wallet specified in the order can be the address that\n78:         // initates the reclaim. In the context of a delegate call, address(this)\n79:         // will be the safe.\n80:         if (address(this) != rentalOrder.rentalWallet) {\n81:             revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed(\n82:                 rentalOrder.rentalWallet\n83:             );\n84:         }\n85: \n86:         // Get a count for the number of items.\n87:         uint256 itemCount = rentalOrder.items.length;\n88: \n89:         // Transfer each item if it is a rented asset.\n90:         for (uint256 i = 0; i < itemCount; ++i) {\n91:             Item memory item = rentalOrder.items[i];\n92: \n93:             // Check if the item is an ERC721.\n94:             if (item.itemType == ItemType.ERC721)\n95:                 _transferERC721(item, rentalOrder.lender);\n96: \n97:             // check if the item is an ERC1155.\n98:             if (item.itemType == ItemType.ERC1155)\n99:                 _transferERC1155(item, rentalOrder.lender);\n100:         }\n101:     }\n102: }\n103: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n5: \n6: import {\n7:     RentPayload,\n8:     Hook,\n9:     RentalOrder,\n10:     OrderFulfillment,\n11:     OrderMetadata,\n12:     Item\n13: } from \"@src/libraries/RentalStructs.sol\";\n14: import {Errors} from \"@src/libraries/Errors.sol\";\n15: \n16: /**\n17:  * @title Signer\n18:  * @notice Contains logic related to signed payloads and signature verification when\n19:  *         creating rentals.\n20:  */\n21: abstract contract Signer {\n22:     using ECDSA for bytes32;\n23: \n24:     // Declare constants for name and version.\n25:     string internal constant _NAME = \"ReNFT-Rentals\";\n26:     string internal constant _VERSION = \"1.0.0\";\n27: \n28:     // Precompute hashes, original chainId, and domain separator on deployment.\n29:     bytes32 internal immutable _NAME_HASH;\n30:     bytes32 internal immutable _VERSION_HASH;\n31:     bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\n32:     uint256 internal immutable _CHAIN_ID;\n33:     bytes32 internal immutable _DOMAIN_SEPARATOR;\n34:     bytes32 internal immutable _ITEM_TYPEHASH;\n35:     bytes32 internal immutable _HOOK_TYPEHASH;\n36:     bytes32 internal immutable _RENTAL_ORDER_TYPEHASH;\n37:     bytes32 internal immutable _ORDER_FULFILLMENT_TYPEHASH;\n38:     bytes32 internal immutable _ORDER_METADATA_TYPEHASH;\n39:     bytes32 internal immutable _RENT_PAYLOAD_TYPEHASH;\n40: \n41:     /**\n42:      * @dev Sets up the type hashes and sets the chain ID.\n43:      */\n44:     constructor() {\n45:         // Derive name, version, and EIP-712 typehashes.\n46:         (\n47:             _NAME_HASH,\n48:             _VERSION_HASH,\n49:             _EIP_712_DOMAIN_TYPEHASH,\n50:             _DOMAIN_SEPARATOR\n51:         ) = _deriveTypehashes();\n52: \n53:         // Derive name and version hashes alongside required EIP-712 typehashes.\n54:         (\n55:             _ITEM_TYPEHASH,\n56:             _HOOK_TYPEHASH,\n57:             _RENTAL_ORDER_TYPEHASH,\n58:             _ORDER_FULFILLMENT_TYPEHASH,\n59:             _ORDER_METADATA_TYPEHASH,\n60:             _RENT_PAYLOAD_TYPEHASH\n61:         ) = _deriveRentalTypehashes();\n62: \n63:         // Store the current chainId and derive the current domain separator.\n64:         _CHAIN_ID = block.chainid;\n65:     }\n66: \n67:     /**\n68:      * @dev Validates that the expected fulfiller of the order is the same as the address\n69:      *      executed the order. This check is meant to prevent order sniping where one\n70:      *      party receives a server-side signature but another party intercepts the\n71:      *      signature and uses it.\n72:      *\n73:      * @param intendedFulfiller Address that was expected to execute the order.\n74:      * @param actualFulfiller   Address that actually executed the order.\n75:      */\n76:     function _validateFulfiller(\n77:         address intendedFulfiller,\n78:         address actualFulfiller\n79:     ) internal pure {\n80:         // Check actual fulfiller against the intended fulfiller.\n81:         if (intendedFulfiller != actualFulfiller) {\n82:             revert Errors.SignerPackage_UnauthorizedFulfiller(\n83:                 actualFulfiller,\n84:                 intendedFulfiller\n85:             );\n86:         }\n87:     }\n88: \n89:     /**\n90:      * @dev Validates that the server-side signature has not expired.\n91:      *\n92:      * @param expiration Expiration time of the signature.\n93:      */\n94:     function _validateProtocolSignatureExpiration(uint256 expiration) internal view {\n95:         // Check that the signature provided by the protocol signer has not expired.\n96:         if (block.timestamp > expiration) {\n97:             revert Errors.SignerPackage_SignatureExpired(block.timestamp, expiration);\n98:         }\n99:     }\n100: \n101:     /**\n102:      * @dev Recovers the signer of the payload hash.\n103:      *\n104:      * @param payloadHash The payload hash which was signed.\n105:      * @param signature   The signature data for the payload hash.\n106:      */\n107:     function _recoverSignerFromPayload(\n108:         bytes32 payloadHash,\n109:         bytes memory signature\n110:     ) internal view returns (address) {\n111:         // Derive original EIP-712 digest using domain separator and order hash.\n112:         bytes32 digest = _DOMAIN_SEPARATOR.toTypedDataHash(payloadHash);\n113: \n114:         // Recover the signer address of the signature.\n115:         return digest.recover(signature);\n116:     }\n117: \n118:     /**\n119:      * @dev Derives the hash of a given item using a type hash.\n120:      *\n121:      * @param item Item to hash.\n122:      *\n123:      * @return The hash of the item.\n124:      */\n125:     function _deriveItemHash(Item memory item) internal view returns (bytes32) {\n126:         // Derive and return the item as specified by EIP-712.\n127:         return\n128:             keccak256(\n129:                 abi.encode(\n130:                     _ITEM_TYPEHASH,\n131:                     item.itemType,\n132:                     item.settleTo,\n133:                     item.token,\n134:                     item.amount,\n135:                     item.identifier\n136:                 )\n137:             );\n138:     }\n139: \n140:     /**\n141:      * @dev Derives the hash of a given hook using a type hash.\n142:      *\n143:      * @param hook Hook to hash.\n144:      *\n145:      * @return The hash of the hook.\n146:      */\n147:     function _deriveHookHash(Hook memory hook) internal view returns (bytes32) {\n148:         // Derive and return the hook as specified by EIP-712.\n149:         return\n150:             keccak256(\n151:                 abi.encode(_HOOK_TYPEHASH, hook.target, hook.itemIndex, hook.extraData)\n152:             );\n153:     }\n154: \n155:     /**\n156:      * @dev Derives the hash of a given rental order using a type hash.\n157:      *\n158:      * @param order Rental order to hash.\n159:      *\n160:      * @return The hash of the rental order.\n161:      */\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         // Create arrays for items and hooks.\n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         // Iterate over each item.\n170:         for (uint256 i = 0; i < order.items.length; ++i) {\n171:             // Hash the item.\n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         // Iterate over each hook.\n176:         for (uint256 i = 0; i < order.hooks.length; ++i) {\n177:             // Hash the hook.\n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)),\n187:                     keccak256(abi.encodePacked(hookHashes)),\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n196: \n197:     /**\n198:      * @dev Derives the hash of a given fulfillment using a type hash.\n199:      *\n200:      * @param fulfillment Order fulfillment to hash.\n201:      *\n202:      * @return The hash of the order fulfillment.\n203:      */\n204:     function _deriveOrderFulfillmentHash(\n205:         OrderFulfillment memory fulfillment\n206:     ) internal view returns (bytes32) {\n207:         // Derive and return the fulfilmment hash as specified by EIP-712\n208:         return keccak256(abi.encode(_ORDER_FULFILLMENT_TYPEHASH, fulfillment.recipient));\n209:     }\n210: \n211:     /**\n212:      * @dev Derives the hash of a given order metadata using a type hash.\n213:      *\n214:      * @param metadata Order metadata to hash.\n215:      *\n216:      * @return The hash of the order metadata.\n217:      */\n218:     function _deriveOrderMetadataHash(\n219:         OrderMetadata memory metadata\n220:     ) internal view returns (bytes32) {\n221:         // Create array for hooks.\n222:         bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n223: \n224:         // Iterate over each hook.\n225:         for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n226:             // Hash the hook\n227:             hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n228:         }\n229: \n230:         // Derive and return the metadata hash as specified by EIP-712.\n231:         return\n232:             keccak256(\n233:                 abi.encode(\n234:                     _ORDER_METADATA_TYPEHASH,\n235:                     metadata.rentDuration,\n236:                     keccak256(abi.encodePacked(hookHashes))\n237:                 )\n238:             );\n239:     }\n240: \n241:     /**\n242:      * @dev Derives the hash of a given payload using a type hash.\n243:      *\n244:      * @param payload Rent payload to hash.\n245:      *\n246:      * @return The hash of the rent payload.\n247:      */\n248:     function _deriveRentPayloadHash(\n249:         RentPayload memory payload\n250:     ) internal view returns (bytes32) {\n251:         // Derive and return the rent payload hash as specified by EIP-712.\n252:         return\n253:             keccak256(\n254:                 abi.encode(\n255:                     _RENT_PAYLOAD_TYPEHASH,\n256:                     _deriveOrderFulfillmentHash(payload.fulfillment),\n257:                     _deriveOrderMetadataHash(payload.metadata),\n258:                     payload.expiration,\n259:                     payload.intendedFulfiller\n260:                 )\n261:             );\n262:     }\n263: \n264:     /**\n265:      * @dev Derives the hash of the domain separator.\n266:      *\n267:      * @param _eip712DomainTypeHash The standard EIP-712 domain type string.\n268:      * @param _nameHash             Hash of the contract name.\n269:      * @param _versionHash          Hash of the contract version.\n270:      *\n271:      * @return The hash of the domain separator.\n272:      */\n273:     function _deriveDomainSeparator(\n274:         bytes32 _eip712DomainTypeHash,\n275:         bytes32 _nameHash,\n276:         bytes32 _versionHash\n277:     ) internal view virtual returns (bytes32) {\n278:         return\n279:             keccak256(\n280:                 abi.encode(\n281:                     _eip712DomainTypeHash,\n282:                     _nameHash,\n283:                     _versionHash,\n284:                     block.chainid,\n285:                     address(this)\n286:                 )\n287:             );\n288:     }\n289: \n290:     /**\n291:      * @dev Derives the standard EIP-712 type hashes.\n292:      *\n293:      * @return nameHash             Hash of the contract name.\n294:      * @return versionHash          Hash of the contract version.\n295:      * @return eip712DomainTypehash Hash of the EIP-712 Domain.\n296:      * @return domainSeparator      The constructed domain separator.\n297:      */\n298:     function _deriveTypehashes()\n299:         internal\n300:         view\n301:         returns (\n302:             bytes32 nameHash,\n303:             bytes32 versionHash,\n304:             bytes32 eip712DomainTypehash,\n305:             bytes32 domainSeparator\n306:         )\n307:     {\n308:         // Derive the name type hash.\n309:         nameHash = keccak256(bytes(_NAME));\n310: \n311:         // Derive the version type hash.\n312:         versionHash = keccak256(bytes(_VERSION));\n313: \n314:         // Construct the primary EIP-712 domain type string.\n315:         eip712DomainTypehash = keccak256(\n316:             abi.encodePacked(\n317:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n318:             )\n319:         );\n320: \n321:         // Construct the domain separator.\n322:         domainSeparator = _deriveDomainSeparator(\n323:             eip712DomainTypehash,\n324:             nameHash,\n325:             versionHash\n326:         );\n327:     }\n328: \n329:     /**\n330:      * @dev Derives the protocol-specific type hashes.\n331:      *\n332:      * @return itemTypeHash             Type hash of the item.\n333:      * @return hookTypeHash             Type hash of the hook.\n334:      * @return rentalOrderTypeHash      Type hash of the rental order.\n335:      * @return orderFulfillmentTypeHash Type hash of the order fulfillment.\n336:      * @return orderMetadataTypeHash    Type hash of the order metadata.\n337:      * @return rentPayloadTypeHash      Type hash of the rent payload.\n338:      */\n339:     function _deriveRentalTypehashes()\n340:         internal\n341:         pure\n342:         returns (\n343:             bytes32 itemTypeHash,\n344:             bytes32 hookTypeHash,\n345:             bytes32 rentalOrderTypeHash,\n346:             bytes32 orderFulfillmentTypeHash,\n347:             bytes32 orderMetadataTypeHash,\n348:             bytes32 rentPayloadTypeHash\n349:         )\n350:     {\n351:         // Construct the Item type string.\n352:         bytes memory itemTypeString = abi.encodePacked(\n353:             \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n354:         );\n355: \n356:         // Construct the Hook type string.\n357:         bytes memory hookTypeString = abi.encodePacked(\n358:             \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n359:         );\n360: \n361:         // Construct the RentalOrder type string.\n362:         bytes memory rentalOrderTypeString = abi.encodePacked(\n363:             \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n364:         );\n365: \n366:         // Derive the Item type hash using the corresponding type string.\n367:         itemTypeHash = keccak256(itemTypeString);\n368: \n369:         // Derive the Hook type hash using the corresponding type string.\n370:         hookTypeHash = keccak256(hookTypeString);\n371: \n372:         // Derive the RentalOrder type hash using the corresponding type string.\n373:         rentalOrderTypeHash = keccak256(\n374:             abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n375:         );\n376: \n377:         {\n378:             // Construct the OrderFulfillment type string.\n379:             bytes memory orderFulfillmentTypeString = abi.encodePacked(\n380:                 \"OrderFulfillment(address recipient)\"\n381:             );\n382: \n383:             // Construct the OrderMetadata type string.\n384:             bytes memory orderMetadataTypeString = abi.encodePacked(\n385:                 \"OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\"\n386:             );\n387: \n388:             // Construct the RentPayload type string.\n389:             bytes memory rentPayloadTypeString = abi.encodePacked(\n390:                 \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\"\n391:             );\n392: \n393:             // Derive RentPayload type hash via combination of relevant type strings.\n394:             rentPayloadTypeHash = keccak256(\n395:                 abi.encodePacked(\n396:                     rentPayloadTypeString,\n397:                     orderMetadataTypeString,\n398:                     orderFulfillmentTypeString\n399:                 )\n400:             );\n401: \n402:             // Derive the OrderFulfillment type hash using the corresponding type string.\n403:             orderFulfillmentTypeHash = keccak256(orderFulfillmentTypeString);\n404: \n405:             // Derive the OrderMetadata type hash using the corresponding type string.\n406:             orderMetadataTypeHash = keccak256(orderMetadataTypeString);\n407:         }\n408:     }\n409: }\n410: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\";\n5: import {Enum} from \"@safe-contracts/common/Enum.sol\";\n6: import {LibString} from \"@solady/utils/LibString.sol\";\n7: \n8: import {IHook} from \"@src/interfaces/IHook.sol\";\n9: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\n10: import {toKeycode} from \"@src/libraries/KernelUtils.sol\";\n11: import {Storage} from \"@src/modules/Storage.sol\";\n12: import {\n13:     shared_set_approval_for_all_selector,\n14:     e721_approve_selector,\n15:     e721_safe_transfer_from_1_selector,\n16:     e721_safe_transfer_from_2_selector,\n17:     e721_transfer_from_selector,\n18:     e721_approve_token_id_offset,\n19:     e721_safe_transfer_from_1_token_id_offset,\n20:     e721_safe_transfer_from_2_token_id_offset,\n21:     e721_transfer_from_token_id_offset,\n22:     e1155_safe_transfer_from_selector,\n23:     e1155_safe_batch_transfer_from_selector,\n24:     e1155_safe_transfer_from_token_id_offset,\n25:     e1155_safe_batch_transfer_from_token_id_offset,\n26:     gnosis_safe_set_guard_selector,\n27:     gnosis_safe_enable_module_selector,\n28:     gnosis_safe_disable_module_selector,\n29:     gnosis_safe_enable_module_offset,\n30:     gnosis_safe_disable_module_offset\n31: } from \"@src/libraries/RentalConstants.sol\";\n32: import {Errors} from \"@src/libraries/Errors.sol\";\n33: \n34: /**\n35:  * @title Guard\n36:  * @notice Acts as an interface for all behavior related to guarding transactions\n37:  *         that originate from a rental wallet.\n38:  */\n39: contract Guard is Policy, BaseGuard {\n40:     /////////////////////////////////////////////////////////////////////////////////\n41:     //                         Kernel Policy Configuration                         //\n42:     /////////////////////////////////////////////////////////////////////////////////\n43: \n44:     // Modules that the policy depends on.\n45:     Storage public STORE;\n46: \n47:     /**\n48:      * @dev Instantiate this contract as a policy.\n49:      *\n50:      * @param kernel_ Address of the kernel contract.\n51:      */\n52:     constructor(Kernel kernel_) Policy(kernel_) {}\n53: \n54:     /**\n55:      * @notice Upon policy activation, configures the modules that the policy depends on.\n56:      *         If a module is ever upgraded that this policy depends on, the kernel will\n57:      *         call this function again to ensure this policy has the current address\n58:      *         of the module.\n59:      *\n60:      * @return dependencies Array of keycodes which represent modules that\n61:      *                      this policy depends on.\n62:      */\n63:     function configureDependencies()\n64:         external\n65:         override\n66:         onlyKernel\n67:         returns (Keycode[] memory dependencies)\n68:     {\n69:         dependencies = new Keycode[](1);\n70: \n71:         dependencies[0] = toKeycode(\"STORE\");\n72:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n73:     }\n74: \n75:     /**\n76:      * @notice Upon policy activation, permissions are requested from the kernel to access\n77:      *         particular keycode <> function selector pairs. Once these permissions are\n78:      *         granted, they do not change and can only be revoked when the policy is\n79:      *         deactivated by the kernel.\n80:      *\n81:      * @return requests Array of keycode <> function selector pairs which represent\n82:      *                  permissions for the policy.\n83:      */\n84:     function requestPermissions()\n85:         external\n86:         view\n87:         override\n88:         onlyKernel\n89:         returns (Permissions[] memory requests)\n90:     {\n91:         requests = new Permissions[](2);\n92:         requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n93:         requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n94:     }\n95: \n96:     /////////////////////////////////////////////////////////////////////////////////\n97:     //                            Internal Functions                               //\n98:     /////////////////////////////////////////////////////////////////////////////////\n99: \n100:     /**\n101:      * @dev Loads a `bytes32` value from calldata.\n102:      *\n103:      * @param data   Calldata of the transaction to execute.\n104:      * @param offset Byte offset where the value starts.\n105:      *\n106:      * @return value The value retrieved from the data.\n107:      */\n108:     function _loadValueFromCalldata(\n109:         bytes memory data,\n110:         uint256 offset\n111:     ) private pure returns (bytes32 value) {\n112:         // Load the `uint256` from calldata at the offset.\n113:         assembly {\n114:             value := mload(add(data, offset))\n115:         }\n116:     }\n117: \n118:     /**\n119:      * @dev Reverts if the token is actively rented.\n120:      *\n121:      * @param selector Function selector which cannot be called\n122:      * @param safe     Address of the safe that originated the call\n123:      * @param token    Address of the token which is actively rented.\n124:      * @param tokenId  ID of the token which is actively rented.\n125:      */\n126:     function _revertSelectorOnActiveRental(\n127:         bytes4 selector,\n128:         address safe,\n129:         address token,\n130:         uint256 tokenId\n131:     ) private view {\n132:         // Check if the selector is allowed.\n133:         if (STORE.isRentedOut(safe, token, tokenId)) {\n134:             revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n135:         }\n136:     }\n137: \n138:     /**\n139:      * @dev Reverts if the extension is not whitelisted.\n140:      *\n141:      * @param extension Address of the extension.\n142:      */\n143:     function _revertNonWhitelistedExtension(address extension) private view {\n144:         // Check if the extension is whitelisted.\n145:         if (!STORE.whitelistedExtensions(extension)) {\n146:             revert Errors.GuardPolicy_UnauthorizedExtension(extension);\n147:         }\n148:     }\n149: \n150:     /**\n151:      * @dev Forwards a gnosis safe call to a hook contract for further processing.\n152:      *\n153:      * @param hook  Address of the hook contract.\n154:      * @param safe  Address of the rental wallet that originated the call.\n155:      * @param to    Address that the call is directed to.\n156:      * @param value Value of ether sent with the call.\n157:      * @param data  Calldata to execute.\n158:      */\n159:     function _forwardToHook(\n160:         address hook,\n161:         address safe,\n162:         address to,\n163:         uint256 value,\n164:         bytes memory data\n165:     ) private {\n166:         // Call the `onTransaction` hook function.\n167:         try IHook(hook).onTransaction(safe, to, value, data) {} catch Error(\n168:             string memory revertReason\n169:         ) {\n170:             // Revert with reason given.\n171:             revert Errors.Shared_HookFailString(revertReason);\n172:         } catch Panic(uint256 errorCode) {\n173:             // Convert solidity panic code to string.\n174:             string memory stringErrorCode = LibString.toString(errorCode);\n175: \n176:             // Revert with panic code.\n177:             revert Errors.Shared_HookFailString(\n178:                 string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n179:             );\n180:         } catch (bytes memory revertData) {\n181:             // Fallback to an error that returns the byte data.\n182:             revert Errors.Shared_HookFailBytes(revertData);\n183:         }\n184:     }\n185: \n186:     /**\n187:      * @dev Prevent transactions that involve transferring an ERC721 or ERC1155 in any\n188:      *      way, and prevent transactions that involve changing the modules or the\n189:      *      guard contract.\n190:      *\n191:      * @param from Rental safe address that initiated the transaction.\n192:      * @param to Address that the data is targetted to.\n193:      * @param data Calldata of the transaction.\n194:      */\n195:     function _checkTransaction(address from, address to, bytes memory data) private view {\n196:         bytes4 selector;\n197: \n198:         // Load in the function selector.\n199:         assembly {\n200:             selector := mload(add(data, 0x20))\n201:         }\n202: \n203:         if (selector == e721_safe_transfer_from_1_selector) {\n204:             // Load the token ID from calldata.\n205:             uint256 tokenId = uint256(\n206:                 _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset)\n207:             );\n208: \n209:             // Check if the selector is allowed.\n210:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n211:         } else if (selector == e721_safe_transfer_from_2_selector) {\n212:             // Load the token ID from calldata.\n213:             uint256 tokenId = uint256(\n214:                 _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset)\n215:             );\n216: \n217:             // Check if the selector is allowed.\n218:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n219:         } else if (selector == e721_transfer_from_selector) {\n220:             // Load the token ID from calldata.\n221:             uint256 tokenId = uint256(\n222:                 _loadValueFromCalldata(data, e721_transfer_from_token_id_offset)\n223:             );\n224: \n225:             // Check if the selector is allowed.\n226:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n227:         } else if (selector == e721_approve_selector) {\n228:             // Load the token ID from calldata.\n229:             uint256 tokenId = uint256(\n230:                 _loadValueFromCalldata(data, e721_approve_token_id_offset)\n231:             );\n232: \n233:             // Check if the selector is allowed.\n234:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n235:         } else if (selector == e1155_safe_transfer_from_selector) {\n236:             // Load the token ID from calldata.\n237:             uint256 tokenId = uint256(\n238:                 _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n239:             );\n240: \n241:             // Check if the selector is allowed.\n242:             _revertSelectorOnActiveRental(selector, from, to, tokenId);\n243:         } else if (selector == gnosis_safe_enable_module_selector) {\n244:             // Load the extension address from calldata.\n245:             address extension = address(\n246:                 uint160(\n247:                     uint256(\n248:                         _loadValueFromCalldata(data, gnosis_safe_enable_module_offset)\n249:                     )\n250:                 )\n251:             );\n252: \n253:             // Check if the extension is whitelisted.\n254:             _revertNonWhitelistedExtension(extension);\n255:         } else if (selector == gnosis_safe_disable_module_selector) {\n256:             // Load the extension address from calldata.\n257:             address extension = address(\n258:                 uint160(\n259:                     uint256(\n260:                         _loadValueFromCalldata(data, gnosis_safe_disable_module_offset)\n261:                     )\n262:                 )\n263:             );\n264: \n265:             // Check if the extension is whitelisted.\n266:             _revertNonWhitelistedExtension(extension);\n267:         } else {\n268:             // Revert if the `setApprovalForAll` selector is specified. This selector is\n269:             // shared between ERC721 and ERC1155 tokens.\n270:             if (selector == shared_set_approval_for_all_selector) {\n271:                 revert Errors.GuardPolicy_UnauthorizedSelector(\n272:                     shared_set_approval_for_all_selector\n273:                 );\n274:             }\n275: \n276:             // Revert if the `safeBatchTransferFrom` selector is specified. There's no\n277:             // cheap way to check if individual items in the batch are rented out.\n278:             // Each token ID would require a call to the storage contract to check\n279:             // its rental status.\n280:             if (selector == e1155_safe_batch_transfer_from_selector) {\n281:                 revert Errors.GuardPolicy_UnauthorizedSelector(\n282:                     e1155_safe_batch_transfer_from_selector\n283:                 );\n284:             }\n285: \n286:             // Revert if the `setGuard` selector is specified.\n287:             if (selector == gnosis_safe_set_guard_selector) {\n288:                 revert Errors.GuardPolicy_UnauthorizedSelector(\n289:                     gnosis_safe_set_guard_selector\n290:                 );\n291:             }\n292:         }\n293:     }\n294: \n295:     /////////////////////////////////////////////////////////////////////////////////\n296:     //                            External Functions                               //\n297:     /////////////////////////////////////////////////////////////////////////////////\n298: \n299:     /** @notice Checks a transaction initiated by a rental safe to decide whether\n300:      *          it can be allowed or not. During this check, execution control flow\n301:      *          will be passed to an external hook contract if one exists for the\n302:      *          target contract.\n303:      *\n304:      * @param to             Destination address of Safe transaction.\n305:      * @param value          Ether value of Safe transaction.\n306:      * @param data           Data payload of Safe transaction.\n307:      * @param operation      Operation type of Safe transaction.\n308:      */\n309:     function checkTransaction(\n310:         address to,\n311:         uint256 value,\n312:         bytes memory data,\n313:         Enum.Operation operation,\n314:         uint256,\n315:         uint256,\n316:         uint256,\n317:         address,\n318:         address payable,\n319:         bytes memory,\n320:         address\n321:     ) external override {\n322:         // Disallow transactions that use delegate call, unless explicitly\n323:         // permitted by the protocol.\n324:         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n325:             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n326:         }\n327: \n328:         // Require that a function selector exists.\n329:         if (data.length < 4) {\n330:             revert Errors.GuardPolicy_FunctionSelectorRequired();\n331:         }\n332: \n333:         // Fetch the hook to interact with for this transaction.\n334:         address hook = STORE.contractToHook(to);\n335:         bool isActive = STORE.hookOnTransaction(hook);\n336: \n337:         // If a hook exists and is enabled, forward the control flow to the hook.\n338:         if (hook != address(0) && isActive) {\n339:             _forwardToHook(hook, msg.sender, to, value, data);\n340:         }\n341:         // If no hook exists, use basic tx check.\n342:         else {\n343:             _checkTransaction(msg.sender, to, data);\n344:         }\n345:     }\n346: \n347:     /**\n348:      * @notice Performs any checks after execution. This is left unimplemented.\n349:      *\n350:      * @param txHash Hash of the transaction.\n351:      * @param success Whether the transaction succeeded.\n352:      */\n353:     function checkAfterExecution(bytes32 txHash, bool success) external override {}\n354: \n355:     /**\n356:      * @notice Connects a target contract to a hook.\n357:      *\n358:      * @param to   The destination contract of a call.\n359:      * @param hook The hook middleware contract to sit between the call\n360:      *             and the destination.\n361:      */\n362:     function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") {\n363:         STORE.updateHookPath(to, hook);\n364:     }\n365: \n366:     /**\n367:      * @notice Toggle the status of a hook contract, which defines the functionality\n368:      *         that the hook supports.\n369:      *\n370:      * @param hook The hook contract address.\n371:      * @param bitmap Bitmap of the status.\n372:      */\n373:     function updateHookStatus(\n374:         address hook,\n375:         uint8 bitmap\n376:     ) external onlyRole(\"GUARD_ADMIN\") {\n377:         STORE.updateHookStatus(hook, bitmap);\n378:     }\n379: }\n380: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L1-L1)"
          ]
        },
        {
          "content": "```solidity\n1: // SPDX-License-Identifier: BUSL-1.1\n2: pragma solidity ^0.8.20;\n3: \n4: import {\n5:     toRole,\n6:     ensureContract,\n7:     ensureValidKeycode,\n8:     ensureValidRole\n9: } from \"@src/libraries/KernelUtils.sol\";\n10: import {Actions, Keycode, Role, Permissions} from \"@src/libraries/RentalStructs.sol\";\n11: import {Errors} from \"@src/libraries/Errors.sol\";\n12: import {Events} from \"src/libraries/Events.sol\";\n13: \n14: /////////////////////////////////////////////////////////////////////////////////\n15: //                         Module Abstract Contracts                           //\n16: /////////////////////////////////////////////////////////////////////////////////\n17: \n18: /**\n19:  * @title KernelAdapter\n20:  * @notice A base contract to be inherited by both policies and modules. Provides common\n21:  *         access to logic related to the kernel contract.\n22:  */\n23: abstract contract KernelAdapter {\n24:     // The active kernel contract.\n25:     Kernel public kernel;\n26: \n27:     /**\n28:      * @dev Instantiate this contract as a a kernel adapter. When using a proxy, the kernel address\n29:      *      should be set to address(0).\n30:      *\n31:      * @param kernel_ Address of the kernel contract.\n32:      */\n33:     constructor(Kernel kernel_) {\n34:         kernel = kernel_;\n35:     }\n36: \n37:     /**\n38:      * @dev Modifier which only allows calls from the active kernel contract.\n39:      */\n40:     modifier onlyKernel() {\n41:         if (msg.sender != address(kernel))\n42:             revert Errors.KernelAdapter_OnlyKernel(msg.sender);\n43:         _;\n44:     }\n45: \n46:     /**\n47:      * @notice Points the adapter to reference a new kernel address. This function can\n48:      *         only be called by the active kernel, and is used to perform migrations by\n49:      *         telling all policies and modules where the new kernel is located before\n50:      *         actually performing the migration.\n51:      *\n52:      * @param newKernel_  Address of the new kernel contract.\n53:      */\n54:     function changeKernel(Kernel newKernel_) external onlyKernel {\n55:         kernel = newKernel_;\n56:     }\n57: }\n58: \n59: /**\n60:  * @title Module\n61:  * @notice A base contract to be inherited by all module implementations. Provides common\n62:  *         logic related to module functionality.\n63:  */\n64: abstract contract Module is KernelAdapter {\n65:     /**\n66:      * @dev Instantiate this contract as a a module. When using a proxy, the kernel address\n67:      *      should be set to address(0).\n68:      *\n69:      * @param kernel_ Address of the kernel contract.\n70:      */\n71:     constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n72: \n73:     /**\n74:      * @dev Modifier which only allows calls to the module if the policy contract making the\n75:      *      call has been given explicit permission by the kernel first.\n76:      */\n77:     modifier permissioned() {\n78:         if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig)) {\n79:             revert Errors.Module_PolicyNotAuthorized(msg.sender);\n80:         }\n81:         _;\n82:     }\n83: \n84:     /**\n85:      * @notice The 5-character keycode used to uniquely represent the module. This\n86:      *         must be implemented by the inheriting contract.\n87:      *\n88:      * @return Keycode represented by the module.\n89:      */\n90:     function KEYCODE() public pure virtual returns (Keycode);\n91: \n92:     /**\n93:      * @notice Specifies the version of the module being implemented. Minor version\n94:      *         changes retain the interface, and major version upgrades indicated\n95:      *         breaking changes to the interface.\n96:      *\n97:      * @return major Major version of the module.\n98:      * @return minor Minor version of the module.\n99:      */\n100:     function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n101: \n102:     /**\n103:      * @notice Initialization function for the module which is called when the module is\n104:      *         first installed or upgraded by the kernel. Can only be called by the kernel.\n105:      */\n106:     function INIT() external virtual onlyKernel {}\n107: }\n108: \n109: /**\n110:  * @title Policy\n111:  * @notice A base contract to be inherited by all policy implementations. Provides common\n112:  *         logic related to policy functionality.\n113:  */\n114: abstract contract Policy is KernelAdapter {\n115:     // Whether the policy is active or not.\n116:     bool public isActive;\n117: \n118:     /**\n119:      * @dev Instantiate this contract as a a policy. When using a proxy, the kernel address\n120:      *      should be set to address(0).\n121:      *\n122:      * @param kernel_ Address of the kernel contract.\n123:      */\n124:     constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n125: \n126:     /**\n127:      * @dev Modifier which only allows calls from addresses which have explicitly been\n128:      *      granted a role by the kernel.\n129:      */\n130:     modifier onlyRole(bytes32 role_) {\n131:         Role role = toRole(role_);\n132:         if (!kernel.hasRole(msg.sender, role)) {\n133:             revert Errors.Policy_OnlyRole(role);\n134:         }\n135:         _;\n136:     }\n137: \n138:     /**\n139:      * @notice When a policy is activated, it must respond with all of the module\n140:      *         keycodes that it depends on. The kernel stores these dependencies as a\n141:      *         mapping from module keycode to an array of policies that depend on it.\n142:      *         This is useful because when a module is upgraded, it can know exactly\n143:      *         the policies that depend upon it and call out to each policy to\n144:      *         reconfigure its dependencies to use the upgraded module contract address.\n145:      *\n146:      * @param dependencies Keycodes of all the modules that the policy depends on.\n147:      */\n148:     function configureDependencies()\n149:         external\n150:         virtual\n151:         onlyKernel\n152:         returns (Keycode[] memory dependencies)\n153:     {}\n154: \n155:     /**\n156:      * @notice When a policy is activated, it must respond with a series of\n157:      *         keycode <> function selector pairs which represent a request for the\n158:      *         policy to call a specific function selector at a specific module.\n159:      *         These requests are stored as a mapping in the kernel while the policy\n160:      *         is active, and the kernel will reject any call from a policy to a module\n161:      *         which has not first requested permission.\n162:      *\n163:      * @param requests Keycode <> function selector pairs which define the module access\n164:      *                 requested by a policy.\n165:      */\n166:     function requestPermissions()\n167:         external\n168:         view\n169:         virtual\n170:         onlyKernel\n171:         returns (Permissions[] memory requests)\n172:     {}\n173: \n174:     /**\n175:      * @dev Used by a policy to get the current address of a module\n176:      *      at a specific keycode.\n177:      *\n178:      * @param keycode_ Keycode used to get the address of the module.\n179:      */\n180:     function getModuleAddress(Keycode keycode_) internal view returns (address) {\n181:         address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n182:         if (moduleForKeycode == address(0))\n183:             revert Errors.Policy_ModuleDoesNotExist(keycode_);\n184:         return moduleForKeycode;\n185:     }\n186: \n187:     /**\n188:      * @notice Allows the kernel to grant or revoke the active status of the policy.\n189:      *\n190:      * @param activate_ Whether to activate or deactivate the policy.\n191:      */\n192:     function setActiveStatus(bool activate_) external onlyKernel {\n193:         isActive = activate_;\n194:     }\n195: }\n196: \n197: /////////////////////////////////////////////////////////////////////////////////\n198: //                               Kernel Contract                               //\n199: /////////////////////////////////////////////////////////////////////////////////\n200: \n201: /**\n202:  * @title Kernel\n203:  * @notice A registry contract that manages a set of policy and module contracts, as well\n204:  *         as the permissions to interact with those contracts.\n205:  */\n206: contract Kernel {\n207:     // Admin addresses.\n208:     address public executor;\n209:     address public admin;\n210: \n211:     // Module Management.\n212:     Keycode[] public allKeycodes;\n213:     mapping(Keycode => Module) public getModuleForKeycode; // get contract for module keycode.\n214:     mapping(Module => Keycode) public getKeycodeForModule; // get module keycode for contract.\n215: \n216:     // Module dependents data. Manages module dependencies for policies.\n217:     mapping(Keycode => Policy[]) public moduleDependents;\n218:     mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n219: \n220:     // Module <> Policy Permissions. Keycode -> Policy -> Function Selector -> Permission.\n221:     mapping(Keycode => mapping(Policy => mapping(bytes4 => bool)))\n222:         public modulePermissions; // for policy addr, check if they have permission to call the function in the module.\n223: \n224:     // List of all active policies.\n225:     Policy[] public activePolicies;\n226:     mapping(Policy => uint256) public getPolicyIndex;\n227: \n228:     // Policy roles data.\n229:     mapping(address => mapping(Role => bool)) public hasRole;\n230:     mapping(Role => bool) public isRole;\n231: \n232:     /////////////////////////////////////////////////////////////////////////////////\n233:     //                                Constructor                                  //\n234:     /////////////////////////////////////////////////////////////////////////////////\n235: \n236:     /**\n237:      * @dev Instantiate the kernel with executor and admin addresses.\n238:      *\n239:      * @param _executor Address in charge of handling kernel executions.\n240:      * @param _admin    Address in charge of granting and revoking roles.\n241:      */\n242:     constructor(address _executor, address _admin) {\n243:         executor = _executor;\n244:         admin = _admin;\n245:     }\n246: \n247:     /////////////////////////////////////////////////////////////////////////////////\n248:     //                                Modifiers                                    //\n249:     /////////////////////////////////////////////////////////////////////////////////\n250: \n251:     /**\n252:      * @dev Modifier which only allows calls by an executing address.\n253:      */\n254:     modifier onlyExecutor() {\n255:         if (msg.sender != executor) revert Errors.Kernel_OnlyExecutor(msg.sender);\n256:         _;\n257:     }\n258: \n259:     /**\n260:      * @dev modifier which only allows calls by an admin address.\n261:      */\n262:     modifier onlyAdmin() {\n263:         if (msg.sender != admin) revert Errors.Kernel_OnlyAdmin(msg.sender);\n264:         _;\n265:     }\n266: \n267:     /////////////////////////////////////////////////////////////////////////////////\n268:     //                            External Functions                               //\n269:     /////////////////////////////////////////////////////////////////////////////////\n270: \n271:     /**\n272:      * @dev Executes an action on a target address.\n273:      *\n274:      * @param action_ Action which will be performed.\n275:      * @param target_ Address upon which the action will operate.\n276:      */\n277:     function executeAction(Actions action_, address target_) external onlyExecutor {\n278:         if (action_ == Actions.InstallModule) {\n279:             ensureContract(target_);\n280:             ensureValidKeycode(Module(target_).KEYCODE());\n281:             _installModule(Module(target_));\n282:         } else if (action_ == Actions.UpgradeModule) {\n283:             ensureContract(target_);\n284:             ensureValidKeycode(Module(target_).KEYCODE());\n285:             _upgradeModule(Module(target_));\n286:         } else if (action_ == Actions.ActivatePolicy) {\n287:             ensureContract(target_);\n288:             _activatePolicy(Policy(target_));\n289:         } else if (action_ == Actions.DeactivatePolicy) {\n290:             ensureContract(target_);\n291:             _deactivatePolicy(Policy(target_));\n292:         } else if (action_ == Actions.MigrateKernel) {\n293:             ensureContract(target_);\n294:             _migrateKernel(Kernel(target_));\n295:         } else if (action_ == Actions.ChangeExecutor) {\n296:             executor = target_;\n297:         } else if (action_ == Actions.ChangeAdmin) {\n298:             admin = target_;\n299:         }\n300: \n301:         emit Events.ActionExecuted(action_, target_);\n302:     }\n303: \n304:     /**\n305:      * @dev Grants a role to the target address.\n306:      *\n307:      * @param role_ Role to grant to the target.\n308:      * @param addr_ Address that will receive the role.\n309:      */\n310:     function grantRole(Role role_, address addr_) public onlyAdmin {\n311:         // Check that the address does not already have the role.\n312:         if (hasRole[addr_][role_])\n313:             revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_);\n314: \n315:         // Ensure the role is properly formatted.\n316:         ensureValidRole(role_);\n317: \n318:         // Mark this role as having been granted.\n319:         if (!isRole[role_]) isRole[role_] = true;\n320: \n321:         // Grant the role to the target.\n322:         hasRole[addr_][role_] = true;\n323: \n324:         emit Events.RoleGranted(role_, addr_);\n325:     }\n326: \n327:     /**\n328:      * @dev Revokes a role from the target address.\n329:      *\n330:      * @param role_ Role to revoke from the target.\n331:      * @param addr_ Address that will have the role removed.\n332:      */\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin {\n334:         // Check if the role has been granted before.\n335:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_);\n336: \n337:         // Check if the target address currently has the role.\n338:         if (!hasRole[addr_][role_])\n339:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_);\n340: \n341:         // Revoke the role.\n342:         hasRole[addr_][role_] = false;\n343: \n344:         emit Events.RoleRevoked(role_, addr_);\n345:     }\n346: \n347:     /////////////////////////////////////////////////////////////////////////////////\n348:     //                            Internal Functions                               //\n349:     /////////////////////////////////////////////////////////////////////////////////\n350: \n351:     /**\n352:      * @dev Installs a new module into the kernel.\n353:      *\n354:      * @param newModule_ Address of the new module.\n355:      */\n356:     function _installModule(Module newModule_) internal {\n357:         // Fetch the module keycode.\n358:         Keycode keycode = newModule_.KEYCODE();\n359: \n360:         // Make sure the keycode isnt in use already.\n361:         if (address(getModuleForKeycode[keycode]) != address(0)) {\n362:             revert Errors.Kernel_ModuleAlreadyInstalled(keycode);\n363:         }\n364: \n365:         // Connect the keycode to the module address.\n366:         getModuleForKeycode[keycode] = newModule_;\n367: \n368:         // Connect the module address to the keycode.\n369:         getKeycodeForModule[newModule_] = keycode;\n370: \n371:         // Keep a running array of all module keycodes.\n372:         allKeycodes.push(keycode);\n373: \n374:         // Initialize the module contract.\n375:         newModule_.INIT();\n376:     }\n377: \n378:     /**\n379:      * @dev Upgrades a module by changing the address that the keycode points to.\n380:      *\n381:      * @param newModule_ Address of the new module.\n382:      */\n383:     function _upgradeModule(Module newModule_) internal {\n384:         // Get the keycode of the new module\n385:         Keycode keycode = newModule_.KEYCODE();\n386: \n387:         // Get the address of the old module\n388:         Module oldModule = getModuleForKeycode[keycode];\n389: \n390:         // Check that the old module contract exists, and that the old module\n391:         // address is not the same as the new module\n392:         if (address(oldModule) == address(0) || oldModule == newModule_) {\n393:             revert Errors.Kernel_InvalidModuleUpgrade(keycode);\n394:         }\n395: \n396:         // The old module no longer points to the keycode.\n397:         getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n398: \n399:         // The new module points to the keycode.\n400:         getKeycodeForModule[newModule_] = keycode;\n401: \n402:         // The keycode points to the new module.\n403:         getModuleForKeycode[keycode] = newModule_;\n404: \n405:         // Initialize the new module contract.\n406:         newModule_.INIT();\n407: \n408:         // Reconfigure policies so that all policies that depended on the old\n409:         // module will refetch the new module address from the kernel.\n410:         _reconfigurePolicies(keycode);\n411:     }\n412: \n413:     /**\n414:      * @dev Activates a new policy into the kernel.\n415:      *\n416:      * @param policy_ Address of the policy to activate.\n417:      */\n418:     function _activatePolicy(Policy policy_) internal {\n419:         // Ensure that the policy is not already active.\n420:         if (policy_.isActive())\n421:             revert Errors.Kernel_PolicyAlreadyApproved(address(policy_));\n422: \n423:         // Grant permissions for policy to access restricted module functions.\n424:         Permissions[] memory requests = policy_.requestPermissions();\n425:         _setPolicyPermissions(policy_, requests, true);\n426: \n427:         // Add policy to list of active policies.\n428:         activePolicies.push(policy_);\n429: \n430:         // Set the index of the policy in the array of active policies.\n431:         getPolicyIndex[policy_] = activePolicies.length - 1;\n432: \n433:         // Fetch module dependencies.\n434:         Keycode[] memory dependencies = policy_.configureDependencies();\n435:         uint256 depLength = dependencies.length;\n436: \n437:         // Loop through each keycode the policy depends on.\n438:         for (uint256 i; i < depLength; ++i) {\n439:             Keycode keycode = dependencies[i];\n440: \n441:             // Push the policy to the array of dependents for the keycode\n442:             moduleDependents[keycode].push(policy_);\n443: \n444:             // Set the index of the policy in the array of dependents.\n445:             getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n446:         }\n447: \n448:         // Set policy status to active.\n449:         policy_.setActiveStatus(true);\n450:     }\n451: \n452:     /**\n453:      * @dev Deactivates an active policy from the kernel\n454:      *\n455:      * @param policy_ Address of the policy to deactivate.\n456:      */\n457:     function _deactivatePolicy(Policy policy_) internal {\n458:         if (!policy_.isActive()) revert Errors.Kernel_PolicyNotApproved(address(policy_));\n459: \n460:         // Fetch originally granted permissions from the policy\n461:         // and then revoke them.\n462:         Permissions[] memory requests = policy_.requestPermissions();\n463:         _setPolicyPermissions(policy_, requests, false);\n464: \n465:         // Get the index of the policy in the active policies array.\n466:         uint256 idx = getPolicyIndex[policy_];\n467: \n468:         // Get the index of the last policy in the active policy array.\n469:         Policy lastPolicy = activePolicies[activePolicies.length - 1];\n470: \n471:         // Set the last policy at the index of the policy to deactivate.\n472:         activePolicies[idx] = lastPolicy;\n473: \n474:         // Pop the last policy from the array.\n475:         activePolicies.pop();\n476: \n477:         // Set the last policy's index to the index of the policy\n478:         // that was removed.\n479:         getPolicyIndex[lastPolicy] = idx;\n480: \n481:         // Delete the index of the policy being deactivated.\n482:         delete getPolicyIndex[policy_];\n483: \n484:         // Remove policy from array of dependents for each keycode\n485:         // that the policy depends upon.\n486:         _pruneFromDependents(policy_);\n487: \n488:         // Set policy status to inactive.\n489:         policy_.setActiveStatus(false);\n490:     }\n491: \n492:     /**\n493:      * @dev Migrates the kernel to a new contract.\n494:      *\n495:      *      WARNING: THIS ACTION WILL BRICK THIS KERNEL.\n496:      *\n497:      *      By performing a migration, this kernel will no longer have any authority\n498:      *      over the current policies and modules.\n499:      *\n500:      *      All functionality will move to the new kernel. The new kernel will need\n501:      *      to add all of the modules and policies again via `executeAction`. Until\n502:      *      all policies and modules are re-activated on the new kernel, policies will\n503:      *      not be able to access permissioned functions on modules, and privileged\n504:      *      addresses will not be able to access role-gated functions on policies.\n505:      *\n506:      * @param newKernel_ Address of the new kernel.\n507:      */\n508:     function _migrateKernel(Kernel newKernel_) internal {\n509:         uint256 keycodeLen = allKeycodes.length;\n510: \n511:         // For each keycode stored in the kernel.\n512:         for (uint256 i; i < keycodeLen; ++i) {\n513:             // get the module represented by the keycode.\n514:             Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n515:             // Instruct the module to change the kernel.\n516:             module.changeKernel(newKernel_);\n517:         }\n518: \n519:         // For each active policy stored in the kernel\n520:         uint256 policiesLen = activePolicies.length;\n521:         for (uint256 j; j < policiesLen; ++j) {\n522:             // Get the policy.\n523:             Policy policy = activePolicies[j];\n524: \n525:             // Deactivate the policy before changing kernel.\n526:             policy.setActiveStatus(false);\n527: \n528:             // Instruct the policy to change the kernel.\n529:             policy.changeKernel(newKernel_);\n530:         }\n531:     }\n532: \n533:     /**\n534:      * @dev All policies that are dependent on the module represented by the keycode\n535:      *      must be reconfigured so that the policies can request the current\n536:      *      address of the module from the kernel.\n537:      *\n538:      * @param keycode_ Keycode representing the module.\n539:      */\n540:     function _reconfigurePolicies(Keycode keycode_) internal {\n541:         // Get an array of all policies that depend on the keycode.\n542:         Policy[] memory dependents = moduleDependents[keycode_];\n543:         uint256 depLength = dependents.length;\n544: \n545:         // Loop through each policy.\n546:         for (uint256 i; i < depLength; ++i) {\n547:             // Reconfigure its dependencies.\n548:             dependents[i].configureDependencies();\n549:         }\n550:     }\n551: \n552:     /**\n553:      * @dev Sets the permissions for a policy to interact with a module. Once the policy has\n554:      *      been activated, these permissions do not change until the policy is deactivated.\n555:      *\n556:      * @param policy_   Address of the policy.\n557:      * @param requests_ Permission requests comprised of keycode and function selector pairs.\n558:      * @param grant_    Whether to grant these permissions or revoke them.\n559:      */\n560:     function _setPolicyPermissions(\n561:         Policy policy_,\n562:         Permissions[] memory requests_,\n563:         bool grant_\n564:     ) internal {\n565:         uint256 reqLength = requests_.length;\n566:         for (uint256 i = 0; i < reqLength; ++i) {\n567:             // Set the permission for the keycode -> policy -> function selector.\n568:             Permissions memory request = requests_[i];\n569:             modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n570: \n571:             emit Events.PermissionsUpdated(\n572:                 request.keycode,\n573:                 policy_,\n574:                 request.funcSelector,\n575:                 grant_\n576:             );\n577:         }\n578:     }\n579: \n580:     /**\n581:      * @dev All keycodes store an array of the policies that depend upon them,\n582:      *      so a policy must be pruned from this array when it is deactivated.\n583:      *\n584:      * @param policy_ Address of the policy to prune from the dependency array.\n585:      */\n586:     function _pruneFromDependents(Policy policy_) internal {\n587:         // Retrieve all keycodes that the policy is dependent upon.\n588:         Keycode[] memory dependencies = policy_.configureDependencies();\n589:         uint256 depcLength = dependencies.length;\n590: \n591:         // Loop through each keycode.\n592:         for (uint256 i; i < depcLength; ++i) {\n593:             // Get the stored array of policies that depend on the keycode.\n594:             Keycode keycode = dependencies[i];\n595:             Policy[] storage dependents = moduleDependents[keycode];\n596: \n597:             // Get the index of the policy to prune in the array.\n598:             uint256 origIndex = getDependentIndex[keycode][policy_];\n599: \n600:             // Get the address of the last policy in the array.\n601:             Policy lastPolicy = dependents[dependents.length - 1];\n602: \n603:             // Overwrite the last policy with the policy being pruned.\n604:             dependents[origIndex] = lastPolicy;\n605: \n606:             // Since the last policy exists twice now in the array, pop it\n607:             // from the end of the array.\n608:             dependents.pop();\n609: \n610:             // Set the index of the swapped policy to its correct spot.\n611:             getDependentIndex[keycode][lastPolicy] = origIndex;\n612: \n613:             // Delete the index of the of the pruned policy.\n614:             delete getDependentIndex[keycode][policy_];\n615:         }\n616:     }\n617: }\n618: \n\n```\n",
          "loc": [
            "[1](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L1-L1)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Contracts should have full test coverage",
      "description": "Attaining 100% code coverage is not an assurance of a bug-free codebase, but it significantly improves the likelihood of identifying simple bugs and aids in maintaining a stable codebase by preventing regressions during code modifications. Additionally, to achieve complete coverage, code writers usually have to structure their code more modularly, which implies testing each component independently. This reduces the complex interdependencies between modules and layers, creating a more understandable and auditable codebase. Consequently, this practice aids in enhancing code maintainability and reduces the risk of introducing bugs during future changes.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23: contract PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n14: contract StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n15: contract Admin is Policy  // <= FOUND\n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n22: contract Factory is Policy  // <= FOUND\n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard  // <= FOUND\n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        },
        {
          "content": "```solidity\n14: contract Create2Deployer  // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n206: contract Kernel  // <= FOUND\n\n```\n",
          "loc": [
            "[206](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L206-L206)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using named function calls",
      "description": "Named function calls in Solidity greatly improve code readability by explicitly mapping arguments to their respective parameter names. This clarity becomes critical when dealing with functions that have numerous or complex parameters, reducing potential errors due to misordered arguments. Therefore, adopting named function calls contributes to more maintainable and less error-prone code.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n175: \n176:         \n177:         _safeTransfer(token, lender, lenderAmount); // <= FOUND\n\n```\n",
          "loc": [
            "[175](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L175-L177)"
          ]
        },
        {
          "content": "```solidity\n178: \n179:         \n180:         _safeTransfer(token, renter, renterAmount); // <= FOUND\n\n```\n",
          "loc": [
            "[178](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L178-L180)"
          ]
        },
        {
          "content": "```solidity\n201: \n202:         \n203:         _safeTransfer(token, settleToAddress, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[201](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L201-L203)"
          ]
        },
        {
          "content": "```solidity\n408: \n409:         \n410:         _safeTransfer(token, to, skimmedBalance); // <= FOUND\n\n```\n",
          "loc": [
            "[408](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L408-L410)"
          ]
        },
        {
          "content": "```solidity\n168:         \n169:         (uint256 renterAmount, uint256 lenderAmount) = _calculatePaymentProRata( // <= FOUND\n170:             amount, // <= FOUND\n171:             elapsedTime, // <= FOUND\n172:             totalTime\n173:         );\n\n```\n",
          "loc": [
            "[168](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L168-L171)"
          ]
        },
        {
          "content": "```solidity\n371: \n372:         \n373:         _increaseDeposit(token, amount); // <= FOUND\n\n```\n",
          "loc": [
            "[371](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L371-L373)"
          ]
        },
        {
          "content": "```solidity\n760: \n761:         \n762:         address signer = _recoverSignerFromPayload( // <= FOUND\n763:             _deriveRentPayloadHash(payload), // <= FOUND\n764:             signature\n765:         );\n\n```\n",
          "loc": [
            "[760](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L760-L763)"
          ]
        },
        {
          "content": "```solidity\n322: \n323:         \n324:         domainSeparator = _deriveDomainSeparator( // <= FOUND\n325:             eip712DomainTypehash, // <= FOUND\n326:             nameHash, // <= FOUND\n327:             versionHash\n328:         );\n\n```\n",
          "loc": [
            "[322](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L322-L326)"
          ]
        },
        {
          "content": "```solidity\n46:         \n47:         (\n48:             _NAME_HASH, // <= FOUND\n49:             _VERSION_HASH, // <= FOUND\n50:             _EIP_712_DOMAIN_TYPEHASH, // <= FOUND\n51:             _DOMAIN_SEPARATOR\n52:         ) = _deriveTypehashes(); // <= FOUND\n\n```\n",
          "loc": [
            "[46](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L46-L52)"
          ]
        },
        {
          "content": "```solidity\n54: \n55:         \n56:         (\n57:             _ITEM_TYPEHASH, // <= FOUND\n58:             _HOOK_TYPEHASH, // <= FOUND\n59:             _RENTAL_ORDER_TYPEHASH, // <= FOUND\n60:             _ORDER_FULFILLMENT_TYPEHASH, // <= FOUND\n61:             _ORDER_METADATA_TYPEHASH, // <= FOUND\n62:             _RENT_PAYLOAD_TYPEHASH\n63:         ) = _deriveRentalTypehashes(); // <= FOUND\n\n```\n",
          "loc": [
            "[54](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L54-L63)"
          ]
        },
        {
          "content": "```solidity\n422:             \n423:             _processBaseOrderOffer(items, offers, 0); // <= FOUND\n\n```\n",
          "loc": [
            "[422](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L422-L423)"
          ]
        },
        {
          "content": "```solidity\n430:             \n431:             _processPayOrderOffer(items, offers, 0); // <= FOUND\n\n```\n",
          "loc": [
            "[430](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L430-L431)"
          ]
        },
        {
          "content": "```solidity\n771: \n772:         \n773:         _rentFromZone(payload, seaportPayload); // <= FOUND\n\n```\n",
          "loc": [
            "[771](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L771-L773)"
          ]
        },
        {
          "content": "```solidity\n700:                 _checkExpectedRecipient(execution, address(ESCRW)); // <= FOUND\n\n```\n",
          "loc": [
            "[700](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L700-L700)"
          ]
        },
        {
          "content": "```solidity\n705:                 _checkExpectedRecipient(execution, expectedRentalSafe); // <= FOUND\n\n```\n",
          "loc": [
            "[705](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L705-L705)"
          ]
        },
        {
          "content": "```solidity\n205:             \n206:             uint256 tokenId = uint256(\n207:                 _loadValueFromCalldata(data, e721_safe_transfer_from_1_token_id_offset) // <= FOUND\n208:             );\n\n```\n",
          "loc": [
            "[205](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L205-L207)"
          ]
        },
        {
          "content": "```solidity\n213:             \n214:             uint256 tokenId = uint256(\n215:                 _loadValueFromCalldata(data, e721_safe_transfer_from_2_token_id_offset) // <= FOUND\n216:             );\n\n```\n",
          "loc": [
            "[213](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L213-L215)"
          ]
        },
        {
          "content": "```solidity\n221:             \n222:             uint256 tokenId = uint256(\n223:                 _loadValueFromCalldata(data, e721_transfer_from_token_id_offset) // <= FOUND\n224:             );\n\n```\n",
          "loc": [
            "[221](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L221-L223)"
          ]
        },
        {
          "content": "```solidity\n229:             \n230:             uint256 tokenId = uint256(\n231:                 _loadValueFromCalldata(data, e721_approve_token_id_offset) // <= FOUND\n232:             );\n\n```\n",
          "loc": [
            "[229](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L229-L231)"
          ]
        },
        {
          "content": "```solidity\n237:             \n238:             uint256 tokenId = uint256(\n239:                 _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset) // <= FOUND\n240:             );\n\n```\n",
          "loc": [
            "[237](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L237-L239)"
          ]
        },
        {
          "content": "```solidity\n245:             \n246:             address extension = address(\n247:                 uint160(\n248:                     uint256(\n249:                         _loadValueFromCalldata(data, gnosis_safe_enable_module_offset) // <= FOUND\n250:                     )\n251:                 )\n252:             );\n\n```\n",
          "loc": [
            "[245](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L245-L249)"
          ]
        },
        {
          "content": "```solidity\n257:             \n258:             address extension = address(\n259:                 uint160(\n260:                     uint256(\n261:                         _loadValueFromCalldata(data, gnosis_safe_disable_module_offset) // <= FOUND\n262:                     )\n263:                 )\n264:             );\n\n```\n",
          "loc": [
            "[257](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L257-L261)"
          ]
        },
        {
          "content": "```solidity\n42: \n43:         \n44:         address targetDeploymentAddress = getCreate2Address(salt, initCode); // <= FOUND\n\n```\n",
          "loc": [
            "[42](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L42-L44)"
          ]
        },
        {
          "content": "```solidity\n425:         _setPolicyPermissions(policy_, requests, true); // <= FOUND\n\n```\n",
          "loc": [
            "[425](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L425-L425)"
          ]
        },
        {
          "content": "```solidity\n463:         _setPolicyPermissions(policy_, requests, false); // <= FOUND\n\n```\n",
          "loc": [
            "[463](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L463-L463)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Using XOR (^) and AND (&) bitwise equivalents",
      "description": "XOR (^) and AND (&) are bitwise operators that can be more efficient for specific operations in Solidity. XOR returns true if the bits being compared are different, and AND returns true if both bits are true. Using these operators can lead to more concise and efficient code for tasks such as toggling bits or checking specific bit conditions. By applying bitwise logic, you can reduce computational complexity and enhance code performance. Consider using XOR and AND where appropriate, understanding the specific requirements and ensuring that the use of these operators aligns with the intended logic of the application.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n100:     function _safeTransfer(address token, address to, uint256 value) internal { // <= FOUND\n101:         \n102:         (bool success, bytes memory data) = token.call(\n103:             abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n104:         );\n105: \n106:         \n107:         \n108:         \n109:         \n110:         \n111:         \n112:         \n113:         \n114:         \n115:         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n116:             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n117:         }\n118:     }\n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L100-L100)"
          ]
        },
        {
          "content": "```solidity\n215:     function _settlePayment(\n216:         Item[] calldata items,\n217:         OrderType orderType,\n218:         address lender,\n219:         address renter,\n220:         uint256 start,\n221:         uint256 end\n222:     ) internal {\n223:         \n224:         uint256 elapsedTime = block.timestamp - start;\n225:         uint256 totalTime = end - start;\n226: \n227:         \n228:         bool isRentalOver = elapsedTime >= totalTime;\n229: \n230:         \n231:         for (uint256 i = 0; i < items.length; ++i) {\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n281:             }\n282:         }\n283:     }\n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L215-L215)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Lack Of Brace Spacing",
      "description": "Lack of brace spacing in coding refers to the absence of spaces around braces, which can hinder code readability. In Solidity, as in many programming languages, spacing can enhance the visual distinction between different parts of the code, making it easier to follow. A lack of spacing can lead to a dense, confusing appearance. The resolution to this issue is to follow a consistent style guide that defines rules for brace spacing. By including spaces around braces, such as `{ statement }` instead of `{statement}`, developers can ensure that the code is more legible and maintainable, especially in larger codebases.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n4: \n5: import {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L4-L5)"
          ]
        },
        {
          "content": "```solidity\n4: \n5: import {Kernel, Module, Keycode} from \"@src/Kernel.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L4-L5)"
          ]
        },
        {
          "content": "```solidity\n5: import {Proxiable} from \"@src/proxy/Proxiable.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n4: import {Errors} from \"@src/libraries/Errors.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n13: import {Events} from \"@src/libraries/Events.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[13](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L13-L13)"
          ]
        },
        {
          "content": "```solidity\n6: import {RentalUtils} from \"@src/libraries/RentalUtils.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[6](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L6-L6)"
          ]
        },
        {
          "content": "```solidity\n7: import {RentalId, RentalAssetUpdate} from \"@src/libraries/RentalStructs.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L7-L7)"
          ]
        },
        {
          "content": "```solidity\n7: \n8: import {RentalId, RentalAssetUpdate} from \"@src/libraries/RentalStructs.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L7-L8)"
          ]
        },
        {
          "content": "```solidity\n4: \n5: import {IERC721} from \"@openzeppelin-contracts/token/ERC721/IERC721.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L4-L5)"
          ]
        },
        {
          "content": "```solidity\n5: import {IERC1155} from \"@openzeppelin-contracts/token/ERC1155/IERC1155.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n7: \n8: import {RentalOrder, Item, ItemType} from \"@src/libraries/RentalStructs.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[7](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L7-L8)"
          ]
        },
        {
          "content": "```solidity\n4: \n5: import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L4-L5)"
          ]
        },
        {
          "content": "```solidity\n10: \n11: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[10](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L10-L11)"
          ]
        },
        {
          "content": "```solidity\n11: import {toKeycode} from \"@src/libraries/KernelUtils.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[11](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L11-L11)"
          ]
        },
        {
          "content": "```solidity\n14: import {Storage} from \"@src/modules/Storage.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n19: import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[19](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L19-L19)"
          ]
        },
        {
          "content": "```solidity\n4: \n5: import {ZoneParameters} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L4-L5)"
          ]
        },
        {
          "content": "```solidity\n5: import {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n6: import {LibString} from \"@solady/utils/LibString.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[6](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L6-L6)"
          ]
        },
        {
          "content": "```solidity\n8: \n9: import {ISafe} from \"@src/interfaces/ISafe.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[8](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L8-L9)"
          ]
        },
        {
          "content": "```solidity\n9: import {IHook} from \"@src/interfaces/IHook.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[9](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L9-L9)"
          ]
        },
        {
          "content": "```solidity\n10: import {ZoneInterface} from \"@src/interfaces/IZone.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[10](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L10-L10)"
          ]
        },
        {
          "content": "```solidity\n13: import {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[13](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L13-L13)"
          ]
        },
        {
          "content": "```solidity\n15: import {Signer} from \"@src/packages/Signer.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n16: import {Zone} from \"@src/packages/Zone.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[16](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L16-L16)"
          ]
        },
        {
          "content": "```solidity\n17: import {Accumulator} from \"@src/packages/Accumulator.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[17](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L17-L17)"
          ]
        },
        {
          "content": "```solidity\n496: \n497:             \n498:             try\n499:                 IHook(target).onStart( // <= FOUND\n500:                     rentalWallet,\n501:                     offer.token, // <= FOUND\n502:                     offer.identifier, // <= FOUND\n503:                     offer.amount, // <= FOUND\n504:                     hooks[i].extraData // <= FOUND\n505:                 )\n506:             {} catch Error(string memory revertReason) { // <= FOUND\n\n```\n",
          "loc": [
            "[496](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L496-L506)"
          ]
        },
        {
          "content": "```solidity\n4: \n5: import {SafeL2} from \"@safe-contracts/SafeL2.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L4-L5)"
          ]
        },
        {
          "content": "```solidity\n5: import {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n6: import {TokenCallbackHandler} from \"@safe-contracts/handler/TokenCallbackHandler.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[6](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L6-L6)"
          ]
        },
        {
          "content": "```solidity\n15: import {Stop} from \"@src/policies/Stop.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n16: import {Guard} from \"@src/policies/Guard.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[16](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L16-L16)"
          ]
        },
        {
          "content": "```solidity\n4: \n5: import {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L4-L5)"
          ]
        },
        {
          "content": "```solidity\n4: import {Enum} from \"@safe-contracts/common/Enum.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n9: \n10: import {IHook} from \"@src/interfaces/IHook.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[9](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L9-L10)"
          ]
        },
        {
          "content": "```solidity\n10: import {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[10](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L10-L10)"
          ]
        },
        {
          "content": "```solidity\n167:         \n168:         try IHook(hook).onTransaction(safe, to, value, data) {} catch Error( // <= FOUND\n\n```\n",
          "loc": [
            "[167](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L167-L168)"
          ]
        },
        {
          "content": "```solidity\n4: \n5: import {Enum} from \"@safe-contracts/common/Enum.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L4-L5)"
          ]
        },
        {
          "content": "```solidity\n14: import {Reclaimer} from \"@src/packages/Reclaimer.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n226: \n227:             \n228:             try\n229:                 IHook(target).onStop( // <= FOUND\n230:                     rentalWallet,\n231:                     item.token, // <= FOUND\n232:                     item.identifier, // <= FOUND\n233:                     item.amount, // <= FOUND\n234:                     hooks[i].extraData // <= FOUND\n235:                 )\n236:             {} catch Error(string memory revertReason) { // <= FOUND\n\n```\n",
          "loc": [
            "[226](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L226-L236)"
          ]
        },
        {
          "content": "```solidity\n4: \n5: import {Errors} from \"@src/libraries/Errors.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L4-L5)"
          ]
        },
        {
          "content": "```solidity\n10: import {Actions, Keycode, Role, Permissions} from \"@src/libraries/RentalStructs.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[10](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L10-L10)"
          ]
        },
        {
          "content": "```solidity\n12: import {Events} from \"src/libraries/Events.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[12](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L12-L12)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Common functions should be refactored to a common base contract",
      "description": "In Solidity development, it's advisable to refactor common functions into a shared base contract to enhance code reusability and maintainability. This approach not only promotes clean and organized code but also saves on gas costs when deploying multiple contracts that utilize the same functions. By placing shared logic in a common base contract, it becomes easier to manage updates to those functions, reducing the likelihood of errors across multiple dependent contracts. The resolution is to identify the functions that are used across different contracts, encapsulate them in a base contract, and then inherit from that base contract wherever those functions are needed.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n86:     function MODULE_PROXY_INSTANTIATION(\n87:         Kernel kernel_\n88:     ) external onlyByProxy onlyUninitialized {\n89:         kernel = kernel_;\n90:         initialized = true;\n91:     }\n\n```\n",
          "loc": [
            ""
          ]
        },
        {
          "content": "```solidity\n96:     function VERSION() external pure override returns (uint8 major, uint8 minor) { // <= FOUND\n97:         return (1, 0);\n98:     }\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n360:     function upgrade(address newImplementation) external onlyByProxy permissioned { // <= FOUND\n361:         \n362:         _upgrade(newImplementation);\n363:     }\n\n```\n",
          "loc": [
            "[360](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L360-L360)"
          ]
        },
        {
          "content": "```solidity\n369:     function freeze() external onlyByProxy permissioned { // <= FOUND\n370:         \n371:         _freeze();\n372:     }\n\n```\n",
          "loc": [
            "[369](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L369-L369)"
          ]
        },
        {
          "content": "```solidity\n72:     function configureDependencies()\n73:         external\n74:         override\n75:         onlyKernel\n76:         returns (Keycode[] memory dependencies)\n77:     {\n78:         dependencies = new Keycode[](2);\n79: \n80:         dependencies[0] = toKeycode(\"STORE\");\n81:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n82: \n83:         dependencies[1] = toKeycode(\"ESCRW\");\n84:         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n85:     }\n\n```\n",
          "loc": [
            ""
          ]
        },
        {
          "content": "```solidity\n73:     function configureDependencies()\n74:         external\n75:         override\n76:         onlyKernel\n77:         returns (Keycode[] memory dependencies)\n78:     {\n79:         dependencies = new Keycode[](1);\n80: \n81:         dependencies[0] = toKeycode(\"STORE\");\n82:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n83:     }\n\n```\n",
          "loc": [
            ""
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use of override is unnecessary",
      "description": "Starting with Solidity version 0.8.8, the use of the `override` keyword is simplified. If a function solely overrides an interface function and does not exist in multiple base contracts, specifying `override` becomes unnecessary. This change streamlines the code and makes it less verbose. Removing unnecessary use of `override` in these situations can make the code cleaner and more maintainable, aligning with the newer Solidity guidelines. It's a good practice to adapt to this updated behavior to stay consistent with the language's evolution and current best practices.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n353:     function checkAfterExecution(bytes32 txHash, bool success) external override  // <= FOUND\n\n```\n",
          "loc": [
            "[353](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L353-L353)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "If statement control structures do not comply with best practices",
      "description": "If statements which include a single line do not need to have curly brackets, however according to the Solidiity style guide the line of code executed upon the if statement condition being met should still be on the next line, not on the same line as the if statement declaration.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n296:         \n297:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to); // <= FOUND\n\n```\n",
          "loc": [
            "[296](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L296-L297)"
          ]
        },
        {
          "content": "```solidity\n299: \n300:         \n301:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n\n```\n",
          "loc": [
            "[299](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L299-L301)"
          ]
        },
        {
          "content": "```solidity\n299:         \n300:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n\n```\n",
          "loc": [
            "[299](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L299-L300)"
          ]
        },
        {
          "content": "```solidity\n321: \n322:         \n323:         if (bitmap > uint8(7)) // <= FOUND\n324:             revert Errors.StorageModule_InvalidHookStatusBitmap(bitmap); // <= FOUND\n\n```\n",
          "loc": [
            "[321](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L321-L324)"
          ]
        },
        {
          "content": "```solidity\n94: \n95:             \n96:             if (item.itemType == ItemType.ERC721) // <= FOUND\n97:                 _transferERC721(item, rentalOrder.lender); // <= FOUND\n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L94-L97)"
          ]
        },
        {
          "content": "```solidity\n98: \n99:             \n100:             if (item.itemType == ItemType.ERC1155) // <= FOUND\n101:                 _transferERC1155(item, rentalOrder.lender); // <= FOUND\n\n```\n",
          "loc": [
            "[98](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L98-L101)"
          ]
        },
        {
          "content": "```solidity\n41:         if (msg.sender != address(kernel)) // <= FOUND\n42:             revert Errors.KernelAdapter_OnlyKernel(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L41-L42)"
          ]
        },
        {
          "content": "```solidity\n182:         if (moduleForKeycode == address(0)) // <= FOUND\n183:             revert Errors.Policy_ModuleDoesNotExist(keycode_); // <= FOUND\n\n```\n",
          "loc": [
            "[182](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L182-L183)"
          ]
        },
        {
          "content": "```solidity\n255:         if (msg.sender != executor) revert Errors.Kernel_OnlyExecutor(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[255](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L255-L255)"
          ]
        },
        {
          "content": "```solidity\n263:         if (msg.sender != admin) revert Errors.Kernel_OnlyAdmin(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[263](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L263-L263)"
          ]
        },
        {
          "content": "```solidity\n312:         \n313:         if (hasRole[addr_][role_]) // <= FOUND\n314:             revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_); // <= FOUND\n\n```\n",
          "loc": [
            "[312](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L312-L314)"
          ]
        },
        {
          "content": "```solidity\n319: \n320:         \n321:         if (!isRole[role_]) isRole[role_] = true; // <= FOUND\n\n```\n",
          "loc": [
            "[319](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L319-L321)"
          ]
        },
        {
          "content": "```solidity\n335:         \n336:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_); // <= FOUND\n\n```\n",
          "loc": [
            "[335](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L335-L336)"
          ]
        },
        {
          "content": "```solidity\n338: \n339:         \n340:         if (!hasRole[addr_][role_]) // <= FOUND\n341:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_); // <= FOUND\n\n```\n",
          "loc": [
            "[338](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L338-L341)"
          ]
        },
        {
          "content": "```solidity\n420:         \n421:         if (policy_.isActive()) // <= FOUND\n422:             revert Errors.Kernel_PolicyAlreadyApproved(address(policy_)); // <= FOUND\n\n```\n",
          "loc": [
            "[420](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L420-L422)"
          ]
        },
        {
          "content": "```solidity\n458:         if (!policy_.isActive()) revert Errors.Kernel_PolicyNotApproved(address(policy_)); // <= FOUND\n\n```\n",
          "loc": [
            "[458](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L458-L458)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider adding formal verification proofs",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23: contract PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n14: contract StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n15: contract Admin is Policy  // <= FOUND\n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n22: contract Factory is Policy  // <= FOUND\n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard  // <= FOUND\n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        },
        {
          "content": "```solidity\n14: contract Create2Deployer  // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n206: contract Kernel  // <= FOUND\n\n```\n",
          "loc": [
            "[206](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L206-L206)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use string.concat() on strings instead of abi.encodePacked() for clearer semantic meaning",
      "description": "From Solidity 0.8.12 onwards, developers can utilize `string.concat()` to concatenate strings without additional padding. Opting for `string.concat()` over `abi.encodePacked()` offers clearer semantic interpretation of the code's intent, enhancing readability. This shift minimizes ambiguity, reducing the potential for misinterpretation by reviewers or future developers. Thus, for string concatenation tasks, it's recommended to transition to `string.concat()` for transparent, straightforward code that communicates its purpose distinctly.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) {\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) {\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)),\n187:                     keccak256(abi.encodePacked(hookHashes)),\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[162](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n218:     function _deriveOrderMetadataHash(\n219:         OrderMetadata memory metadata\n220:     ) internal view returns (bytes32) {\n221:         \n222:         bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n223: \n224:         \n225:         for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n226:             \n227:             hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n228:         }\n229: \n230:         \n231:         return\n232:             keccak256(\n233:                 abi.encode(\n234:                     _ORDER_METADATA_TYPEHASH,\n235:                     metadata.rentDuration,\n236:                     keccak256(abi.encodePacked(hookHashes))\n237:                 )\n238:             );\n239:     }\n\n```\n",
          "loc": [
            "[218](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L218-L218)"
          ]
        },
        {
          "content": "```solidity\n298:     function _deriveTypehashes()\n299:         internal\n300:         view\n301:         returns (\n302:             bytes32 nameHash,\n303:             bytes32 versionHash,\n304:             bytes32 eip712DomainTypehash,\n305:             bytes32 domainSeparator\n306:         )\n307:     {\n308:         \n309:         nameHash = keccak256(bytes(_NAME));\n310: \n311:         \n312:         versionHash = keccak256(bytes(_VERSION));\n313: \n314:         \n315:         eip712DomainTypehash = keccak256(\n316:             abi.encodePacked(\n317:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n318:             )\n319:         );\n320: \n321:         \n322:         domainSeparator = _deriveDomainSeparator(\n323:             eip712DomainTypehash,\n324:             nameHash,\n325:             versionHash\n326:         );\n327:     }\n\n```\n",
          "loc": [
            "[298](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L298-L298)"
          ]
        },
        {
          "content": "```solidity\n339:     function _deriveRentalTypehashes()\n340:         internal\n341:         pure\n342:         returns (\n343:             bytes32 itemTypeHash,\n344:             bytes32 hookTypeHash,\n345:             bytes32 rentalOrderTypeHash,\n346:             bytes32 orderFulfillmentTypeHash,\n347:             bytes32 orderMetadataTypeHash,\n348:             bytes32 rentPayloadTypeHash\n349:         )\n350:     {\n351:         \n352:         bytes memory itemTypeString = abi.encodePacked(\n353:             \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n354:         );\n355: \n356:         \n357:         bytes memory hookTypeString = abi.encodePacked(\n358:             \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n359:         );\n360: \n361:         \n362:         bytes memory rentalOrderTypeString = abi.encodePacked(\n363:             \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n364:         );\n365: \n366:         \n367:         itemTypeHash = keccak256(itemTypeString);\n368: \n369:         \n370:         hookTypeHash = keccak256(hookTypeString);\n371: \n372:         \n373:         rentalOrderTypeHash = keccak256(\n374:             abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n375:         );\n376: \n377:         {\n378:             \n379:             bytes memory orderFulfillmentTypeString = abi.encodePacked(\n380:                 \"OrderFulfillment(address recipient)\"\n381:             );\n382: \n383:             \n384:             bytes memory orderMetadataTypeString = abi.encodePacked(\n385:                 \"OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\"\n386:             );\n387: \n388:             \n389:             bytes memory rentPayloadTypeString = abi.encodePacked(\n390:                 \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\"\n391:             );\n392: \n393:             \n394:             rentPayloadTypeHash = keccak256(\n395:                 abi.encodePacked(\n396:                     rentPayloadTypeString,\n397:                     orderMetadataTypeString,\n398:                     orderFulfillmentTypeString\n399:                 )\n400:             );\n401: \n402:             \n403:             orderFulfillmentTypeHash = keccak256(orderFulfillmentTypeString);\n404: \n405:             \n406:             orderMetadataTypeHash = keccak256(orderMetadataTypeString);\n407:         }\n408:     }\n\n```\n",
          "loc": [
            "[339](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L339-L339)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "function names should be lowerCamelCase",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n86:     function MODULE_PROXY_INSTANTIATION(\n87:         Kernel kernel_\n88:     ) external onlyByProxy onlyUninitialized \n\n```\n",
          "loc": [
            "[86](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L86-L86)"
          ]
        },
        {
          "content": "```solidity\n96:     function VERSION() external pure override returns (uint8 major, uint8 minor) \n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n103:     function KEYCODE() public pure override returns (Keycode) \n\n```\n",
          "loc": [
            "[103](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n100:     function VERSION() external pure virtual returns (uint8 major, uint8 minor) \n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L100-L100)"
          ]
        },
        {
          "content": "```solidity\n106:     function INIT() external virtual onlyKernel \n\n```\n",
          "loc": [
            "[106](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L106-L106)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider bounding input array length",
      "description": "Unbounded array inputs in functions can lead to unintentional excessive gas consumption, potentially causing a transaction to revert after expending substantial gas. To enhance user experience and prevent such scenarios, consider implementing a `require()` statement that limits the array length to a defined maximum. This constraint ensures that transactions won't proceed if they're likely to hit gas limits due to array size, saving users from unnecessary gas costs and offering a more predictable interaction with the contract.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n231:        for (uint256 i = 0; i < items.length; ++i) { // <= FOUND\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n\n```\n",
          "loc": [
            "[231](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L231-L231)"
          ]
        },
        {
          "content": "```solidity\n341:        for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n342:             \n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L341-L341)"
          ]
        },
        {
          "content": "```solidity\n197:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) { // <= FOUND\n198:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n199: \n200:             \n201:             rentedAssets[asset.rentalId] += asset.amount;\n202:         }\n\n```\n",
          "loc": [
            "[197](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n249:        for (uint256 i = 0; i < orderHashes.length; ++i) { // <= FOUND\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n\n```\n",
          "loc": [
            "[249](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L249-L249)"
          ]
        },
        {
          "content": "```solidity\n170:        for (uint256 i = 0; i < order.items.length; ++i) { // <= FOUND\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n\n```\n",
          "loc": [
            "[170](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L170-L170)"
          ]
        },
        {
          "content": "```solidity\n225:        for (uint256 i = 0; i < metadata.hooks.length; ++i) { // <= FOUND\n226:             \n227:             hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n228:         }\n\n```\n",
          "loc": [
            "[225](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L225-L225)"
          ]
        },
        {
          "content": "```solidity\n261:        for (uint256 i; i < offers.length; ++i) { // <= FOUND\n262:             \n263:             SpentItem memory offer = offers[i];\n264: \n265:             \n266:             if (offer.isERC721()) {\n267:                 \n268:                 \n269:                 itemType = ItemType.ERC721;\n270:                 settleTo = SettleTo.LENDER;\n271: \n272:                 \n273:                 totalRentals++;\n274:             }\n275:             \n276:             else if (offer.isERC1155()) {\n277:                 \n278:                 \n279:                 itemType = ItemType.ERC1155;\n280:                 settleTo = SettleTo.LENDER;\n281: \n282:                 \n283:                 totalRentals++;\n284:             }\n285:             \n286:             else if (offer.isERC20()) {\n287:                 \n288:                 \n289:                 itemType = ItemType.ERC20;\n290:                 settleTo = SettleTo.RENTER;\n291: \n292:                 \n293:                 totalPayments++;\n294:             }\n295:             \n296:             else {\n297:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n298:             }\n299: \n300:             \n301:             rentalItems[i + startIndex] = Item({\n302:                 itemType: itemType,\n303:                 settleTo: settleTo,\n304:                 token: offer.token,\n305:                 amount: offer.amount,\n306:                 identifier: offer.identifier\n307:             });\n308:         }\n\n```\n",
          "loc": [
            "[261](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L261-L261)"
          ]
        },
        {
          "content": "```solidity\n375:        for (uint256 i; i < considerations.length; ++i) { // <= FOUND\n376:             \n377:             ReceivedItem memory consideration = considerations[i];\n378: \n379:             \n380:             if (consideration.isERC20()) {\n381:                 totalPayments++;\n382:             }\n383:             \n384:             else if (consideration.isRental()) {\n385:                 totalRentals++;\n386:             }\n387:             \n388:             else {\n389:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n390:                     consideration.itemType\n391:                 );\n392:             }\n393:         }\n\n```\n",
          "loc": [
            "[375](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L375-L375)"
          ]
        },
        {
          "content": "```solidity\n475:        for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n476:             \n477:             target = hooks[i].target;\n478: \n479:             \n480:             if (!STORE.hookOnStart(target)) {\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             \n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             \n488:             offer = offerItems[itemIndex];\n489: \n490:             \n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             \n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 \n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) {\n508:                 \n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 \n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n514:                 );\n515:             } catch (bytes memory revertData) {\n516:                 \n517:                 revert Errors.Shared_HookFailBytes(revertData);\n518:             }\n519:         }\n\n```\n",
          "loc": [
            "[475](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L475-L475)"
          ]
        },
        {
          "content": "```solidity\n695:        for (uint256 i = 0; i < executions.length; ++i) { // <= FOUND\n696:             ReceivedItem memory execution = executions[i];\n697: \n698:             \n699:             if (execution.isERC20()) {\n700:                 _checkExpectedRecipient(execution, address(ESCRW));\n701:             }\n702:             \n703:             \n704:             else if (execution.isRental()) {\n705:                 _checkExpectedRecipient(execution, expectedRentalSafe);\n706:             }\n707:             \n708:             else {\n709:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n710:                     execution.itemType\n711:                 );\n712:             }\n713:         }\n\n```\n",
          "loc": [
            "[695](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L695-L695)"
          ]
        },
        {
          "content": "```solidity\n205:        for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n206:             \n207:             target = hooks[i].target;\n208: \n209:             \n210:             if (!STORE.hookOnStop(target)) {\n211:                 revert Errors.Shared_DisabledHook(target);\n212:             }\n213: \n214:             \n215:             itemIndex = hooks[i].itemIndex;\n216: \n217:             \n218:             item = rentalItems[itemIndex];\n219: \n220:             \n221:             if (!item.isRental()) {\n222:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n223:             }\n224: \n225:             \n226:             try\n227:                 IHook(target).onStop(\n228:                     rentalWallet,\n229:                     item.token,\n230:                     item.identifier,\n231:                     item.amount,\n232:                     hooks[i].extraData\n233:                 )\n234:             {} catch Error(string memory revertReason) {\n235:                 \n236:                 revert Errors.Shared_HookFailString(revertReason);\n237:             } catch Panic(uint256 errorCode) {\n238:                 \n239:                 string memory stringErrorCode = LibString.toString(errorCode);\n240: \n241:                 \n242:                 revert Errors.Shared_HookFailString(\n243:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n244:                 );\n245:             } catch (bytes memory revertData) {\n246:                 \n247:                 revert Errors.Shared_HookFailBytes(revertData);\n248:             }\n249:         }\n\n```\n",
          "loc": [
            "[205](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L205-L205)"
          ]
        },
        {
          "content": "```solidity\n276:        for (uint256 i; i < order.items.length; ++i) { // <= FOUND\n277:             if (order.items[i].isRental()) {\n278:                 \n279:                 _insert(\n280:                     rentalAssetUpdates,\n281:                     order.items[i].toRentalId(order.rentalWallet),\n282:                     order.items[i].amount\n283:                 );\n284:             }\n285:         }\n\n```\n",
          "loc": [
            "[276](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L276-L276)"
          ]
        },
        {
          "content": "```solidity\n324:        for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n325:             \n326:             _validateRentalCanBeStoped(\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             \n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) { // <= FOUND\n334:                 \n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert(\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             \n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n346: \n347:             \n348:             if (orders[i].hooks.length > 0) { // <= FOUND\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n350:             }\n351: \n352:             \n353:             _reclaimRentedItems(orders[i]);\n354: \n355:             \n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:         }\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L348)"
          ]
        },
        {
          "content": "```solidity\n438:        for (uint256 i; i < depLength; ++i) {\n439:             Keycode keycode = dependencies[i];\n440: \n441:             \n442:             moduleDependents[keycode].push(policy_);\n443: \n444:             \n445:             getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1; // <= FOUND\n446:         }\n\n```\n",
          "loc": [
            "[445](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L445-L445)"
          ]
        },
        {
          "content": "```solidity\n592:        for (uint256 i; i < depcLength; ++i) {\n593:             \n594:             Keycode keycode = dependencies[i];\n595:             Policy[] storage dependents = moduleDependents[keycode];\n596: \n597:             \n598:             uint256 origIndex = getDependentIndex[keycode][policy_];\n599: \n600:             \n601:             Policy lastPolicy = dependents[dependents.length - 1]; // <= FOUND\n602: \n603:             \n604:             dependents[origIndex] = lastPolicy;\n605: \n606:             \n607:             \n608:             dependents.pop();\n609: \n610:             \n611:             getDependentIndex[keycode][lastPolicy] = origIndex;\n612: \n613:             \n614:             delete getDependentIndex[keycode][policy_];\n615:         }\n\n```\n",
          "loc": [
            "[601](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L601-L601)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider implementing EIP-5267 to securely describe EIP-712 domains being used",
      "description": "EIP-5267 aims to enhance EIP-712, which standardizes Ethereum's structured data signing. While EIP-712 defines how structured data should be signed, EIP-5267 focuses on standardizing the representation of domains. By doing so, it allows applications to fetch domain descriptions and dynamically construct domain separators, aiding in secure EIP-712 signature integration. To implement EIP-5267, contracts should expose a consistent method (e.g., `EIP712Domain()`) returning the domain's description. Adopting this ensures that applications can universally and securely handle EIP-712 signatures across various contracts, enhancing both security and scalability in Ethereum applications.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n315: \n316:         \n317:         eip712DomainTypehash = keccak256( // <= FOUND\n318:             abi.encodePacked(\n319:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\" // <= FOUND\n320:             )\n321:         );\n\n```\n",
          "loc": [
            "[315](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L315-L319)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Add inline comments for unnamed variables in function declarations",
      "description": "Unnamed variables in function declarations can confuse developers. To enhance clarity, add inline comments next to each unnamed variable. E.g address, -> address /* to */,",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n309:     function checkTransaction(\n310:         address to,\n311:         uint256 value,\n312:         bytes memory data,\n313:         Enum.Operation operation,\n314:         uint256, // <= FOUND\n315:         uint256, // <= FOUND\n316:         uint256, // <= FOUND\n317:         address, // <= FOUND\n318:         address payable,\n319:         bytes memory,\n320:         address\n321:     ) external override \n\n```\n",
          "loc": [
            "[314](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L314-L317)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Public state arrays should have a getter to return all elements",
      "description": "In Solidity, public state variables automatically generate a getter function. For non-array types, this is straightforward: it simply returns the value. However, for arrays, the automatically generated getter only allows retrieval of an element at a specific index, not the entire array. This is mainly to prevent unintentional high gas costs, as returning the entire array can be expensive if it's large. If developers want to retrieve the whole array, they must explicitly define a function, as auto-generation could inadvertently expose contracts to gas-related vulnerabilities or lead to unwanted behavior for larger arrays.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n206: contract Kernel {\n207:     \n208:     address public executor;\n209:     address public admin;\n210: \n212:     Keycode[] public allKeycodes; // <= FOUND\n213:     mapping(Keycode => Module) public getModuleForKeycode; \n214:     mapping(Module => Keycode) public getKeycodeForModule; \n215: \n217:     mapping(Keycode => Policy[]) public moduleDependents;\n218:     mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n219: \n221:     mapping(Keycode => mapping(Policy => mapping(bytes4 => bool)))\n222:         public modulePermissions; \n223: \n225:     Policy[] public activePolicies; // <= FOUND\n226:     mapping(Policy => uint256) public getPolicyIndex;\n227: \n229:     mapping(address => mapping(Role => bool)) public hasRole;\n230:     mapping(Role => bool) public isRole;\n231: \n362: }\n\n```\n",
          "loc": [
            "[206](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L206-L225)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Ensure block.timestamp is only used in long time intervals",
      "description": "`block.timestamp` represents the current block's timestamp and can be influenced, within limits, by miners. For short time intervals, this malleability can be exploited, potentially allowing miners to manipulate contract behavior. For instance, they might fast-forward an expiration or delay an event. When designing smart contracts, if precise time checks are needed for short intervals, alternatives like block numbers can be considered. However, for longer durations where a few seconds of deviation is inconsequential, `block.timestamp` is generally safe and efficient. Always assess the implications of time manipulations for the specific use-case before utilizing `block.timestamp`. In practice, if you're using block.timestamp to measure intervals that are a matter of days, weeks, or longer, the potential manipulation by miners becomes less significant. Always prioritize the security and integrity of your smart contract operations when making these decisions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n580:                 seaportOrderHash: seaportPayload.orderHash,\n581:                 items: items,\n582:                 hooks: payload.metadata.hooks,\n583:                 orderType: payload.metadata.orderType,\n584:                 lender: seaportPayload.offerer,\n585:                 renter: payload.intendedFulfiller,\n586:                 rentalWallet: payload.fulfillment.recipient,\n587:                 startTimestamp: block.timestamp,\n588:                 endTimestamp: block.timestamp + payload.metadata.rentDuration // <= FOUND\n589:             });\n\n```\n",
          "loc": [
            "[580](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L580-L588)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Don't use assembly for create2",
      "description": "Using assembly for create2 is error-prone and harder to read than higher-level Solidity. With the evolution of the Solidity language, a more abstracted and clear syntax for salted contract creation, which leverages the create2 opcode, has been introduced. Instead of manually managing assembly code, developers are encouraged to use the modern syntax, ensuring better readability, maintainability, and reduced chances of mistakes. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n53:         assembly {\n54:             deploymentAddress := create2( // <= FOUND\n55:                 \n56:                 callvalue(),\n57:                 \n58:                 add(initCode, 0x20),\n59:                 \n60:                 mload(initCode),\n61:                 \n62:                 salt\n63:             )\n64:         }\n\n```\n",
          "loc": [
            "[54](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L54-L54)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "It is best practice to use linear inheritance",
      "description": "In Solidity, complex inheritance structures can obfuscate code understanding, introducing potential security risks. Multiple inheritance, especially with overlapping function names or state variables, can cause unintentional overrides or ambiguous behavior. Resolution: Strive for linear and simple inheritance chains. Avoid diamond or circular inheritance patterns. Clearly document the purpose and relationships of base contracts, ensuring that overrides are intentional. Tools like Remix or Hardhat can visualize inheritance chains, assisting in verification. Keeping inheritance streamlined aids in better code readability, reduces potential errors, and ensures smoother audits and upgrades.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard  // <= FOUND\n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Contracts with only unimplemented functions can be labeled as abstract",
      "description": "In Solidity, a contract that's not meant to be deployed on its own but is intended to be inherited by other contracts should be marked `abstract`. This ensures that developers recognize the contract's incomplete or intended-to-be-extended nature. If a contract has unimplemented functions or is designed with the intention that another contract should extend its functionality, it should be explicitly labeled as `abstract`. This helps prevent inadvertent deployments and clearly communicates the contract's purpose to other developers. Resolution: Review the contract, and if it's not supposed to function standalone, mark it as `abstract` to make the intention clear.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23: contract PaymentEscrowBase \n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n14: contract StorageBase \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n14: contract Create2Deployer \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L14-L14)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "A event should be emitted if a non immutable state variable is set in a constructor",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n242:     constructor(address _executor, address _admin) {\n243:         executor = _executor; // <= FOUND\n244:         admin = _admin; // <= FOUND\n245:     }\n\n```\n",
          "loc": [
            "[242](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L242-L244)"
          ]
        },
        {
          "content": "```solidity\n33:     constructor(Kernel kernel_) {\n34:         kernel = kernel_; // <= FOUND\n35:     }\n\n```\n",
          "loc": [
            "[33](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L33-L34)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider only defining one library/interface/contract per sol file",
      "description": "Combining multiple libraries, interfaces, or contracts in a single `.sol` file can lead to clutter, reduced readability, and versioning issues. **Resolution**: Adopt the best practice of defining only one library, interface, or contract per Solidity file. This modular approach enhances clarity, simplifies unit testing, and streamlines code review. Furthermore, segregating components makes version management easier, as updates to one component won't necessitate changes to a file housing multiple unrelated components. Structured file management can further assist in avoiding naming collisions and ensure smoother integration into larger systems or DApps.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: \n3: pragma solidity ^0.8.20;\n4: \n5: import {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\n6: import {Proxiable} from \"@src/proxy/Proxiable.sol\";\n7: import {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n8: import {RentalId, RentalAssetUpdate} from \"@src/libraries/RentalStructs.sol\";\n9: import {Errors} from \"@src/libraries/Errors.sol\";\n10: \n15: contract StorageBase { // <= FOUND\n16:     \n21:     mapping(bytes32 orderHash => bool isActive) public orders;\n22: \n27:     mapping(RentalId itemId => uint256 amount) public rentedAssets;\n28: \n34:     mapping(address safe => uint256 nonce) public deployedSafes;\n35: \n37:     uint256 public totalSafes;\n38: \n45:     mapping(address to => address hook) internal _contractToHook;\n46: \n48:     mapping(address hook => uint8 enabled) public hookStatus;\n49: \n56:     mapping(address delegate => bool isWhitelisted) public whitelistedDelegates;\n57: \n59:     mapping(address extension => bool isWhitelisted) public whitelistedExtensions;\n60: }\n61: \n67: contract Storage is Proxiable, Module, StorageBase { // <= FOUND\n68:     using RentalUtils for address;\n69: \n80:     constructor(Kernel kernel_) Module(kernel_) {}\n81: \n87:     function MODULE_PROXY_INSTANTIATION(\n88:         Kernel kernel_\n89:     ) external onlyByProxy onlyUninitialized {\n90:         kernel = kernel_;\n91:         initialized = true;\n92:     }\n93: \n97:     function VERSION() external pure override returns (uint8 major, uint8 minor) {\n98:         return (1, 0);\n99:     }\n100: \n104:     function KEYCODE() public pure override returns (Keycode) {\n105:         return Keycode.wrap(\"STORE\");\n106:     }\n107: \n119:     function isRentedOut(\n120:         address recipient,\n121:         address token,\n122:         uint256 identifier\n123:     ) external view returns (bool) {\n124:         \n125:         RentalId rentalId = RentalUtils.getItemPointer(recipient, token, identifier);\n126: \n127:         \n128:         return rentedAssets[rentalId] != 0;\n129:     }\n130: \n136:     function contractToHook(address to) external view returns (address) {\n137:         \n138:         address hook = _contractToHook[to];\n139: \n140:         \n141:         \n142:         return hookStatus[hook] != 0 ? hook : address(0);\n143:     }\n144: \n150:     function hookOnTransaction(address hook) external view returns (bool) {\n151:         \n152:         return (uint8(1) & hookStatus[hook]) != 0;\n153:     }\n154: \n160:     function hookOnStart(address hook) external view returns (bool) {\n161:         \n162:         return uint8(2) & hookStatus[hook] != 0;\n163:     }\n164: \n170:     function hookOnStop(address hook) external view returns (bool) {\n171:         \n172:         return uint8(4) & hookStatus[hook] != 0;\n173:     }\n174: \n190:     function addRentals(\n191:         bytes32 orderHash,\n192:         RentalAssetUpdate[] memory rentalAssetUpdates\n193:     ) external onlyByProxy permissioned {\n194:         \n195:         orders[orderHash] = true;\n196: \n197:         \n198:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n199:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n200: \n201:             \n202:             rentedAssets[asset.rentalId] += asset.amount;\n203:         }\n204:     }\n205: \n217:     function removeRentals(\n218:         bytes32 orderHash,\n219:         RentalAssetUpdate[] calldata rentalAssetUpdates\n220:     ) external onlyByProxy permissioned {\n221:         \n222:         if (!orders[orderHash]) {\n223:             revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n224:         } else {\n225:             \n226:             delete orders[orderHash];\n227:         }\n228: \n229:         \n230:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n231:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n```\n",
          "loc": [
            "[2](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L2-L67)"
          ]
        },
        {
          "content": "```solidity\n2: \n3: pragma solidity ^0.8.20;\n4: \n5: import {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\n6: \n7: import {Kernel, Module, Keycode} from \"@src/Kernel.sol\";\n8: import {Proxiable} from \"@src/proxy/Proxiable.sol\";\n9: import {\n10:     RentalOrder,\n11:     Item,\n12:     ItemType,\n13:     SettleTo,\n14:     OrderType\n15: } from \"@src/libraries/RentalStructs.sol\";\n16: import {Errors} from \"@src/libraries/Errors.sol\";\n17: import {Events} from \"@src/libraries/Events.sol\";\n18: import {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\n19: \n24: contract PaymentEscrowBase { // <= FOUND\n25:     \n26:     mapping(address token => uint256 amount) public balanceOf;\n27: \n29:     uint256 public fee;\n30: }\n31: \n38: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase { // <= FOUND\n39:     using RentalUtils for Item;\n40:     using RentalUtils for OrderType;\n41: \n52:     constructor(Kernel kernel_) Module(kernel_) {}\n53: \n59:     function MODULE_PROXY_INSTANTIATION(\n60:         Kernel kernel_\n61:     ) external onlyByProxy onlyUninitialized {\n62:         kernel = kernel_;\n63:         initialized = true;\n64:     }\n65: \n69:     function VERSION() external pure override returns (uint8 major, uint8 minor) {\n70:         return (1, 0);\n71:     }\n72: \n76:     function KEYCODE() public pure override returns (Keycode) {\n77:         return Keycode.wrap(\"ESCRW\");\n78:     }\n79: \n89:     function _calculateFee(uint256 amount) internal view returns (uint256) {\n90:         \n91:         return (amount * fee) / 10000;\n92:     }\n93: \n101:     function _safeTransfer(address token, address to, uint256 value) internal {\n102:         \n103:         (bool success, bytes memory data) = token.call(\n104:             abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n105:         );\n106: \n107:         \n108:         \n109:         \n110:         \n111:         \n112:         \n113:         \n114:         \n115:         \n116:         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n117:             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n118:         }\n119:     }\n120: \n133:     function _calculatePaymentProRata(\n134:         uint256 amount,\n135:         uint256 elapsedTime,\n136:         uint256 totalTime\n137:     ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n138:         \n139:         uint256 numerator = (amount * elapsedTime) * 1000;\n140: \n141:         \n142:         \n143:         renterAmount = ((numerator / totalTime) + 500) / 1000;\n144: \n145:         \n146:         lenderAmount = amount - renterAmount;\n147:     }\n\n```\n",
          "loc": [
            "[2](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L2-L38)"
          ]
        },
        {
          "content": "```solidity\n2: \n3: pragma solidity ^0.8.20;\n4: \n5: import {\n6:     toRole,\n7:     ensureContract,\n8:     ensureValidKeycode,\n9:     ensureValidRole\n10: } from \"@src/libraries/KernelUtils.sol\";\n11: import {Actions, Keycode, Role, Permissions} from \"@src/libraries/RentalStructs.sol\";\n12: import {Errors} from \"@src/libraries/Errors.sol\";\n13: import {Events} from \"src/libraries/Events.sol\";\n14: \n24: abstract contract KernelAdapter { // <= FOUND\n25:     \n26:     Kernel public kernel;\n27: \n34:     constructor(Kernel kernel_) {\n35:         kernel = kernel_;\n36:     }\n37: \n41:     modifier onlyKernel() {\n42:         if (msg.sender != address(kernel))\n43:             revert Errors.KernelAdapter_OnlyKernel(msg.sender);\n44:         _;\n45:     }\n46: \n55:     function changeKernel(Kernel newKernel_) external onlyKernel {\n56:         kernel = newKernel_;\n57:     }\n58: }\n59: \n65: abstract contract Module is KernelAdapter { // <= FOUND\n66:     \n72:     constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n73: \n78:     modifier permissioned() {\n79:         if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig)) {\n80:             revert Errors.Module_PolicyNotAuthorized(msg.sender);\n81:         }\n82:         _;\n83:     }\n84: \n91:     function KEYCODE() public pure virtual returns (Keycode);\n92: \n101:     function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n102: \n107:     function INIT() external virtual onlyKernel {}\n108: }\n109: \n115: abstract contract Policy is KernelAdapter { // <= FOUND\n116:     \n117:     bool public isActive;\n118: \n125:     constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n126: \n131:     modifier onlyRole(bytes32 role_) {\n132:         Role role = toRole(role_);\n133:         if (!kernel.hasRole(msg.sender, role)) {\n134:             revert Errors.Policy_OnlyRole(role);\n135:         }\n136:         _;\n137:     }\n138: \n149:     function configureDependencies()\n150:         external\n151:         virtual\n152:         onlyKernel\n153:         returns (Keycode[] memory dependencies)\n154:     {}\n155: \n167:     function requestPermissions()\n168:         external\n169:         view\n170:         virtual\n171:         onlyKernel\n172:         returns (Permissions[] memory requests)\n173:     {}\n174: \n181:     function getModuleAddress(Keycode keycode_) internal view returns (address) {\n182:         address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n183:         if (moduleForKeycode == address(0))\n184:             revert Errors.Policy_ModuleDoesNotExist(keycode_);\n185:         return moduleForKeycode;\n186:     }\n187: \n193:     function setActiveStatus(bool activate_) external onlyKernel {\n194:         isActive = activate_;\n195:     }\n196: }\n197: \n207: contract Kernel { // <= FOUND\n208:     \n209:     address public executor;\n210:     address public admin;\n211: \n213:     Keycode[] public allKeycodes;\n214:     mapping(Keycode => Module) public getModuleForKeycode; \n215:     mapping(Module => Keycode) public getKeycodeForModule; \n216: \n218:     mapping(Keycode => Policy[]) public moduleDependents;\n219:     mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n220: \n222:     mapping(Keycode => mapping(Policy => mapping(bytes4 => bool)))\n223:         public modulePermissions; \n224: \n226:     Policy[] public activePolicies;\n227:     mapping(Policy => uint256) public getPolicyIndex;\n228: \n230:     mapping(address => mapping(Role => bool)) public hasRole;\n231:     mapping(Role => bool) public isRole;\n232: \n243:     constructor(address _executor, address _admin) {\n244:         executor = _executor;\n245:         admin = _admin;\n246:     }\n247: \n255:     modifier onlyExecutor() {\n256:         if (msg.sender != executor) revert Errors.Kernel_OnlyExecutor(msg.sender);\n257:         _;\n258:     }\n259: \n263:     modifier onlyAdmin() {\n264:         if (msg.sender != admin) revert Errors.Kernel_OnlyAdmin(msg.sender);\n265:         _;\n266:     }\n267: \n278:     function executeAction(Actions action_, address target_) external onlyExecutor {\n279:         if (action_ == Actions.InstallModule) {\n280:             ensureContract(target_);\n281:             ensureValidKeycode(Module(target_).KEYCODE());\n282:             _installModule(Module(target_));\n283:         } else if (action_ == Actions.UpgradeModule) {\n284:             ensureContract(target_);\n285:             ensureValidKeycode(Module(target_).KEYCODE());\n286:             _upgradeModule(Module(target_));\n287:         } else if (action_ == Actions.ActivatePolicy) {\n288:             ensureContract(target_);\n289:             _activatePolicy(Policy(target_));\n290:         } else if (action_ == Actions.DeactivatePolicy) {\n291:             ensureContract(target_);\n292:             _deactivatePolicy(Policy(target_));\n293:         } else if (action_ == Actions.MigrateKernel) {\n294:             ensureContract(target_);\n295:             _migrateKernel(Kernel(target_));\n296:         } else if (action_ == Actions.ChangeExecutor) {\n297:             executor = target_;\n298:         } else if (action_ == Actions.ChangeAdmin) {\n299:             admin = target_;\n300:         }\n301: \n302:         emit Events.ActionExecuted(action_, target_);\n303:     }\n304: \n311:     function grantRole(Role role_, address addr_) public onlyAdmin {\n312:         \n313:         if (hasRole[addr_][role_])\n314:             revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_);\n315: \n316:         \n317:         ensureValidRole(role_);\n318: \n319:         \n320:         if (!isRole[role_]) isRole[role_] = true;\n321: \n322:         \n323:         hasRole[addr_][role_] = true;\n324: \n325:         emit Events.RoleGranted(role_, addr_);\n326:     }\n327: \n334:     function revokeRole(Role role_, address addr_) public onlyAdmin {\n335:         \n336:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_);\n337: \n338:         \n339:         if (!hasRole[addr_][role_])\n340:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_);\n341: \n342:         \n343:         hasRole[addr_][role_] = false;\n344: \n345:         emit Events.RoleRevoked(role_, addr_);\n346:     }\n347: \n357:     function _installModule(Module newModule_) internal {\n358:         \n359:         Keycode keycode = newModule_.KEYCODE();\n360: \n361:         \n362:         if (address(getModuleForKeycode[keycode]) != address(0)) {\n363:             revert Errors.Kernel_ModuleAlreadyInstalled(keycode);\n364:         }\n365: \n366:         \n367:         getModuleForKeycode[keycode] = newModule_;\n368: \n369:         \n370:         getKeycodeForModule[newModule_] = keycode;\n371: \n372:         \n373:         allKeycodes.push(keycode);\n374: \n375:         \n376:         newModule_.INIT();\n377:     }\n378: \n384:     function _upgradeModule(Module newModule_) internal {\n385:         \n386:         Keycode keycode = newModule_.KEYCODE();\n387: \n388:         \n389:         Module oldModule = getModuleForKeycode[keycode];\n390: \n391:         \n392:         \n393:         if (address(oldModule) == address(0) || oldModule == newModule_) {\n394:             revert Errors.Kernel_InvalidModuleUpgrade(keycode);\n395:         }\n396: \n397:         \n398:         getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n399: \n400:         \n401:         getKeycodeForModule[newModule_] = keycode;\n402: \n403:         \n404:         getModuleForKeycode[keycode] = newModule_;\n405: \n406:         \n407:         newModule_.INIT();\n408: \n409:         \n410:         \n411:         _reconfigurePolicies(keycode);\n412:     }\n413: \n419:     function _activatePolicy(Policy policy_) internal {\n420:         \n421:         if (policy_.isActive())\n422:             revert Errors.Kernel_PolicyAlreadyApproved(address(policy_));\n423: \n424:         \n425:         Permissions[] memory requests = policy_.requestPermissions();\n426:         _setPolicyPermissions(policy_, requests, true);\n427: \n428:         \n429:         activePolicies.push(policy_);\n430: \n431:         \n432:         getPolicyIndex[policy_] = activePolicies.length - 1;\n433: \n434:         \n435:         Keycode[] memory dependencies = policy_.configureDependencies();\n436:         uint256 depLength = dependencies.length;\n\n```\n",
          "loc": [
            "[2](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L2-L207)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Immutable and constant integer state variables should not be casted",
      "description": "The definition of a constant or immutable variable is that they do not change, casting such variables can potentially push more than one 'value' to a constant, for example a uin128 constant can have its original value and that of when it's casted to uint64 (i.e it has some bytes truncated). This can create confusion and inconsistencies within the code which can inadvertently increase the attack surface of the project. It is thus advise to either change the uint byte size in the constant/immutable definition of the variable or introduce a second state variable to cover the differing casts that are expected such as having a uint128 constant and a separate uint64 constant.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n298:     function _deriveTypehashes()\n299:         internal\n300:         view\n301:         returns (\n302:             bytes32 nameHash,\n303:             bytes32 versionHash,\n304:             bytes32 eip712DomainTypehash,\n305:             bytes32 domainSeparator\n306:         )\n307:     {\n308:         \n309:         nameHash = keccak256(bytes(_NAME)); // <= FOUND\n310: \n311:         \n312:         versionHash = keccak256(bytes(_VERSION)); // <= FOUND\n313: \n314:         \n315:         eip712DomainTypehash = keccak256(\n316:             abi.encodePacked(\n317:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n318:             )\n319:         );\n320: \n321:         \n322:         domainSeparator = _deriveDomainSeparator(\n323:             eip712DomainTypehash,\n324:             nameHash,\n325:             versionHash\n326:         );\n327:     }\n\n```\n",
          "loc": [
            "[298](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L298-L312)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Numbers downcast to addresses may result in collisions",
      "description": "Downcasting numbers to addresses in blockchain contracts, particularly in Ethereum's Solidity, involves risks such as possible address collisions. A collision occurs when different inputs, when cast or hashed, generate the same output address, potentially compromising contract integrity and asset security. If an uint256, for instance, is downcast to an address (effectively an uint160) without ensuring itâ€™s a legitimate, collision-free conversion, different uint256 inputs might yield the same address, creating vulnerabilities attackers might exploit. Implementing thorough checks and opting for secure practices, like avoiding downcasting in critical logic or utilizing mappings with original uint256 as keys, mitigates risks",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n94: \n95:         \n96:         return address(uint160(uint256(addressHash))); // <= FOUND\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L96-L96)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Public variable declarations should have NatSpec descriptions",
      "description": "Public variable declarations in smart contracts should ideally be accompanied by NatSpec comments to enhance code readability and provide clear documentation. NatSpec (Natural Language Specification) is a standard for writing comments in Ethereum smart contracts that can generate user-friendly documentation, improving the transparency of the contract's functionality. This is particularly crucial for public variables, as they are accessible externally, and understanding their role and impact is vital for both developers and users interacting with the contract",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n35:     TokenCallbackHandler public immutable fallbackHandler; // <= FOUND\n36:     SafeProxyFactory public immutable safeProxyFactory; // <= FOUND\n37:     SafeL2 public immutable safeSingleton; // <= FOUND\n\n```\n",
          "loc": [
            "[35](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L35-L37)"
          ]
        },
        {
          "content": "```solidity\n53:     Storage public STORE; // <= FOUND\n54:     PaymentEscrow public ESCRW; // <= FOUND\n55: \n\n```\n",
          "loc": [
            "[53](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L53-L54)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use the Modern Upgradeable Contract Paradigm",
      "description": "Modern smart contract development often employs upgradeable contract structures, utilizing proxy patterns like OpenZeppelinâ€™s Upgradeable Contracts. This paradigm separates logic and state, allowing developers to amend and enhance the contract's functionality without altering its state or the deployed contract address. Transitioning to this approach enhances long-term maintainability.\n\n**Resolution**: Adopt a well-established proxy pattern for upgradeability, ensuring proper initialization and employing transparent proxies to mitigate potential risks. Embrace comprehensive testing and audit practices, particularly when updating contract logic, to ensure state consistency and security are preserved across upgrades. This ensures your contract remains robust and adaptable to future requirements.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23: contract PaymentEscrowBase \n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase \n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n14: contract StorageBase \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase \n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n15: contract Admin is Policy \n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator \n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n22: contract Factory is Policy \n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard \n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator \n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        },
        {
          "content": "```solidity\n14: contract Create2Deployer \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n206: contract Kernel \n\n```\n",
          "loc": [
            "[206](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L206-L206)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Upgrade openzeppelin to the Latest Version - 5.0.0",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n4: import {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n4: import {IERC721} from \"@openzeppelin-contracts/token/ERC721/IERC721.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n5: import {IERC1155} from \"@openzeppelin-contracts/token/ERC1155/IERC1155.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L5-L5)"
          ]
        },
        {
          "content": "```solidity\n4: import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L4-L4)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use a struct to encapsulate multiple function parameters",
      "description": "Using a struct to encapsulate multiple parameters in Solidity functions can significantly enhance code readability and maintainability. Instead of passing a long list of arguments, which can be error-prone and hard to manage, a struct allows grouping related data into a single, coherent entity. This approach simplifies function signatures and makes the code more organized. It also enhances code clarity, as developers can easily understand the relationship between the parameters. Moreover, it aids in future code modifications and expansions, as adding or modifying a parameter only requires changes in the struct definition, rather than in every function that uses these parameters.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n159:     function _settlePaymentProRata(\n160:         address token, // <= FOUND\n161:         uint256 amount, // <= FOUND\n162:         address lender, // <= FOUND\n163:         address renter, // <= FOUND\n164:         uint256 elapsedTime, // <= FOUND\n165:         uint256 totalTime\n166:     ) internal \n\n```\n",
          "loc": [
            "[160](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L160-L164)"
          ]
        },
        {
          "content": "```solidity\n190:     function _settlePaymentInFull(\n191:         address token, // <= FOUND\n192:         uint256 amount, // <= FOUND\n193:         SettleTo settleTo, // <= FOUND\n194:         address lender, // <= FOUND\n195:         address renter\n196:     ) internal \n\n```\n",
          "loc": [
            "[191](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L191-L194)"
          ]
        },
        {
          "content": "```solidity\n215:     function _settlePayment(\n216:         Item[] calldata items, // <= FOUND\n217:         OrderType orderType, // <= FOUND\n218:         address lender, // <= FOUND\n219:         address renter, // <= FOUND\n220:         uint256 start, // <= FOUND\n221:         uint256 end\n222:     ) internal \n\n```\n",
          "loc": [
            "[216](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L216-L220)"
          ]
        },
        {
          "content": "```solidity\n159:     function _forwardToHook(\n160:         address hook, // <= FOUND\n161:         address safe, // <= FOUND\n162:         address to, // <= FOUND\n163:         uint256 value, // <= FOUND\n164:         bytes memory data\n165:     ) private \n\n```\n",
          "loc": [
            "[160](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L160-L163)"
          ]
        },
        {
          "content": "```solidity\n309:     function checkTransaction(\n310:         address to, // <= FOUND\n311:         uint256 value, // <= FOUND\n312:         bytes memory data, // <= FOUND\n313:         Enum.Operation operation, // <= FOUND\n314:         uint256, // <= FOUND\n315:         uint256, // <= FOUND\n316:         uint256, // <= FOUND\n317:         address, // <= FOUND\n318:         address payable, // <= FOUND\n319:         bytes memory, // <= FOUND\n320:         address\n321:     ) external override \n\n```\n",
          "loc": [
            "[310](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L310-L319)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Returning a struct instead of returning many variables is better",
      "description": "Returning a struct from a Solidity function instead of multiple variables offers several benefits, enhancing code clarity and efficiency. Structs allow for the grouping of related data into a single entity, making the function's return values more organized and easier to manage. This approach significantly improves readability, as it encapsulates the data logically, helping developers quickly understand the returned information's structure. Additionally, it simplifies function interfaces, reducing the potential for errors when handling multiple return values. By using structs, you can also easily extend or modify the returned data without altering the function signature, facilitating smoother updates and maintenance of your smart contract code.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n339:     function _deriveRentalTypehashes()\n340:         internal\n341:         pure\n342:         returns (\n343:             bytes32 itemTypeHash, // <= FOUND\n344:             bytes32 hookTypeHash, // <= FOUND\n345:             bytes32 rentalOrderTypeHash, // <= FOUND\n346:             bytes32 orderFulfillmentTypeHash, // <= FOUND\n347:             bytes32 orderMetadataTypeHash, // <= FOUND\n348:             bytes32 rentPayloadTypeHash\n349:         )\n350:     \n\n```\n",
          "loc": [
            "[343](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L343-L347)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Long numbers should include underscores to improve readability and prevent typos",
      "description": "A large number such as 2000000 is far more readable as 2_000_000, this will help prevent unintended bugs in the code",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n90:         \n91:         return (amount * fee) / 10000; // <= FOUND\n\n```\n",
          "loc": [
            "[91](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L91-L91)"
          ]
        },
        {
          "content": "```solidity\n382:         \n383:         if (feeNumerator > 10000) { // <= FOUND\n\n```\n",
          "loc": [
            "[383](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L383-L383)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using a format prettier or forge fmt",
      "description": "Some comments use // X and others //X Amend comments to use only use // X or //X consistently such style inconsistencies can be resolved by running the project through a format prettier or by using forge fmt.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n102: //github.com/martinetlee/create2-snippets#method-1-mixing-with-salt\n\n```\n",
          "loc": [
            "[102](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L102-L102)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Avoid defining a function in a single line including it's contents",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n90: \n97:     function KEYCODE() public pure virtual returns (Keycode); // <= FOUND\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L90-L97)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use 'using' keyword when using specific imports rather than calling the specific import directly",
      "description": "In Solidity, the `using` keyword can streamline the use of library functions for specific types. Instead of calling library functions directly with their full import paths, you can declare a library once with `using` for a specific type. This approach makes your code more readable and concise. For example, instead of `LibraryName.functionName(variable)`, you would first declare `using LibraryName for TypeName;` at the contract level. After this, you can call library functions directly on variables of `TypeName` like `variable.functionName()`. This method not only enhances code clarity but also promotes cleaner and more organized code, especially when multiple functions from the same library are used frequently.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n102:         \n103:         (bool success, bytes memory data) = token.call(\n104:             abi.encodeWithSelector(IERC20.transfer.selector, to, value) // <= FOUND 'IERC20.'\n105:         );\n\n```\n",
          "loc": [
            "[102](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L102-L104)"
          ]
        },
        {
          "content": "```solidity\n76:         return Keycode.wrap(\"ESCRW\"); // <= FOUND 'Keycode.'\n\n```\n",
          "loc": [
            "[76](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L76-L76)"
          ]
        },
        {
          "content": "```solidity\n104:         return Keycode.wrap(\"STORE\"); // <= FOUND 'Keycode.'\n\n```\n",
          "loc": [
            "[104](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L104-L104)"
          ]
        },
        {
          "content": "```solidity\n397: \n398:         \n399:         getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0)); // <= FOUND 'Keycode.'\n\n```\n",
          "loc": [
            "[397](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L397-L399)"
          ]
        },
        {
          "content": "```solidity\n116:             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[116](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L116-L116)"
          ]
        },
        {
          "content": "```solidity\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType)); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[279](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L279-L279)"
          ]
        },
        {
          "content": "```solidity\n367:             revert Errors.PaymentEscrow_ZeroPayment(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[367](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L367-L367)"
          ]
        },
        {
          "content": "```solidity\n383:             revert Errors.PaymentEscrow_InvalidFeeNumerator(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[383](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L383-L383)"
          ]
        },
        {
          "content": "```solidity\n222:             revert Errors.StorageModule_OrderDoesNotExist(orderHash); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[222](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L222-L222)"
          ]
        },
        {
          "content": "```solidity\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[252](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L252-L252)"
          ]
        },
        {
          "content": "```solidity\n296:         \n297:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[296](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L296-L297)"
          ]
        },
        {
          "content": "```solidity\n299: \n300:         \n301:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[299](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L299-L301)"
          ]
        },
        {
          "content": "```solidity\n299:         \n300:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[299](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L299-L300)"
          ]
        },
        {
          "content": "```solidity\n321: \n322:         \n323:         if (bitmap > uint8(7))\n324:             revert Errors.StorageModule_InvalidHookStatusBitmap(bitmap); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[321](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L321-L324)"
          ]
        },
        {
          "content": "```solidity\n74:             revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[74](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L74-L74)"
          ]
        },
        {
          "content": "```solidity\n81:             revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed( // <= FOUND 'Errors.'\n82:                 rentalOrder.rentalWallet\n83:             );\n\n```\n",
          "loc": [
            "[81](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L81-L81)"
          ]
        },
        {
          "content": "```solidity\n82:             revert Errors.SignerPackage_UnauthorizedFulfiller( // <= FOUND 'Errors.'\n83:                 actualFulfiller,\n84:                 intendedFulfiller\n85:             );\n\n```\n",
          "loc": [
            "[82](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L82-L82)"
          ]
        },
        {
          "content": "```solidity\n97:             revert Errors.SignerPackage_SignatureExpired(block.timestamp, expiration); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[97](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L97-L97)"
          ]
        },
        {
          "content": "```solidity\n202:             revert Errors.CreatePolicy_OfferCountZero(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[202](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L202-L202)"
          ]
        },
        {
          "content": "```solidity\n223:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[223](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L223-L223)"
          ]
        },
        {
          "content": "```solidity\n312:             revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[312](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L312-L312)"
          ]
        },
        {
          "content": "```solidity\n333:             revert Errors.CreatePolicy_ConsiderationCountZero(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L333-L333)"
          ]
        },
        {
          "content": "```solidity\n343:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported( // <= FOUND 'Errors.'\n344:                     consideration.itemType\n345:                 );\n\n```\n",
          "loc": [
            "[343](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L343-L343)"
          ]
        },
        {
          "content": "```solidity\n434:                 revert Errors.CreatePolicy_ConsiderationCountNonZero( // <= FOUND 'Errors.'\n435:                     considerations.length\n436:                 );\n\n```\n",
          "loc": [
            "[434](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L434-L434)"
          ]
        },
        {
          "content": "```solidity\n443:                 revert Errors.CreatePolicy_OfferCountNonZero(offers.length); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[443](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L443-L443)"
          ]
        },
        {
          "content": "```solidity\n451:             revert Errors.Shared_OrderTypeNotSupported(uint8(orderType)); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[451](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L451-L451)"
          ]
        },
        {
          "content": "```solidity\n481:                 revert Errors.Shared_DisabledHook(target); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[481](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L481-L481)"
          ]
        },
        {
          "content": "```solidity\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[492](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L492-L492)"
          ]
        },
        {
          "content": "```solidity\n506:                 \n507:                 revert Errors.Shared_HookFailString(revertReason); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[506](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L506-L507)"
          ]
        },
        {
          "content": "```solidity\n512: \n513:                 \n514:                 revert Errors.Shared_HookFailString( // <= FOUND 'Errors.'\n515:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n516:                 );\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L512-L514)"
          ]
        },
        {
          "content": "```solidity\n517:                 \n518:                 revert Errors.Shared_HookFailBytes(revertData); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[517](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L517-L518)"
          ]
        },
        {
          "content": "```solidity\n632:             revert Errors.CreatePolicy_RentDurationZero(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[632](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L632-L632)"
          ]
        },
        {
          "content": "```solidity\n637:             revert Errors.CreatePolicy_InvalidOrderMetadataHash(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[637](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L637-L637)"
          ]
        },
        {
          "content": "```solidity\n650:             revert Errors.CreatePolicy_InvalidRentalSafe(safe); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[650](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L650-L650)"
          ]
        },
        {
          "content": "```solidity\n655:             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[655](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L655-L655)"
          ]
        },
        {
          "content": "```solidity\n671:             revert Errors.CreatePolicy_UnexpectedTokenRecipient( // <= FOUND 'Errors.'\n672:                 execution.itemType,\n673:                 execution.token,\n674:                 execution.identifier,\n675:                 execution.amount,\n676:                 execution.recipient,\n677:                 expectedRecipient\n678:             );\n\n```\n",
          "loc": [
            "[671](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L671-L671)"
          ]
        },
        {
          "content": "```solidity\n709:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported( // <= FOUND 'Errors.'\n710:                     execution.itemType\n711:                 );\n\n```\n",
          "loc": [
            "[709](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L709-L709)"
          ]
        },
        {
          "content": "```solidity\n767:             revert Errors.CreatePolicy_UnauthorizedCreatePolicySigner(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[767](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L767-L767)"
          ]
        },
        {
          "content": "```solidity\n144:             revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[144](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L144-L144)"
          ]
        },
        {
          "content": "```solidity\n134:             revert Errors.GuardPolicy_UnauthorizedSelector(selector); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[134](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L134-L134)"
          ]
        },
        {
          "content": "```solidity\n146:             revert Errors.GuardPolicy_UnauthorizedExtension(extension); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[146](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L146-L146)"
          ]
        },
        {
          "content": "```solidity\n506:             \n507:             revert Errors.Shared_HookFailString(revertReason); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[506](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L506-L507)"
          ]
        },
        {
          "content": "```solidity\n512: \n513:             \n514:             revert Errors.Shared_HookFailString( // <= FOUND 'Errors.'\n515:                 string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n516:             );\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L512-L514)"
          ]
        },
        {
          "content": "```solidity\n517:             \n518:             revert Errors.Shared_HookFailBytes(revertData); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[517](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L517-L518)"
          ]
        },
        {
          "content": "```solidity\n271:                 revert Errors.GuardPolicy_UnauthorizedSelector( // <= FOUND 'Errors.'\n272:                     shared_set_approval_for_all_selector\n273:                 );\n\n```\n",
          "loc": [
            "[271](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L271-L271)"
          ]
        },
        {
          "content": "```solidity\n281:                 revert Errors.GuardPolicy_UnauthorizedSelector( // <= FOUND 'Errors.'\n282:                     e1155_safe_batch_transfer_from_selector\n283:                 );\n\n```\n",
          "loc": [
            "[281](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L281-L281)"
          ]
        },
        {
          "content": "```solidity\n288:                 revert Errors.GuardPolicy_UnauthorizedSelector( // <= FOUND 'Errors.'\n289:                     gnosis_safe_set_guard_selector\n290:                 );\n\n```\n",
          "loc": [
            "[288](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L288-L288)"
          ]
        },
        {
          "content": "```solidity\n325:             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[325](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L325-L325)"
          ]
        },
        {
          "content": "```solidity\n330:             revert Errors.GuardPolicy_FunctionSelectorRequired(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[330](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L330-L330)"
          ]
        },
        {
          "content": "```solidity\n141:                 revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[141](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L141-L141)"
          ]
        },
        {
          "content": "```solidity\n181:             revert Errors.StopPolicy_ReclaimFailed(); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[181](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L181-L181)"
          ]
        },
        {
          "content": "```solidity\n38:             revert Errors.Create2Deployer_UnauthorizedSender(msg.sender, salt); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[38](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L38-L38)"
          ]
        },
        {
          "content": "```solidity\n46:             revert Errors.Create2Deployer_AlreadyDeployed(targetDeploymentAddress, salt); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[46](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L46-L46)"
          ]
        },
        {
          "content": "```solidity\n68:             revert Errors.Create2Deployer_MismatchedDeploymentAddress( // <= FOUND 'Errors.'\n69:                 targetDeploymentAddress,\n70:                 deploymentAddress\n71:             );\n\n```\n",
          "loc": [
            "[68](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L68-L68)"
          ]
        },
        {
          "content": "```solidity\n41:         if (msg.sender != address(kernel))\n42:             revert Errors.KernelAdapter_OnlyKernel(msg.sender); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L41-L42)"
          ]
        },
        {
          "content": "```solidity\n79:             revert Errors.Module_PolicyNotAuthorized(msg.sender); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[79](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L79-L79)"
          ]
        },
        {
          "content": "```solidity\n133:             revert Errors.Policy_OnlyRole(role); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[133](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L133-L133)"
          ]
        },
        {
          "content": "```solidity\n182:         if (moduleForKeycode == address(0))\n183:             revert Errors.Policy_ModuleDoesNotExist(keycode_); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[182](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L182-L183)"
          ]
        },
        {
          "content": "```solidity\n255:         if (msg.sender != executor) revert Errors.Kernel_OnlyExecutor(msg.sender); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[255](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L255-L255)"
          ]
        },
        {
          "content": "```solidity\n263:         if (msg.sender != admin) revert Errors.Kernel_OnlyAdmin(msg.sender); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[263](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L263-L263)"
          ]
        },
        {
          "content": "```solidity\n312:         \n313:         if (hasRole[addr_][role_])\n314:             revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[312](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L312-L314)"
          ]
        },
        {
          "content": "```solidity\n335:         \n336:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[335](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L335-L336)"
          ]
        },
        {
          "content": "```solidity\n338: \n339:         \n340:         if (!hasRole[addr_][role_])\n341:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[338](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L338-L341)"
          ]
        },
        {
          "content": "```solidity\n362:             revert Errors.Kernel_ModuleAlreadyInstalled(keycode); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L362-L362)"
          ]
        },
        {
          "content": "```solidity\n393:             revert Errors.Kernel_InvalidModuleUpgrade(keycode); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[393](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L393-L393)"
          ]
        },
        {
          "content": "```solidity\n420:         \n421:         if (policy_.isActive())\n422:             revert Errors.Kernel_PolicyAlreadyApproved(address(policy_)); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[420](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L420-L422)"
          ]
        },
        {
          "content": "```solidity\n458:         if (!policy_.isActive()) revert Errors.Kernel_PolicyNotApproved(address(policy_)); // <= FOUND 'Errors.'\n\n```\n",
          "loc": [
            "[458](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L458-L458)"
          ]
        },
        {
          "content": "```solidity\n411: \n412:         \n413:         emit Events.FeeTaken(token, skimmedBalance); // <= FOUND 'Events.'\n\n```\n",
          "loc": [
            "[411](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L411-L413)"
          ]
        },
        {
          "content": "```solidity\n171:         \n172:         emit Events.RentalOrderStarted( // <= FOUND 'Events.'\n173:             orderHash,\n174:             extraData,\n175:             order.seaportOrderHash,\n176:             order.items,\n177:             order.hooks,\n178:             order.orderType,\n179:             order.lender,\n180:             order.renter,\n181:             order.rentalWallet,\n182:             order.startTimestamp,\n183:             order.endTimestamp\n184:         );\n\n```\n",
          "loc": [
            "[171](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L171-L172)"
          ]
        },
        {
          "content": "```solidity\n192: \n193:         \n194:         emit Events.RentalSafeDeployment(safe, owners, threshold); // <= FOUND 'Events.'\n\n```\n",
          "loc": [
            "[192](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L192-L194)"
          ]
        },
        {
          "content": "```solidity\n113:         \n114:         emit Events.RentalOrderStopped(seaportOrderHash, stopper); // <= FOUND 'Events.'\n\n```\n",
          "loc": [
            "[113](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L113-L114)"
          ]
        },
        {
          "content": "```solidity\n301: \n302:         emit Events.ActionExecuted(action_, target_); // <= FOUND 'Events.'\n\n```\n",
          "loc": [
            "[301](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L301-L302)"
          ]
        },
        {
          "content": "```solidity\n324: \n325:         emit Events.RoleGranted(role_, addr_); // <= FOUND 'Events.'\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L324-L325)"
          ]
        },
        {
          "content": "```solidity\n344: \n345:         emit Events.RoleRevoked(role_, addr_); // <= FOUND 'Events.'\n\n```\n",
          "loc": [
            "[344](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L344-L345)"
          ]
        },
        {
          "content": "```solidity\n571: \n572:             emit Events.PermissionsUpdated( // <= FOUND 'Events.'\n573:                 request.keycode,\n574:                 policy_,\n575:                 request.funcSelector,\n576:                 grant_\n577:             );\n\n```\n",
          "loc": [
            "[571](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L571-L572)"
          ]
        },
        {
          "content": "```solidity\n124:         \n125:         RentalId rentalId = RentalUtils.getItemPointer(recipient, token, identifier); // <= FOUND 'RentalUtils.'\n\n```\n",
          "loc": [
            "[124](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L124-L125)"
          ]
        },
        {
          "content": "```solidity\n38:         \n39:         bytes32 _rentalId = RentalId.unwrap(rentalId); // <= FOUND 'RentalId.'\n\n```\n",
          "loc": [
            "[38](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L38-L39)"
          ]
        },
        {
          "content": "```solidity\n168:         \n169:         bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n170:             \n171:             address(this),\n172:             \n173:             0,\n174:             \n175:             abi.encodeWithSelector(this.reclaimRentalOrder.selector, order), // <= FOUND 'RentalOrder.'\n176:             \n177:             Enum.Operation.DelegateCall // <= FOUND 'Enum.'\n178:         );\n\n```\n",
          "loc": [
            "[168](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L168-L177)"
          ]
        },
        {
          "content": "```solidity\n94: \n95:             \n96:             if (item.itemType == ItemType.ERC721) // <= FOUND 'ItemType.'\n97:                 _transferERC721(item, rentalOrder.lender);\n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L94-L96)"
          ]
        },
        {
          "content": "```solidity\n98: \n99:             \n100:             if (item.itemType == ItemType.ERC1155) // <= FOUND 'ItemType.'\n101:                 _transferERC1155(item, rentalOrder.lender);\n\n```\n",
          "loc": [
            "[98](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L98-L100)"
          ]
        },
        {
          "content": "```solidity\n215:                 itemType = ItemType.ERC721; // <= FOUND 'ItemType.'\n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L215-L215)"
          ]
        },
        {
          "content": "```solidity\n219:                 itemType = ItemType.ERC1155; // <= FOUND 'ItemType.'\n\n```\n",
          "loc": [
            "[219](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L219-L219)"
          ]
        },
        {
          "content": "```solidity\n215:                 \n216:                 \n217:                 itemType = ItemType.ERC721; // <= FOUND 'ItemType.'\n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L215-L217)"
          ]
        },
        {
          "content": "```solidity\n219:                 \n220:                 \n221:                 itemType = ItemType.ERC1155; // <= FOUND 'ItemType.'\n\n```\n",
          "loc": [
            "[219](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L219-L221)"
          ]
        },
        {
          "content": "```solidity\n289:                 \n290:                 \n291:                 itemType = ItemType.ERC20; // <= FOUND 'ItemType.'\n\n```\n",
          "loc": [
            "[289](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L289-L291)"
          ]
        },
        {
          "content": "```solidity\n351:                 itemType: ItemType.ERC20, // <= FOUND 'ItemType.'\n352:                 settleTo: SettleTo.LENDER,\n353:                 token: consideration.token,\n354:                 amount: consideration.amount,\n355:                 identifier: consideration.identifier\n356:             });\n\n```\n",
          "loc": [
            "[351](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L351-L351)"
          ]
        },
        {
          "content": "```solidity\n509:                 \n510:                 string memory stringErrorCode = LibString.toString(errorCode); // <= FOUND 'LibString.'\n\n```\n",
          "loc": [
            "[509](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L509-L510)"
          ]
        },
        {
          "content": "```solidity\n509:             \n510:             string memory stringErrorCode = LibString.toString(errorCode); // <= FOUND 'LibString.'\n\n```\n",
          "loc": [
            "[509](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L509-L510)"
          ]
        },
        {
          "content": "```solidity\n155: \n156:         \n157:         bytes memory initializerPayload = abi.encodeCall(\n158:             ISafe.setup, // <= FOUND 'ISafe.'\n159:             (\n160:                 \n161:                 owners,\n162:                 \n163:                 threshold,\n164:                 \n165:                 address(this),\n166:                 \n167:                 data,\n168:                 \n169:                 address(fallbackHandler),\n170:                 \n171:                 address(0),\n172:                 \n173:                 0,\n174:                 \n175:                 payable(address(0))\n176:             )\n177:         );\n\n```\n",
          "loc": [
            "[155](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L155-L158)"
          ]
        },
        {
          "content": "```solidity\n774: \n775:         \n776:         validOrderMagicValue = ZoneInterface.validateOrder.selector; // <= FOUND 'ZoneInterface.'\n\n```\n",
          "loc": [
            "[774](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L774-L776)"
          ]
        },
        {
          "content": "```solidity\n309: \n324:     function checkTransaction(\n325:         address to,\n326:         uint256 value,\n327:         bytes memory data,\n328:         Enum.Operation operation, // <= FOUND 'Enum.'\n329:         uint256,\n330:         uint256,\n331:         uint256,\n332:         address,\n333:         address payable,\n334:         bytes memory,\n335:         address\n336:     ) external override {\n\n```\n",
          "loc": [
            "[309](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L309-L328)"
          ]
        },
        {
          "content": "```solidity\n324:         \n325:         \n326:         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) { // <= FOUND 'Enum.'\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L324-L326)"
          ]
        },
        {
          "content": "```solidity\n278:         if (action_ == Actions.InstallModule) { // <= FOUND 'Actions.'\n\n```\n",
          "loc": [
            "[278](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L278-L278)"
          ]
        },
        {
          "content": "```solidity\n282:         } else if (action_ == Actions.UpgradeModule) { // <= FOUND 'Actions.'\n\n```\n",
          "loc": [
            "[282](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L282-L282)"
          ]
        },
        {
          "content": "```solidity\n286:         } else if (action_ == Actions.ActivatePolicy) { // <= FOUND 'Actions.'\n\n```\n",
          "loc": [
            "[286](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L286-L286)"
          ]
        },
        {
          "content": "```solidity\n289:         } else if (action_ == Actions.DeactivatePolicy) { // <= FOUND 'Actions.'\n\n```\n",
          "loc": [
            "[289](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L289-L289)"
          ]
        },
        {
          "content": "```solidity\n292:         } else if (action_ == Actions.MigrateKernel) { // <= FOUND 'Actions.'\n\n```\n",
          "loc": [
            "[292](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L292-L292)"
          ]
        },
        {
          "content": "```solidity\n295:         } else if (action_ == Actions.ChangeExecutor) { // <= FOUND 'Actions.'\n\n```\n",
          "loc": [
            "[295](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L295-L295)"
          ]
        },
        {
          "content": "```solidity\n297:         } else if (action_ == Actions.ChangeAdmin) { // <= FOUND 'Actions.'\n\n```\n",
          "loc": [
            "[297](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L297-L297)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Try catch statement without human readable error",
      "description": "In Solidity, the `try-catch` statement is used for handling exceptions in external function calls and contract creation. However, when a `try-catch` block doesn't include a catch for specific human-readable errors (using `catch Error(string memory reason)`), it can miss catching exceptions that provide explanatory error messages. This lack of detailed error handling could hinder debugging and obscure the reasons behind transaction failures. To address this, it's recommended to include a catch block specifically for `Error` to capture and handle these descriptive error messages effectively. This practice enhances the contract's robustness by providing clearer insights into why certain operations fail, thereby improving maintainability and troubleshooting.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n507:             } catch Panic(uint256 errorCode) { // <= FOUND\n\n```\n",
          "loc": [
            "[507](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L507-L507)"
          ]
        },
        {
          "content": "```solidity\n515:             } catch (bytes memory revertData) { // <= FOUND\n\n```\n",
          "loc": [
            "[515](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L515-L515)"
          ]
        },
        {
          "content": "```solidity\n507:         } catch Panic(uint256 errorCode) { // <= FOUND\n\n```\n",
          "loc": [
            "[507](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L507-L507)"
          ]
        },
        {
          "content": "```solidity\n515:         } catch (bytes memory revertData) { // <= FOUND\n\n```\n",
          "loc": [
            "[515](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L515-L515)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Try catch statement with declared Error consumes more gas",
      "description": "Using a try-catch statement with a declared Error in Solidity can lead to increased gas consumption. This is because the contract must handle additional logic to catch specific error types, including human-readable error messages. When an Error is caught, the contract processes the string message associated with it, which adds to the gas cost due to the handling and storage of this string data. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n496: \n497:             \n498:             try\n499:                 IHook(target).onStart(\n500:                     rentalWallet,\n501:                     offer.token,\n502:                     offer.identifier,\n503:                     offer.amount,\n504:                     hooks[i].extraData\n505:                 )\n506:             {} catch Error(string memory revertReason) { // <= FOUND\n\n```\n",
          "loc": [
            "[496](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L496-L506)"
          ]
        },
        {
          "content": "```solidity\n167:         \n168:         try IHook(hook).onTransaction(safe, to, value, data) {} catch Error( // <= FOUND\n\n```\n",
          "loc": [
            "[167](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L167-L168)"
          ]
        },
        {
          "content": "```solidity\n226: \n227:             \n228:             try\n229:                 IHook(target).onStop(\n230:                     rentalWallet,\n231:                     item.token,\n232:                     item.identifier,\n233:                     item.amount,\n234:                     hooks[i].extraData\n235:                 )\n236:             {} catch Error(string memory revertReason) { // <= FOUND\n\n```\n",
          "loc": [
            "[226](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L226-L236)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Avoid declaring variables with the names of defined functions within the project",
      "description": "Having such variables can create confusion in both developers and in users of the project. Consider renaming these variables to improve code clarity.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n405: \n406:         \n407:         uint256 skimmedBalance = trueBalance - syncedBalance; // <= FOUND\n\n```\n",
          "loc": [
            "[407](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L407-L407)"
          ]
        },
        {
          "content": "```solidity\n32: \n44:     function deploy(\n45:         bytes32 salt,\n46:         bytes memory initCode\n47:     ) external payable returns (address deploymentAddress) { // <= FOUND\n\n```\n",
          "loc": [
            "[47](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L47-L47)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Reserved keyword 'error' used as a variable/object name",
      "description": "Since solidity version 0.8.4, 'error' has been reserved as a keyword and thus should not be used as a variable name.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n507:             } catch Panic(uint256 errorCode) { // <= FOUND\n\n```\n",
          "loc": [
            "[507](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L507-L507)"
          ]
        },
        {
          "content": "```solidity\n507:         } catch Panic(uint256 errorCode) { // <= FOUND\n\n```\n",
          "loc": [
            "[507](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L507-L507)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Avoid caching global vars used once within the function",
      "description": "If a cached variable is not used many times, it can be cheaper to call the global var directly.",
      "gasSavings": 12,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23:         original = address(this); // <= FOUND\n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L23-L23)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "All verbatim blocks are considered identical by deduplicator and can incorrectly be unified",
      "description": "The Solidity Team reported a bug on October 24, 2023, affecting Yul code using the verbatim builtin, specifically in the Block Deduplicator optimizer step. This bug, present since Solidity version 0.8.5, caused incorrect deduplication of verbatim assembly items surrounded by identical opcodes, considering them identical regardless of their data. The bug was confined to pure Yul compilation with optimization enabled and was unlikely to be exploited as an attack vector. The conditions triggering the bug were very specific, and its occurrence was deemed to have a low likelihood. The bug was rated with an overall low score due to these factors. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n2: pragma solidity ^0.8.20; // <= FOUND\n\n```\n",
          "loc": [
            "[2](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L2-L2)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "ERC777 tokens can introduce reentrancy risks",
      "description": "ERC777 is an advanced token standard that introduces hooks, allowing operators to execute additional logic during transfers. While this feature offers greater flexibility, it also opens up the possibility of reentrancy attacks. Specifically, when tokens are sent, the receiving contract's `tokensReceived` hook gets called, and this external call can execute arbitrary code. An attacker can exploit this feature to re-enter the original function, potentially leading to double-spending or other types of financial manipulation.\n\nTo mitigate reentrancy risks with ERC777, it's crucial to adopt established security measures, such as utilizing reentrancy guards or following the check-effects-interactions pattern. Some developers opt to stick with the simpler ERC20 standard, which does not have these hooks, to minimize this risk. If you do choose to use ERC777, extreme caution and thorough auditing are advised to secure against potential reentrancy vulnerabilities.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n32:     function _transferERC721(Item memory item, address recipient) private { // <= FOUND\n33:         IERC721(item.token).safeTransferFrom(address(this), recipient, item.identifier); // <= FOUND\n34:     }\n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L32-L33)"
          ]
        },
        {
          "content": "```solidity\n42:     function _transferERC1155(Item memory item, address recipient) private { // <= FOUND\n43:         IERC1155(item.token).safeTransferFrom(\n44:             address(this),\n45:             recipient,\n46:             item.identifier,\n47:             item.amount,\n48:             \"\"\n49:         );\n50:     }\n\n```\n",
          "loc": [
            "[42](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L42-L42)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Add inline comments for unnamed variables in function declarations",
      "description": "Unnamed variables in function declarations can confuse developers. To enhance clarity, add inline comments next to each unnamed variable. E.g address, -> address /* to */,",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n309:     function checkTransaction(\n310:         address to,\n311:         uint256 value,\n312:         bytes memory data,\n313:         Enum.Operation operation,\n314:         uint256, // <= FOUND\n315:         uint256, // <= FOUND\n316:         uint256, // <= FOUND\n317:         address, // <= FOUND\n318:         address payable,\n319:         bytes memory,\n320:         address\n321:     ) external override \n\n```\n",
          "loc": [
            "[314](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L314-L317)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Public variable declarations should have NatSpec descriptions",
      "description": "Public variable declarations in smart contracts should ideally be accompanied by NatSpec comments to enhance code readability and provide clear documentation. NatSpec (Natural Language Specification) is a standard for writing comments in Ethereum smart contracts that can generate user-friendly documentation, improving the transparency of the contract's functionality. This is particularly crucial for public variables, as they are accessible externally, and understanding their role and impact is vital for both developers and users interacting with the contract",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n35:     TokenCallbackHandler public immutable fallbackHandler; // <= FOUND\n36:     SafeProxyFactory public immutable safeProxyFactory; // <= FOUND\n37:     SafeL2 public immutable safeSingleton; // <= FOUND\n\n```\n",
          "loc": [
            "[35](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L35-L37)"
          ]
        },
        {
          "content": "```solidity\n53:     Storage public STORE; // <= FOUND\n54:     PaymentEscrow public ESCRW; // <= FOUND\n55: \n\n```\n",
          "loc": [
            "[53](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L53-L54)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "No @inheritdoc on override functions",
      "description": "In Solidity, using `@inheritdoc` on overridden functions is crucial for maintaining comprehensive and understandable NatSpec documentation. It ensures that when a function overrides an external interface or contract function, the original documentation is preserved. This not only helps developers understand the purpose and usage of the function but also aids in keeping documentation consistent and accurate across different versions of the codebase. Neglecting to use `@inheritdoc` can lead to incomplete or confusing documentation, making code maintenance and usage more challenging.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n96:     function VERSION() external pure override returns (uint8 major, uint8 minor)  // <= FOUND\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n103:     function KEYCODE() public pure override returns (Keycode)  // <= FOUND\n\n```\n",
          "loc": [
            "[103](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n733:     function validateOrder(\n734:         ZoneParameters calldata zoneParams\n735:     ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue)  // <= FOUND\n\n```\n",
          "loc": [
            "[733](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733-L735)"
          ]
        },
        {
          "content": "```solidity\n309:     function checkTransaction(\n310:         address to,\n311:         uint256 value,\n312:         bytes memory data,\n313:         Enum.Operation operation,\n314:         uint256,\n315:         uint256,\n316:         uint256,\n317:         address,\n318:         address payable,\n319:         bytes memory,\n320:         address\n321:     ) external override  // <= FOUND\n\n```\n",
          "loc": [
            "[309](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L309-L321)"
          ]
        },
        {
          "content": "```solidity\n353:     function checkAfterExecution(bytes32 txHash, bool success) external override  // <= FOUND\n\n```\n",
          "loc": [
            "[353](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L353-L353)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @author is missing from contract",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23: contract PaymentEscrowBase \n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase \n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n14: contract StorageBase \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase \n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n15: contract Admin is Policy \n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator \n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n22: contract Factory is Policy \n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard \n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator \n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        },
        {
          "content": "```solidity\n14: contract Create2Deployer \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n206: contract Kernel \n\n```\n",
          "loc": [
            "[206](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L206-L206)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev is missing from contract",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23: contract PaymentEscrowBase \n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase \n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n14: contract StorageBase \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase \n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n15: contract Admin is Policy \n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator \n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n22: contract Factory is Policy \n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard \n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator \n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        },
        {
          "content": "```solidity\n14: contract Create2Deployer \n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n206: contract Kernel \n\n```\n",
          "loc": [
            "[206](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L206-L206)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @author is missing from abstract",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n12: abstract contract Accumulator \n\n```\n",
          "loc": [
            "[12](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L12-L12)"
          ]
        },
        {
          "content": "```solidity\n15: abstract contract Reclaimer \n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n21: abstract contract Signer \n\n```\n",
          "loc": [
            "[21](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L21-L21)"
          ]
        },
        {
          "content": "```solidity\n23: abstract contract KernelAdapter \n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n64: abstract contract Module is KernelAdapter \n\n```\n",
          "loc": [
            "[64](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L64-L64)"
          ]
        },
        {
          "content": "```solidity\n114: abstract contract Policy is KernelAdapter \n\n```\n",
          "loc": [
            "[114](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L114-L114)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev is missing from abstract",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n12: abstract contract Accumulator \n\n```\n",
          "loc": [
            "[12](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L12-L12)"
          ]
        },
        {
          "content": "```solidity\n15: abstract contract Reclaimer \n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n21: abstract contract Signer \n\n```\n",
          "loc": [
            "[21](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L21-L21)"
          ]
        },
        {
          "content": "```solidity\n23: abstract contract KernelAdapter \n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n64: abstract contract Module is KernelAdapter \n\n```\n",
          "loc": [
            "[64](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L64-L64)"
          ]
        },
        {
          "content": "```solidity\n114: abstract contract Policy is KernelAdapter \n\n```\n",
          "loc": [
            "[114](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L114-L114)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @params comments are missing from modifier",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n130:     modifier onlyRole(bytes32 role_) \n\n```\n",
          "loc": [
            "[130](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L130-L130)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice comments are missing from modifier",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n40:     modifier onlyKernel() \n\n```\n",
          "loc": [
            "[40](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L40-L40)"
          ]
        },
        {
          "content": "```solidity\n77:     modifier permissioned() \n\n```\n",
          "loc": [
            "[77](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L77-L77)"
          ]
        },
        {
          "content": "```solidity\n130:     modifier onlyRole(bytes32 role_) \n\n```\n",
          "loc": [
            "[130](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L130-L130)"
          ]
        },
        {
          "content": "```solidity\n254:     modifier onlyExecutor() \n\n```\n",
          "loc": [
            "[254](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L254-L254)"
          ]
        },
        {
          "content": "```solidity\n262:     modifier onlyAdmin() \n\n```\n",
          "loc": [
            "[262](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L262-L262)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @dev comments are missing from function",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n86:     function MODULE_PROXY_INSTANTIATION(\n87:         Kernel kernel_\n88:     ) external onlyByProxy onlyUninitialized \n\n```\n",
          "loc": [
            "[86](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L86-L86)"
          ]
        },
        {
          "content": "```solidity\n96:     function VERSION() external pure override returns (uint8 major, uint8 minor) \n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n103:     function KEYCODE() public pure override returns (Keycode) \n\n```\n",
          "loc": [
            "[103](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n320:     function settlePayment(RentalOrder calldata order) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[320](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L320-L320)"
          ]
        },
        {
          "content": "```solidity\n337:     function settlePaymentBatch(\n338:         RentalOrder[] calldata orders\n339:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[337](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L337-L337)"
          ]
        },
        {
          "content": "```solidity\n361:     function increaseDeposit(\n362:         address token,\n363:         uint256 amount\n364:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[361](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L361-L361)"
          ]
        },
        {
          "content": "```solidity\n380:     function setFee(uint256 feeNumerator) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[380](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L380-L380)"
          ]
        },
        {
          "content": "```solidity\n397:     function skim(address token, address to) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[397](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L397-L397)"
          ]
        },
        {
          "content": "```solidity\n360:     function upgrade(address newImplementation) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[360](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L360-L360)"
          ]
        },
        {
          "content": "```solidity\n369:     function freeze() external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[369](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L369-L369)"
          ]
        },
        {
          "content": "```solidity\n118:     function isRentedOut(\n119:         address recipient,\n120:         address token,\n121:         uint256 identifier\n122:     ) external view returns (bool) \n\n```\n",
          "loc": [
            "[118](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L118-L118)"
          ]
        },
        {
          "content": "```solidity\n135:     function contractToHook(address to) external view returns (address) \n\n```\n",
          "loc": [
            "[135](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L135-L135)"
          ]
        },
        {
          "content": "```solidity\n149:     function hookOnTransaction(address hook) external view returns (bool) \n\n```\n",
          "loc": [
            "[149](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L149-L149)"
          ]
        },
        {
          "content": "```solidity\n159:     function hookOnStart(address hook) external view returns (bool) \n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n169:     function hookOnStop(address hook) external view returns (bool) \n\n```\n",
          "loc": [
            "[169](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L169-L169)"
          ]
        },
        {
          "content": "```solidity\n189:     function addRentals(\n190:         bytes32 orderHash,\n191:         RentalAssetUpdate[] memory rentalAssetUpdates\n192:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[189](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L189-L189)"
          ]
        },
        {
          "content": "```solidity\n216:     function removeRentals(\n217:         bytes32 orderHash,\n218:         RentalAssetUpdate[] calldata rentalAssetUpdates\n219:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[216](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L216-L216)"
          ]
        },
        {
          "content": "```solidity\n244:     function removeRentalsBatch(\n245:         bytes32[] calldata orderHashes,\n246:         RentalAssetUpdate[] calldata rentalAssetUpdates\n247:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[244](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L244-L244)"
          ]
        },
        {
          "content": "```solidity\n274:     function addRentalSafe(address safe) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[274](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L274-L274)"
          ]
        },
        {
          "content": "```solidity\n294:     function updateHookPath(address to, address hook) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[294](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L294-L294)"
          ]
        },
        {
          "content": "```solidity\n313:     function updateHookStatus(\n314:         address hook,\n315:         uint8 bitmap\n316:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[313](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n334:     function toggleWhitelistDelegate(\n335:         address delegate,\n336:         bool isEnabled\n337:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[334](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L334-L334)"
          ]
        },
        {
          "content": "```solidity\n347:     function toggleWhitelistExtension(\n348:         address extension,\n349:         bool isEnabled\n350:     ) external onlyByProxy permissioned \n\n```\n",
          "loc": [
            "[347](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L347-L347)"
          ]
        },
        {
          "content": "```solidity\n71:     function reclaimRentalOrder(RentalOrder calldata rentalOrder) external \n\n```\n",
          "loc": [
            "[71](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L71-L71)"
          ]
        },
        {
          "content": "```solidity\n73:     function configureDependencies()\n74:         external\n75:         override\n76:         onlyKernel\n77:         returns (Keycode[] memory dependencies)\n78:     \n\n```\n",
          "loc": [
            "[73](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L73-L73)"
          ]
        },
        {
          "content": "```solidity\n94:     function requestPermissions()\n95:         external\n96:         view\n97:         override\n98:         onlyKernel\n99:         returns (Permissions[] memory requests)\n100:     \n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L94-L94)"
          ]
        },
        {
          "content": "```solidity\n99:     function toggleWhitelistDelegate(\n100:         address delegate,\n101:         bool isEnabled\n102:     ) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[99](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L99-L99)"
          ]
        },
        {
          "content": "```solidity\n113:     function toggleWhitelistExtension(\n114:         address extension,\n115:         bool isEnabled\n116:     ) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[113](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n126:     function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n134:     function freezeStorage() external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[134](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L134-L134)"
          ]
        },
        {
          "content": "```solidity\n144:     function upgradePaymentEscrow(\n145:         address newImplementation\n146:     ) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[144](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L144-L144)"
          ]
        },
        {
          "content": "```solidity\n154:     function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[154](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L154-L154)"
          ]
        },
        {
          "content": "```solidity\n164:     function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[164](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L164-L164)"
          ]
        },
        {
          "content": "```solidity\n173:     function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") \n\n```\n",
          "loc": [
            "[173](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L173-L173)"
          ]
        },
        {
          "content": "```solidity\n117:     function domainSeparator() external view returns (bytes32) \n\n```\n",
          "loc": [
            "[117](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n126:     function getRentalOrderHash(\n127:         RentalOrder memory order\n128:     ) external view returns (bytes32) \n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n137:     function getRentPayloadHash(\n138:         RentPayload memory payload\n139:     ) external view returns (bytes32) \n\n```\n",
          "loc": [
            "[137](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L137-L137)"
          ]
        },
        {
          "content": "```solidity\n148:     function getOrderMetadataHash(\n149:         OrderMetadata memory metadata\n150:     ) external view returns (bytes32) \n\n```\n",
          "loc": [
            "[148](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L148-L148)"
          ]
        },
        {
          "content": "```solidity\n733:     function validateOrder(\n734:         ZoneParameters calldata zoneParams\n735:     ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue) \n\n```\n",
          "loc": [
            "[733](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733-L733)"
          ]
        },
        {
          "content": "```solidity\n122:     function initializeRentalSafe(address _stopPolicy, address _guardPolicy) external \n\n```\n",
          "loc": [
            "[122](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L122-L122)"
          ]
        },
        {
          "content": "```solidity\n138:     function deployRentalSafe(\n139:         address[] calldata owners,\n140:         uint256 threshold\n141:     ) external returns (address safe) \n\n```\n",
          "loc": [
            "[138](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138-L138)"
          ]
        },
        {
          "content": "```solidity\n309:     function checkTransaction(\n310:         address to,\n311:         uint256 value,\n312:         bytes memory data,\n313:         Enum.Operation operation,\n314:         uint256,\n315:         uint256,\n316:         uint256,\n317:         address,\n318:         address payable,\n319:         bytes memory,\n320:         address\n321:     ) external override \n\n```\n",
          "loc": [
            "[309](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L309-L309)"
          ]
        },
        {
          "content": "```solidity\n353:     function checkAfterExecution(bytes32 txHash, bool success) external override \n\n```\n",
          "loc": [
            "[353](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L353-L353)"
          ]
        },
        {
          "content": "```solidity\n362:     function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") \n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L362-L362)"
          ]
        },
        {
          "content": "```solidity\n373:     function updateHookStatus(\n374:         address hook,\n375:         uint8 bitmap\n376:     ) external onlyRole(\"GUARD_ADMIN\") \n\n```\n",
          "loc": [
            "[373](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L373-L373)"
          ]
        },
        {
          "content": "```solidity\n265:     function stopRent(RentalOrder calldata order) external \n\n```\n",
          "loc": [
            "[265](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265-L265)"
          ]
        },
        {
          "content": "```solidity\n313:     function stopRentBatch(RentalOrder[] calldata orders) external \n\n```\n",
          "loc": [
            "[313](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L313-L313)"
          ]
        },
        {
          "content": "```solidity\n32:     function deploy(\n33:         bytes32 salt,\n34:         bytes memory initCode\n35:     ) external payable returns (address deploymentAddress) \n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L32-L32)"
          ]
        },
        {
          "content": "```solidity\n84:     function getCreate2Address(\n85:         bytes32 salt,\n86:         bytes memory initCode\n87:     ) public view returns (address) \n\n```\n",
          "loc": [
            "[84](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L84-L84)"
          ]
        },
        {
          "content": "```solidity\n107:     function generateSaltWithSender(\n108:         address sender,\n109:         bytes12 data\n110:     ) public pure returns (bytes32 salt) \n\n```\n",
          "loc": [
            "[107](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L107-L107)"
          ]
        },
        {
          "content": "```solidity\n54:     function changeKernel(Kernel newKernel_) external onlyKernel \n\n```\n",
          "loc": [
            "[54](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L54-L54)"
          ]
        },
        {
          "content": "```solidity\n100:     function VERSION() external pure virtual returns (uint8 major, uint8 minor) \n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L100-L100)"
          ]
        },
        {
          "content": "```solidity\n106:     function INIT() external virtual onlyKernel \n\n```\n",
          "loc": [
            "[106](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L106-L106)"
          ]
        },
        {
          "content": "```solidity\n148:     function configureDependencies()\n149:         external\n150:         virtual\n151:         onlyKernel\n152:         returns (Keycode[] memory dependencies)\n153:     \n\n```\n",
          "loc": [
            "[148](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L148-L148)"
          ]
        },
        {
          "content": "```solidity\n166:     function requestPermissions()\n167:         external\n168:         view\n169:         virtual\n170:         onlyKernel\n171:         returns (Permissions[] memory requests)\n172:     \n\n```\n",
          "loc": [
            "[166](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L166-L166)"
          ]
        },
        {
          "content": "```solidity\n192:     function setActiveStatus(bool activate_) external onlyKernel \n\n```\n",
          "loc": [
            "[192](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L192-L192)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice comments are missing from function",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n88:     function _calculateFee(uint256 amount) internal view returns (uint256) \n\n```\n",
          "loc": [
            "[88](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L88-L88)"
          ]
        },
        {
          "content": "```solidity\n100:     function _safeTransfer(address token, address to, uint256 value) internal \n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L100-L100)"
          ]
        },
        {
          "content": "```solidity\n132:     function _calculatePaymentProRata(\n133:         uint256 amount,\n134:         uint256 elapsedTime,\n135:         uint256 totalTime\n136:     ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) \n\n```\n",
          "loc": [
            "[132](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L132-L132)"
          ]
        },
        {
          "content": "```solidity\n159:     function _settlePaymentProRata(\n160:         address token,\n161:         uint256 amount,\n162:         address lender,\n163:         address renter,\n164:         uint256 elapsedTime,\n165:         uint256 totalTime\n166:     ) internal \n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n190:     function _settlePaymentInFull(\n191:         address token,\n192:         uint256 amount,\n193:         SettleTo settleTo,\n194:         address lender,\n195:         address renter\n196:     ) internal \n\n```\n",
          "loc": [
            "[190](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L190-L190)"
          ]
        },
        {
          "content": "```solidity\n215:     function _settlePayment(\n216:         Item[] calldata items,\n217:         OrderType orderType,\n218:         address lender,\n219:         address renter,\n220:         uint256 start,\n221:         uint256 end\n222:     ) internal \n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L215-L215)"
          ]
        },
        {
          "content": "```solidity\n292:     function _decreaseDeposit(address token, uint256 amount) internal \n\n```\n",
          "loc": [
            "[292](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L292-L292)"
          ]
        },
        {
          "content": "```solidity\n304:     function _increaseDeposit(address token, uint256 amount) internal \n\n```\n",
          "loc": [
            "[304](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L304-L304)"
          ]
        },
        {
          "content": "```solidity\n32:     function _insert(\n33:         bytes memory rentalAssets,\n34:         RentalId rentalId,\n35:         uint256 rentalAssetAmount\n36:     ) internal pure \n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L32-L32)"
          ]
        },
        {
          "content": "```solidity\n96:     function _convertToStatic(\n97:         bytes memory rentalAssetUpdates\n98:     ) internal pure returns (RentalAssetUpdate[] memory updates) \n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n32:     function _transferERC721(Item memory item, address recipient) private \n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L32-L32)"
          ]
        },
        {
          "content": "```solidity\n42:     function _transferERC1155(Item memory item, address recipient) private \n\n```\n",
          "loc": [
            "[42](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L42-L42)"
          ]
        },
        {
          "content": "```solidity\n76:     function _validateFulfiller(\n77:         address intendedFulfiller,\n78:         address actualFulfiller\n79:     ) internal pure \n\n```\n",
          "loc": [
            "[76](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L76-L76)"
          ]
        },
        {
          "content": "```solidity\n94:     function _validateProtocolSignatureExpiration(uint256 expiration) internal view \n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L94-L94)"
          ]
        },
        {
          "content": "```solidity\n107:     function _recoverSignerFromPayload(\n108:         bytes32 payloadHash,\n109:         bytes memory signature\n110:     ) internal view returns (address) \n\n```\n",
          "loc": [
            "[107](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L107-L107)"
          ]
        },
        {
          "content": "```solidity\n125:     function _deriveItemHash(Item memory item) internal view returns (bytes32) \n\n```\n",
          "loc": [
            "[125](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L125-L125)"
          ]
        },
        {
          "content": "```solidity\n147:     function _deriveHookHash(Hook memory hook) internal view returns (bytes32) \n\n```\n",
          "loc": [
            "[147](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L147-L147)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) \n\n```\n",
          "loc": [
            "[162](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L162-L162)"
          ]
        },
        {
          "content": "```solidity\n204:     function _deriveOrderFulfillmentHash(\n205:         OrderFulfillment memory fulfillment\n206:     ) internal view returns (bytes32) \n\n```\n",
          "loc": [
            "[204](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L204-L204)"
          ]
        },
        {
          "content": "```solidity\n218:     function _deriveOrderMetadataHash(\n219:         OrderMetadata memory metadata\n220:     ) internal view returns (bytes32) \n\n```\n",
          "loc": [
            "[218](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L218-L218)"
          ]
        },
        {
          "content": "```solidity\n248:     function _deriveRentPayloadHash(\n249:         RentPayload memory payload\n250:     ) internal view returns (bytes32) \n\n```\n",
          "loc": [
            "[248](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L248-L248)"
          ]
        },
        {
          "content": "```solidity\n273:     function _deriveDomainSeparator(\n274:         bytes32 _eip712DomainTypeHash,\n275:         bytes32 _nameHash,\n276:         bytes32 _versionHash\n277:     ) internal view virtual returns (bytes32) \n\n```\n",
          "loc": [
            "[273](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L273-L273)"
          ]
        },
        {
          "content": "```solidity\n298:     function _deriveTypehashes()\n299:         internal\n300:         view\n301:         returns (\n302:             bytes32 nameHash,\n303:             bytes32 versionHash,\n304:             bytes32 eip712DomainTypehash,\n305:             bytes32 domainSeparator\n306:         )\n307:     \n\n```\n",
          "loc": [
            "[298](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L298-L298)"
          ]
        },
        {
          "content": "```solidity\n339:     function _deriveRentalTypehashes()\n340:         internal\n341:         pure\n342:         returns (\n343:             bytes32 itemTypeHash,\n344:             bytes32 hookTypeHash,\n345:             bytes32 rentalOrderTypeHash,\n346:             bytes32 orderFulfillmentTypeHash,\n347:             bytes32 orderMetadataTypeHash,\n348:             bytes32 rentPayloadTypeHash\n349:         )\n350:     \n\n```\n",
          "loc": [
            "[339](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L339-L339)"
          ]
        },
        {
          "content": "```solidity\n165:     function _emitRentalOrderStarted(\n166:         RentalOrder memory order,\n167:         bytes32 orderHash,\n168:         bytes memory extraData\n169:     ) internal \n\n```\n",
          "loc": [
            "[165](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L165-L165)"
          ]
        },
        {
          "content": "```solidity\n195:     function _processBaseOrderOffer(\n196:         Item[] memory rentalItems,\n197:         SpentItem[] memory offers,\n198:         uint256 startIndex\n199:     ) internal pure \n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L195-L195)"
          ]
        },
        {
          "content": "```solidity\n247:     function _processPayOrderOffer(\n248:         Item[] memory rentalItems,\n249:         SpentItem[] memory offers,\n250:         uint256 startIndex\n251:     ) internal pure \n\n```\n",
          "loc": [
            "[247](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L247-L247)"
          ]
        },
        {
          "content": "```solidity\n326:     function _processBaseOrderConsideration(\n327:         Item[] memory rentalItems,\n328:         ReceivedItem[] memory considerations,\n329:         uint256 startIndex\n330:     ) internal pure \n\n```\n",
          "loc": [
            "[326](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L326-L326)"
          ]
        },
        {
          "content": "```solidity\n367:     function _processPayeeOrderConsideration(\n368:         ReceivedItem[] memory considerations\n369:     ) internal pure \n\n```\n",
          "loc": [
            "[367](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L367-L367)"
          ]
        },
        {
          "content": "```solidity\n411:     function _convertToItems(\n412:         SpentItem[] memory offers,\n413:         ReceivedItem[] memory considerations,\n414:         OrderType orderType\n415:     ) internal pure returns (Item[] memory items) \n\n```\n",
          "loc": [
            "[411](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L411-L411)"
          ]
        },
        {
          "content": "```solidity\n464:     function _addHooks(\n465:         Hook[] memory hooks,\n466:         SpentItem[] memory offerItems,\n467:         address rentalWallet\n468:     ) internal \n\n```\n",
          "loc": [
            "[464](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L464-L464)"
          ]
        },
        {
          "content": "```solidity\n530:     function _rentFromZone(\n531:         RentPayload memory payload,\n532:         SeaportPayload memory seaportPayload\n533:     ) internal \n\n```\n",
          "loc": [
            "[530](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530-L530)"
          ]
        },
        {
          "content": "```solidity\n626:     function _isValidOrderMetadata(\n627:         OrderMetadata memory metadata,\n628:         bytes32 zoneHash\n629:     ) internal view \n\n```\n",
          "loc": [
            "[626](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L626-L626)"
          ]
        },
        {
          "content": "```solidity\n647:     function _isValidSafeOwner(address owner, address safe) internal view \n\n```\n",
          "loc": [
            "[647](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L647-L647)"
          ]
        },
        {
          "content": "```solidity\n666:     function _checkExpectedRecipient(\n667:         ReceivedItem memory execution,\n668:         address expectedRecipient\n669:     ) internal pure \n\n```\n",
          "loc": [
            "[666](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L666-L666)"
          ]
        },
        {
          "content": "```solidity\n691:     function _executionInvariantChecks(\n692:         ReceivedItem[] memory executions,\n693:         address expectedRentalSafe\n694:     ) internal view \n\n```\n",
          "loc": [
            "[691](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L691-L691)"
          ]
        },
        {
          "content": "```solidity\n108:     function _loadValueFromCalldata(\n109:         bytes memory data,\n110:         uint256 offset\n111:     ) private pure returns (bytes32 value) \n\n```\n",
          "loc": [
            "[108](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L108-L108)"
          ]
        },
        {
          "content": "```solidity\n126:     function _revertSelectorOnActiveRental(\n127:         bytes4 selector,\n128:         address safe,\n129:         address token,\n130:         uint256 tokenId\n131:     ) private view \n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n143:     function _revertNonWhitelistedExtension(address extension) private view \n\n```\n",
          "loc": [
            "[143](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L143-L143)"
          ]
        },
        {
          "content": "```solidity\n159:     function _forwardToHook(\n160:         address hook,\n161:         address safe,\n162:         address to,\n163:         uint256 value,\n164:         bytes memory data\n165:     ) private \n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n195:     function _checkTransaction(address from, address to, bytes memory data) private view \n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L195)"
          ]
        },
        {
          "content": "```solidity\n111:     function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal \n\n```\n",
          "loc": [
            "[111](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L111-L111)"
          ]
        },
        {
          "content": "```solidity\n126:     function _validateRentalCanBeStoped(\n127:         OrderType orderType,\n128:         uint256 endTimestamp,\n129:         address expectedLender\n130:     ) internal view \n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n166:     function _reclaimRentedItems(RentalOrder memory order) internal \n\n```\n",
          "loc": [
            "[166](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L166-L166)"
          ]
        },
        {
          "content": "```solidity\n194:     function _removeHooks(\n195:         Hook[] calldata hooks,\n196:         Item[] calldata rentalItems,\n197:         address rentalWallet\n198:     ) internal \n\n```\n",
          "loc": [
            "[194](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L194-L194)"
          ]
        },
        {
          "content": "```solidity\n180:     function getModuleAddress(Keycode keycode_) internal view returns (address) \n\n```\n",
          "loc": [
            "[180](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L180-L180)"
          ]
        },
        {
          "content": "```solidity\n277:     function executeAction(Actions action_, address target_) external onlyExecutor \n\n```\n",
          "loc": [
            "[277](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L277-L277)"
          ]
        },
        {
          "content": "```solidity\n310:     function grantRole(Role role_, address addr_) public onlyAdmin \n\n```\n",
          "loc": [
            "[310](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L310-L310)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin \n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L333)"
          ]
        },
        {
          "content": "```solidity\n356:     function _installModule(Module newModule_) internal \n\n```\n",
          "loc": [
            "[356](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L356-L356)"
          ]
        },
        {
          "content": "```solidity\n383:     function _upgradeModule(Module newModule_) internal \n\n```\n",
          "loc": [
            "[383](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L383-L383)"
          ]
        },
        {
          "content": "```solidity\n418:     function _activatePolicy(Policy policy_) internal \n\n```\n",
          "loc": [
            "[418](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L418-L418)"
          ]
        },
        {
          "content": "```solidity\n457:     function _deactivatePolicy(Policy policy_) internal \n\n```\n",
          "loc": [
            "[457](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L457-L457)"
          ]
        },
        {
          "content": "```solidity\n508:     function _migrateKernel(Kernel newKernel_) internal \n\n```\n",
          "loc": [
            "[508](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L508-L508)"
          ]
        },
        {
          "content": "```solidity\n540:     function _reconfigurePolicies(Keycode keycode_) internal \n\n```\n",
          "loc": [
            "[540](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L540-L540)"
          ]
        },
        {
          "content": "```solidity\n560:     function _setPolicyPermissions(\n561:         Policy policy_,\n562:         Permissions[] memory requests_,\n563:         bool grant_\n564:     ) internal \n\n```\n",
          "loc": [
            "[560](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L560-L560)"
          ]
        },
        {
          "content": "```solidity\n586:     function _pruneFromDependents(Policy policy_) internal \n\n```\n",
          "loc": [
            "[586](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L586-L586)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec @notice comments are missing from constructor",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n79:     constructor(Kernel kernel_) Module(kernel_) \n\n```\n",
          "loc": [
            "[79](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L79-L79)"
          ]
        },
        {
          "content": "```solidity\n22:     constructor() \n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n61:     constructor(Kernel kernel_) Policy(kernel_) \n\n```\n",
          "loc": [
            "[61](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L61-L61)"
          ]
        },
        {
          "content": "```solidity\n61:     constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() \n\n```\n",
          "loc": [
            "[61](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L61-L61)"
          ]
        },
        {
          "content": "```solidity\n49:     constructor(\n50:         Kernel kernel_,\n51:         Stop stopPolicy_,\n52:         Guard guardPolicy_,\n53:         TokenCallbackHandler fallbackHandler_,\n54:         SafeProxyFactory safeProxyFactory_,\n55:         SafeL2 safeSingleton_\n56:     ) Policy(kernel_) \n\n```\n",
          "loc": [
            "[49](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L49-L49)"
          ]
        },
        {
          "content": "```solidity\n52:     constructor(Kernel kernel_) Policy(kernel_) Signer() Reclaimer() \n\n```\n",
          "loc": [
            "[52](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L52-L52)"
          ]
        },
        {
          "content": "```solidity\n79:     constructor(Kernel kernel_) \n\n```\n",
          "loc": [
            "[79](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L79-L79)"
          ]
        },
        {
          "content": "```solidity\n71:     constructor(Kernel kernel_) KernelAdapter(kernel_) \n\n```\n",
          "loc": [
            "[71](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L71-L71)"
          ]
        },
        {
          "content": "```solidity\n242:     constructor(address _executor, address _admin) \n\n```\n",
          "loc": [
            "[242](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L242-L242)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec comments are missing from scope blocks",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n377:         {\n378:             \n379:             bytes memory orderFulfillmentTypeString = abi.encodePacked(\n380:                 \"OrderFulfillment(address recipient)\"\n381:             );\n382: \n383:             \n384:             bytes memory orderMetadataTypeString = abi.encodePacked(\n385:                 \"OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\"\n386:             );\n387: \n388:             \n389:             bytes memory rentPayloadTypeString = abi.encodePacked(\n390:                 \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\"\n391:             );\n392: \n393:             \n394:             rentPayloadTypeHash = keccak256(\n395:                 abi.encodePacked(\n396:                     rentPayloadTypeString,\n397:                     orderMetadataTypeString,\n398:                     orderFulfillmentTypeString\n399:                 )\n400:             );\n401: \n402:             \n403:             orderFulfillmentTypeHash = keccak256(orderFulfillmentTypeString);\n404: \n405:             \n406:             orderMetadataTypeHash = keccak256(orderMetadataTypeString);\n407:         }\n\n```\n",
          "loc": [
            "[377](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L377-L377)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec comments are missing from assembly blocks",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n40:         assembly {\n41:             \n42:             if eq(mload(rentalAssets), 0) {\n43:                 \n44:                 mstore(rentalAssets, 0x20)\n45: \n46:                 \n47:                 mstore(add(0x20, rentalAssets), 0x00)\n48:             }\n49: \n50:             \n51:             \n52:             let newByteDataSize := add(mload(rentalAssets), 0x40)\n53: \n54:             \n55:             let rentalAssetElementPtr := add(rentalAssets, 0x20)\n56: \n57:             \n58:             let elements := add(mload(rentalAssetElementPtr), 1)\n59: \n60:             \n61:             \n62:             \n63:             \n64:             let newItemPosition := add(\n65:                 rentalAssetElementPtr,\n66:                 sub(mul(elements, 0x40), 0x20)\n67:             )\n68: \n69:             \n70:             mstore(rentalAssets, newByteDataSize)\n71: \n72:             \n73:             mstore(rentalAssetElementPtr, elements)\n74: \n75:             \n76:             mstore(newItemPosition, _rentalId)\n77: \n78:             \n79:             mstore(add(newItemPosition, 0x20), rentalAssetAmount)\n80: \n81:             \n82:             \n83:             mstore(0x40, add(newItemPosition, 0x40))\n84:         }\n\n```\n",
          "loc": [
            "[40](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L40-L40)"
          ]
        },
        {
          "content": "```solidity\n104:         assembly {\n105:             \n106:             \n107:             \n108:             \n109:             rentalAssetUpdatePointer := add(0x20, rentalAssetUpdates)\n110: \n111:             \n112:             rentalAssetUpdateLength := mload(rentalAssetUpdatePointer)\n113:         }\n\n```\n",
          "loc": [
            "[104](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L104-L104)"
          ]
        },
        {
          "content": "```solidity\n113:         assembly {\n114:             value := mload(add(data, offset))\n115:         }\n\n```\n",
          "loc": [
            "[113](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n199:         assembly {\n200:             selector := mload(add(data, 0x20))\n201:         }\n\n```\n",
          "loc": [
            "[199](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L199-L199)"
          ]
        },
        {
          "content": "```solidity\n53:         assembly {\n54:             deploymentAddress := create2(\n55:                 \n56:                 callvalue(),\n57:                 \n58:                 add(initCode, 0x20),\n59:                 \n60:                 mload(initCode),\n61:                 \n62:                 salt\n63:             )\n64:         }\n\n```\n",
          "loc": [
            "[53](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L53-L53)"
          ]
        },
        {
          "content": "```solidity\n111:        assembly {\n112:             \n113:             salt := or(\n114:                 \n115:                 shl(0x60, sender),\n116:                 \n117:                 shr(0xA0, data)\n118:             )\n119:         }\n\n```\n",
          "loc": [
            "[111](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L111-L111)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Public functions not used internally can be marked as external to save gas",
      "description": "Public functions that aren't used internally in Solidity contracts should be made external to optimize gas usage and improve contract efficiency. External functions can only be called from outside the contract, and their arguments are directly read from the calldata, which is more gas-efficient than loading them into memory, as is the case for public functions. By using external visibility, developers can reduce gas consumption for external calls and ensure that the contract operates more cost-effectively for users. Moreover, setting the appropriate visibility level for functions also enhances code readability and maintainability, promoting a more secure and well-structured contract design.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n107:     function generateSaltWithSender(\n108:         address sender,\n109:         bytes12 data\n110:     ) public pure returns (bytes32 salt) \n\n```\n",
          "loc": [
            "[107](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L107-L107)"
          ]
        },
        {
          "content": "```solidity\n310:     function grantRole(Role role_, address addr_) public onlyAdmin \n\n```\n",
          "loc": [
            "[310](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L310-L310)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin \n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L333)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Calldata should be used in place of memory function parameters when not mutated",
      "description": "In Solidity, `calldata` should be used in place of `memory` for function parameters when the function is `external`. This is because `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and it's cheaper in terms of gas than `memory`. It's especially efficient for arrays and complex data types. `calldata` provides a gas-efficient way to pass data in external function calls, whereas `memory` is a temporary space that's erased between external function calls. This distinction is crucial for optimizing smart contracts for gas usage and performance.",
      "gasSavings": 13,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n189:     function addRentals(\n190:         bytes32 orderHash, // <= FOUND\n191:         RentalAssetUpdate[] memory rentalAssetUpdates // <= FOUND\n192:     ) external onlyByProxy permissioned {\n193:         \n194:         orders[orderHash] = true; // <= FOUND\n195: \n196:         \n197:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) { // <= FOUND\n198:             RentalAssetUpdate memory asset = rentalAssetUpdates[i]; // <= FOUND\n199: \n200:             \n201:             rentedAssets[asset.rentalId] += asset.amount;\n202:         }\n203:     }\n\n```\n",
          "loc": [
            "[189](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L189-L198)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Nested for loops should be avoided due to high gas costs resulting from O^2 time complexity",
      "description": "In Solidity, avoiding nested for loops is a recommended practice primarily due to the high gas costs associated with them. These loops can lead to quadratic (O^2) time complexity, especially when they iterate over large data sets or perform complex computations. Since every operation in a smart contract consumes gas, and users pay for this gas, optimizing for lower gas usage is crucial. Nested loops, which inherently have higher computational complexity, can significantly increase the gas costs of a contract. To optimize for efficiency, it's advisable to minimize the use of loops, limit their range, and reduce computations within each loop iteration. Alternative patterns like map/filter/reduce might often be cheaper than traditional for loops in terms of gas usage",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n324:        for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n325:             \n326:             _validateRentalCanBeStoped(\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             \n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) { // <= FOUND\n334:                 \n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert(\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             \n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n346: \n347:             \n348:             if (orders[i].hooks.length > 0) { // <= FOUND\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n350:             }\n351: \n352:             \n353:             _reclaimRentedItems(orders[i]);\n354: \n355:             \n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:         }\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L348)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Usage of smaller uint/int types causes overhead",
      "description": "When using a smaller int/uint type it first needs to be converted to it's 258 bit counterpart to be operated, this increases the gass cost and thus should be avoided. However it does make sense to use smaller int/uint values within structs provided you pack the struct properly.",
      "gasSavings": 275,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n96:     function VERSION() external pure override returns (uint8 major, uint8 minor) { // <= FOUND\n97:         return (1, 0);\n98:     }\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L96-L96)"
          ]
        },
        {
          "content": "```solidity\n313:     function updateHookStatus(\n314:         address hook,\n315:         uint8 bitmap // <= FOUND\n316:     ) external onlyByProxy permissioned {\n317:         \n318:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n319: \n320:         \n321:         if (bitmap > uint8(7))\n322:             revert Errors.StorageModule_InvalidHookStatusBitmap(bitmap);\n323: \n324:         \n325:         hookStatus[hook] = bitmap;\n326:     }\n\n```\n",
          "loc": [
            "[315](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L315-L315)"
          ]
        },
        {
          "content": "```solidity\n339:     function _deriveRentalTypehashes()\n340:         internal\n341:         pure\n342:         returns (\n343:             bytes32 itemTypeHash,\n344:             bytes32 hookTypeHash,\n345:             bytes32 rentalOrderTypeHash,\n346:             bytes32 orderFulfillmentTypeHash,\n347:             bytes32 orderMetadataTypeHash,\n348:             bytes32 rentPayloadTypeHash\n349:         )\n350:     {\n351:         \n352:         bytes memory itemTypeString = abi.encodePacked(\n353:             \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\" // <= FOUND\n354:         );\n355: \n356:         \n357:         bytes memory hookTypeString = abi.encodePacked(\n358:             \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n359:         );\n360: \n361:         \n362:         bytes memory rentalOrderTypeString = abi.encodePacked(\n363:             \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\" // <= FOUND\n364:         );\n365: \n366:         \n367:         itemTypeHash = keccak256(itemTypeString);\n368: \n369:         \n370:         hookTypeHash = keccak256(hookTypeString);\n371: \n372:         \n373:         rentalOrderTypeHash = keccak256(\n374:             abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n375:         );\n376: \n377:         {\n378:             \n379:             bytes memory orderFulfillmentTypeString = abi.encodePacked(\n380:                 \"OrderFulfillment(address recipient)\"\n381:             );\n382: \n383:             \n384:             bytes memory orderMetadataTypeString = abi.encodePacked(\n385:                 \"OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\" // <= FOUND\n386:             );\n387: \n388:             \n389:             bytes memory rentPayloadTypeString = abi.encodePacked(\n390:                 \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\"\n391:             );\n392: \n393:             \n394:             rentPayloadTypeHash = keccak256(\n395:                 abi.encodePacked(\n396:                     rentPayloadTypeString,\n397:                     orderMetadataTypeString,\n398:                     orderFulfillmentTypeString\n399:                 )\n400:             );\n401: \n402:             \n403:             orderFulfillmentTypeHash = keccak256(orderFulfillmentTypeString);\n404: \n405:             \n406:             orderMetadataTypeHash = keccak256(orderMetadataTypeString);\n407:         }\n408:     }\n\n```\n",
          "loc": [
            "[353](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L353-L385)"
          ]
        },
        {
          "content": "```solidity\n373:     function updateHookStatus(\n374:         address hook,\n375:         uint8 bitmap // <= FOUND\n376:     ) external onlyRole(\"GUARD_ADMIN\") {\n377:         STORE.updateHookStatus(hook, bitmap);\n378:     }\n\n```\n",
          "loc": [
            "[375](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L375-L375)"
          ]
        },
        {
          "content": "```solidity\n100:     function VERSION() external pure virtual returns (uint8 major, uint8 minor) {} // <= FOUND\n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L100-L100)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use != 0 instead of > 0",
      "description": "Replace spotted instances with != 0 for uints as this uses less gas",
      "gasSavings": 15,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n433: \n434:             \n435:             if (considerations.length > 0) { // <= FOUND\n\n```\n",
          "loc": [
            "[435](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L435-L435)"
          ]
        },
        {
          "content": "```solidity\n442:             \n443:             if (offers.length > 0) { // <= FOUND\n\n```\n",
          "loc": [
            "[443](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L443-L443)"
          ]
        },
        {
          "content": "```solidity\n606: \n607:             \n608:             if (payload.metadata.hooks.length > 0) { // <= FOUND\n\n```\n",
          "loc": [
            "[608](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L608-L608)"
          ]
        },
        {
          "content": "```solidity\n288: \n289:         \n290:         if (order.hooks.length > 0) { // <= FOUND\n\n```\n",
          "loc": [
            "[290](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L290-L290)"
          ]
        },
        {
          "content": "```solidity\n348: \n349:             \n350:             if (orders[i].hooks.length > 0) { // <= FOUND\n\n```\n",
          "loc": [
            "[350](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L350-L350)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Integer increments by one can be unchecked to save on gas fees",
      "description": "Using unchecked increments in Solidity can save on gas fees by bypassing built-in overflow checks, thus optimizing gas usage, but requires careful assessment of potential risks and edge cases to avoid unintended consequences.",
      "gasSavings": 2880,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n215:     function _settlePayment(\n216:         Item[] calldata items,\n217:         OrderType orderType,\n218:         address lender,\n219:         address renter,\n220:         uint256 start,\n221:         uint256 end\n222:     ) internal {\n223:         \n224:         uint256 elapsedTime = block.timestamp - start;\n225:         uint256 totalTime = end - start;\n226: \n227:         \n228:         bool isRentalOver = elapsedTime >= totalTime;\n229: \n230:         \n231:         for (uint256 i = 0; i < items.length; ++i) { // <= FOUND\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n\n```\n",
          "loc": [
            "[231](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L231-L231)"
          ]
        },
        {
          "content": "```solidity\n337:     function settlePaymentBatch(\n338:         RentalOrder[] calldata orders\n339:     ) external onlyByProxy permissioned {\n340:         \n341:         for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n342:             \n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n352:     }\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L341-L341)"
          ]
        },
        {
          "content": "```solidity\n189:     function addRentals(\n190:         bytes32 orderHash,\n191:         RentalAssetUpdate[] memory rentalAssetUpdates\n192:     ) external onlyByProxy permissioned {\n193:         \n194:         orders[orderHash] = true;\n195: \n196:         \n197:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) { // <= FOUND\n198:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n199: \n200:             \n201:             rentedAssets[asset.rentalId] += asset.amount;\n202:         }\n203:     }\n\n```\n",
          "loc": [
            "[197](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n216:     function removeRentals(\n217:         bytes32 orderHash,\n218:         RentalAssetUpdate[] calldata rentalAssetUpdates\n219:     ) external onlyByProxy permissioned {\n220:         \n221:         if (!orders[orderHash]) {\n222:             revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n223:         } else {\n224:             \n225:             delete orders[orderHash];\n226:         }\n227: \n228:         \n229:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) { // <= FOUND\n230:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n231: \n232:             \n233:             rentedAssets[asset.rentalId] -= asset.amount;\n234:         }\n235:     }\n\n```\n",
          "loc": [
            "[229](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L229-L229)"
          ]
        },
        {
          "content": "```solidity\n244:     function removeRentalsBatch(\n245:         bytes32[] calldata orderHashes,\n246:         RentalAssetUpdate[] calldata rentalAssetUpdates\n247:     ) external onlyByProxy permissioned {\n248:         \n249:         for (uint256 i = 0; i < orderHashes.length; ++i) { // <= FOUND\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n258: \n259:         \n260:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) { // <= FOUND\n261:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n262: \n263:             \n264:             rentedAssets[asset.rentalId] -= asset.amount;\n265:         }\n266:     }\n\n```\n",
          "loc": [
            "[249](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L249-L260)"
          ]
        },
        {
          "content": "```solidity\n96:     function _convertToStatic(\n97:         bytes memory rentalAssetUpdates\n98:     ) internal pure returns (RentalAssetUpdate[] memory updates) {\n99:         \n100:         bytes32 rentalAssetUpdatePointer;\n101: \n102:         \n103:         uint256 rentalAssetUpdateLength;\n104:         assembly {\n105:             \n106:             \n107:             \n108:             \n109:             rentalAssetUpdatePointer := add(0x20, rentalAssetUpdates)\n110: \n111:             \n112:             rentalAssetUpdateLength := mload(rentalAssetUpdatePointer)\n113:         }\n114: \n115:         \n116:         updates = new RentalAssetUpdate[](rentalAssetUpdateLength);\n117: \n118:         \n119:         \n120:         for (uint256 i = 0; i < rentalAssetUpdateLength; ++i) { // <= FOUND\n121:             \n122:             RentalId rentalId;\n123:             uint256 amount;\n124: \n125:             \n126:             assembly {\n127:                 \n128:                 \n129:                 \n130:                 \n131:                 let currentElementOffset := add(0x20, mul(i, 0x40))\n132: \n133:                 \n134:                 rentalId := mload(add(rentalAssetUpdatePointer, currentElementOffset))\n135: \n136:                 \n137:                 amount := mload(\n138:                     add(0x20, add(rentalAssetUpdatePointer, currentElementOffset))\n139:                 )\n140:             }\n141: \n142:             \n143:             updates[i] = RentalAssetUpdate(rentalId, amount);\n144:         }\n145:     }\n\n```\n",
          "loc": [
            "[120](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L120-L120)"
          ]
        },
        {
          "content": "```solidity\n71:     function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n72:         \n73:         if (address(this) == original) {\n74:             revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed();\n75:         }\n76: \n77:         \n78:         \n79:         \n80:         if (address(this) != rentalOrder.rentalWallet) {\n81:             revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed(\n82:                 rentalOrder.rentalWallet\n83:             );\n84:         }\n85: \n86:         \n87:         uint256 itemCount = rentalOrder.items.length;\n88: \n89:         \n90:         for (uint256 i = 0; i < itemCount; ++i) { // <= FOUND\n91:             Item memory item = rentalOrder.items[i];\n92: \n93:             \n94:             if (item.itemType == ItemType.ERC721)\n95:                 _transferERC721(item, rentalOrder.lender);\n96: \n97:             \n98:             if (item.itemType == ItemType.ERC1155)\n99:                 _transferERC1155(item, rentalOrder.lender);\n100:         }\n101:     }\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L90-L90)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) { // <= FOUND\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) { // <= FOUND\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)),\n187:                     keccak256(abi.encodePacked(hookHashes)),\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[170](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L170-L176)"
          ]
        },
        {
          "content": "```solidity\n218:     function _deriveOrderMetadataHash(\n219:         OrderMetadata memory metadata\n220:     ) internal view returns (bytes32) {\n221:         \n222:         bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n223: \n224:         \n225:         for (uint256 i = 0; i < metadata.hooks.length; ++i) { // <= FOUND\n226:             \n227:             hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n228:         }\n229: \n230:         \n231:         return\n232:             keccak256(\n233:                 abi.encode(\n234:                     _ORDER_METADATA_TYPEHASH,\n235:                     metadata.rentDuration,\n236:                     keccak256(abi.encodePacked(hookHashes))\n237:                 )\n238:             );\n239:     }\n\n```\n",
          "loc": [
            "[225](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L225-L225)"
          ]
        },
        {
          "content": "```solidity\n195:     function _processBaseOrderOffer(\n196:         Item[] memory rentalItems,\n197:         SpentItem[] memory offers,\n198:         uint256 startIndex\n199:     ) internal pure {\n200:         \n201:         if (offers.length == 0) {\n202:             revert Errors.CreatePolicy_OfferCountZero();\n203:         }\n204: \n205:         \n206:         ItemType itemType;\n207: \n208:         \n209:         for (uint256 i; i < offers.length; ++i) { // <= FOUND\n210:             \n211:             SpentItem memory offer = offers[i];\n212: \n213:             \n214:             if (offer.isERC721()) {\n215:                 itemType = ItemType.ERC721;\n216:             }\n217:             \n218:             else if (offer.isERC1155()) {\n219:                 itemType = ItemType.ERC1155;\n220:             }\n221:             \n222:             else {\n223:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n224:             }\n225: \n226:             \n227:             \n228:             rentalItems[i + startIndex] = Item({\n229:                 itemType: itemType,\n230:                 settleTo: SettleTo.LENDER,\n231:                 token: offer.token,\n232:                 amount: offer.amount,\n233:                 identifier: offer.identifier\n234:             });\n235:         }\n236:     }\n\n```\n",
          "loc": [
            "[209](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L209-L209)"
          ]
        },
        {
          "content": "```solidity\n247:     function _processPayOrderOffer(\n248:         Item[] memory rentalItems,\n249:         SpentItem[] memory offers,\n250:         uint256 startIndex\n251:     ) internal pure {\n252:         \n253:         uint256 totalRentals;\n254:         uint256 totalPayments;\n255: \n256:         \n257:         ItemType itemType;\n258:         SettleTo settleTo;\n259: \n260:         \n261:         for (uint256 i; i < offers.length; ++i) { // <= FOUND\n262:             \n263:             SpentItem memory offer = offers[i];\n264: \n265:             \n266:             if (offer.isERC721()) {\n267:                 \n268:                 \n269:                 itemType = ItemType.ERC721;\n270:                 settleTo = SettleTo.LENDER;\n271: \n272:                 \n273:                 totalRentals++; // <= FOUND\n274:             }\n275:             \n276:             else if (offer.isERC1155()) {\n277:                 \n278:                 \n279:                 itemType = ItemType.ERC1155;\n280:                 settleTo = SettleTo.LENDER;\n281: \n282:                 \n283:                 totalRentals++; // <= FOUND\n284:             }\n285:             \n286:             else if (offer.isERC20()) {\n287:                 \n288:                 \n289:                 itemType = ItemType.ERC20;\n290:                 settleTo = SettleTo.RENTER;\n291: \n292:                 \n293:                 totalPayments++; // <= FOUND\n294:             }\n295:             \n296:             else {\n297:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n298:             }\n299: \n300:             \n301:             rentalItems[i + startIndex] = Item({\n302:                 itemType: itemType,\n303:                 settleTo: settleTo,\n304:                 token: offer.token,\n305:                 amount: offer.amount,\n306:                 identifier: offer.identifier\n307:             });\n308:         }\n309: \n310:         \n311:         if (totalRentals == 0 || totalPayments == 0) {\n312:             revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n313:         }\n314:     }\n\n```\n",
          "loc": [
            "[261](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L261-L293)"
          ]
        },
        {
          "content": "```solidity\n326:     function _processBaseOrderConsideration(\n327:         Item[] memory rentalItems,\n328:         ReceivedItem[] memory considerations,\n329:         uint256 startIndex\n330:     ) internal pure {\n331:         \n332:         if (considerations.length == 0) {\n333:             revert Errors.CreatePolicy_ConsiderationCountZero();\n334:         }\n335: \n336:         \n337:         for (uint256 i; i < considerations.length; ++i) { // <= FOUND\n338:             \n339:             ReceivedItem memory consideration = considerations[i];\n340: \n341:             \n342:             if (!consideration.isERC20()) {\n343:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n344:                     consideration.itemType\n345:                 );\n346:             }\n347: \n348:             \n349:             \n350:             rentalItems[i + startIndex] = Item({\n351:                 itemType: ItemType.ERC20,\n352:                 settleTo: SettleTo.LENDER,\n353:                 token: consideration.token,\n354:                 amount: consideration.amount,\n355:                 identifier: consideration.identifier\n356:             });\n357:         }\n358:     }\n\n```\n",
          "loc": [
            "[337](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L337-L337)"
          ]
        },
        {
          "content": "```solidity\n367:     function _processPayeeOrderConsideration(\n368:         ReceivedItem[] memory considerations\n369:     ) internal pure {\n370:         \n371:         uint256 totalRentals;\n372:         uint256 totalPayments;\n373: \n374:         \n375:         for (uint256 i; i < considerations.length; ++i) { // <= FOUND\n376:             \n377:             ReceivedItem memory consideration = considerations[i];\n378: \n379:             \n380:             if (consideration.isERC20()) {\n381:                 totalPayments++; // <= FOUND\n382:             }\n383:             \n384:             else if (consideration.isRental()) {\n385:                 totalRentals++; // <= FOUND\n386:             }\n387:             \n388:             else {\n389:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n390:                     consideration.itemType\n391:                 );\n392:             }\n393:         }\n394: \n395:         \n396:         if (totalRentals == 0 || totalPayments == 0) {\n397:             revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n398:         }\n399:     }\n\n```\n",
          "loc": [
            "[375](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L375-L385)"
          ]
        },
        {
          "content": "```solidity\n464:     function _addHooks(\n465:         Hook[] memory hooks,\n466:         SpentItem[] memory offerItems,\n467:         address rentalWallet\n468:     ) internal {\n469:         \n470:         address target;\n471:         uint256 itemIndex;\n472:         SpentItem memory offer;\n473: \n474:         \n475:         for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n476:             \n477:             target = hooks[i].target;\n478: \n479:             \n480:             if (!STORE.hookOnStart(target)) {\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             \n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             \n488:             offer = offerItems[itemIndex];\n489: \n490:             \n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             \n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 \n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) {\n508:                 \n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 \n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n514:                 );\n515:             } catch (bytes memory revertData) {\n516:                 \n517:                 revert Errors.Shared_HookFailBytes(revertData);\n518:             }\n519:         }\n520:     }\n\n```\n",
          "loc": [
            "[475](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L475-L475)"
          ]
        },
        {
          "content": "```solidity\n530:     function _rentFromZone(\n531:         RentPayload memory payload,\n532:         SeaportPayload memory seaportPayload\n533:     ) internal {\n534:         \n535:         _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n536: \n537:         \n538:         _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n539: \n540:         \n541:         _executionInvariantChecks(\n542:             seaportPayload.totalExecutions,\n543:             payload.fulfillment.recipient\n544:         );\n545: \n546:         \n547:         \n548:         Item[] memory items = _convertToItems(\n549:             seaportPayload.offer,\n550:             seaportPayload.consideration,\n551:             payload.metadata.orderType\n552:         );\n553: \n554:         \n555:         \n556:         if (\n557:             payload.metadata.orderType.isBaseOrder() ||\n558:             payload.metadata.orderType.isPayOrder()\n559:         ) {\n560:             \n561:             \n562:             \n563:             bytes memory rentalAssetUpdates = new bytes(0);\n564: \n565:             \n566:             \n567:             for (uint256 i; i < items.length; ++i) { // <= FOUND\n568:                 if (items[i].isRental()) {\n569:                     \n570:                     _insert(\n571:                         rentalAssetUpdates,\n572:                         items[i].toRentalId(payload.fulfillment.recipient),\n573:                         items[i].amount\n574:                     );\n575:                 }\n576:             }\n577: \n578:             \n579:             RentalOrder memory order = RentalOrder({\n580:                 seaportOrderHash: seaportPayload.orderHash,\n581:                 items: items,\n582:                 hooks: payload.metadata.hooks,\n583:                 orderType: payload.metadata.orderType,\n584:                 lender: seaportPayload.offerer,\n585:                 renter: payload.intendedFulfiller,\n586:                 rentalWallet: payload.fulfillment.recipient,\n587:                 startTimestamp: block.timestamp,\n588:                 endTimestamp: block.timestamp + payload.metadata.rentDuration\n589:             });\n590: \n591:             \n592:             bytes32 orderHash = _deriveRentalOrderHash(order);\n593: \n594:             \n595:             STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n596: \n597:             \n598:             \n599:             for (uint256 i = 0; i < items.length; ++i) { // <= FOUND\n600:                 if (items[i].isERC20()) {\n601:                     ESCRW.increaseDeposit(items[i].token, items[i].amount);\n602:                 }\n603:             }\n604: \n605:             \n606:             if (payload.metadata.hooks.length > 0) {\n607:                 _addHooks(\n608:                     payload.metadata.hooks,\n609:                     seaportPayload.offer,\n610:                     payload.fulfillment.recipient\n611:                 );\n612:             }\n613: \n614:             \n615:             _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n616:         }\n617:     }\n\n```\n",
          "loc": [
            "[567](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L567-L599)"
          ]
        },
        {
          "content": "```solidity\n691:     function _executionInvariantChecks(\n692:         ReceivedItem[] memory executions,\n693:         address expectedRentalSafe\n694:     ) internal view {\n695:         for (uint256 i = 0; i < executions.length; ++i) { // <= FOUND\n696:             ReceivedItem memory execution = executions[i];\n697: \n698:             \n699:             if (execution.isERC20()) {\n700:                 _checkExpectedRecipient(execution, address(ESCRW));\n701:             }\n702:             \n703:             \n704:             else if (execution.isRental()) {\n705:                 _checkExpectedRecipient(execution, expectedRentalSafe);\n706:             }\n707:             \n708:             else {\n709:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n710:                     execution.itemType\n711:                 );\n712:             }\n713:         }\n714:     }\n\n```\n",
          "loc": [
            "[695](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L695-L695)"
          ]
        },
        {
          "content": "```solidity\n194:     function _removeHooks(\n195:         Hook[] calldata hooks,\n196:         Item[] calldata rentalItems,\n197:         address rentalWallet\n198:     ) internal {\n199:         \n200:         address target;\n201:         uint256 itemIndex;\n202:         Item memory item;\n203: \n204:         \n205:         for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n206:             \n207:             target = hooks[i].target;\n208: \n209:             \n210:             if (!STORE.hookOnStop(target)) {\n211:                 revert Errors.Shared_DisabledHook(target);\n212:             }\n213: \n214:             \n215:             itemIndex = hooks[i].itemIndex;\n216: \n217:             \n218:             item = rentalItems[itemIndex];\n219: \n220:             \n221:             if (!item.isRental()) {\n222:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n223:             }\n224: \n225:             \n226:             try\n227:                 IHook(target).onStop(\n228:                     rentalWallet,\n229:                     item.token,\n230:                     item.identifier,\n231:                     item.amount,\n232:                     hooks[i].extraData\n233:                 )\n234:             {} catch Error(string memory revertReason) {\n235:                 \n236:                 revert Errors.Shared_HookFailString(revertReason);\n237:             } catch Panic(uint256 errorCode) {\n238:                 \n239:                 string memory stringErrorCode = LibString.toString(errorCode);\n240: \n241:                 \n242:                 revert Errors.Shared_HookFailString(\n243:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n244:                 );\n245:             } catch (bytes memory revertData) {\n246:                 \n247:                 revert Errors.Shared_HookFailBytes(revertData);\n248:             }\n249:         }\n250:     }\n\n```\n",
          "loc": [
            "[205](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L205-L205)"
          ]
        },
        {
          "content": "```solidity\n265:     function stopRent(RentalOrder calldata order) external {\n266:         \n267:         _validateRentalCanBeStoped(order.orderType, order.endTimestamp, order.lender);\n268: \n269:         \n270:         \n271:         \n272:         bytes memory rentalAssetUpdates = new bytes(0);\n273: \n274:         \n275:         \n276:         for (uint256 i; i < order.items.length; ++i) { // <= FOUND\n277:             if (order.items[i].isRental()) {\n278:                 \n279:                 _insert(\n280:                     rentalAssetUpdates,\n281:                     order.items[i].toRentalId(order.rentalWallet),\n282:                     order.items[i].amount\n283:                 );\n284:             }\n285:         }\n286: \n287:         \n288:         if (order.hooks.length > 0) {\n289:             _removeHooks(order.hooks, order.items, order.rentalWallet);\n290:         }\n291: \n292:         \n293:         _reclaimRentedItems(order);\n294: \n295:         \n296:         ESCRW.settlePayment(order);\n297: \n298:         \n299:         STORE.removeRentals(\n300:             _deriveRentalOrderHash(order),\n301:             _convertToStatic(rentalAssetUpdates)\n302:         );\n303: \n304:         \n305:         _emitRentalOrderStopped(order.seaportOrderHash, msg.sender);\n306:     }\n\n```\n",
          "loc": [
            "[276](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L276-L276)"
          ]
        },
        {
          "content": "```solidity\n313:     function stopRentBatch(RentalOrder[] calldata orders) external {\n314:         \n315:         bytes32[] memory orderHashes = new bytes32[](orders.length);\n316: \n317:         \n318:         \n319:         \n320:         bytes memory rentalAssetUpdates = new bytes(0);\n321: \n322:         \n323:         \n324:         for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n325:             \n326:             _validateRentalCanBeStoped(\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             \n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) { // <= FOUND\n334:                 \n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert(\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             \n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n346: \n347:             \n348:             if (orders[i].hooks.length > 0) {\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n350:             }\n351: \n352:             \n353:             _reclaimRentedItems(orders[i]);\n354: \n355:             \n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:         }\n358: \n359:         \n360:         ESCRW.settlePaymentBatch(orders);\n361: \n362:         \n363:         STORE.removeRentalsBatch(orderHashes, _convertToStatic(rentalAssetUpdates));\n364:     }\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L333)"
          ]
        },
        {
          "content": "```solidity\n418:     function _activatePolicy(Policy policy_) internal {\n419:         \n420:         if (policy_.isActive())\n421:             revert Errors.Kernel_PolicyAlreadyApproved(address(policy_));\n422: \n423:         \n424:         Permissions[] memory requests = policy_.requestPermissions();\n425:         _setPolicyPermissions(policy_, requests, true);\n426: \n427:         \n428:         activePolicies.push(policy_);\n429: \n430:         \n431:         getPolicyIndex[policy_] = activePolicies.length - 1;\n432: \n433:         \n434:         Keycode[] memory dependencies = policy_.configureDependencies();\n435:         uint256 depLength = dependencies.length;\n436: \n437:         \n438:         for (uint256 i; i < depLength; ++i) { // <= FOUND\n439:             Keycode keycode = dependencies[i];\n440: \n441:             \n442:             moduleDependents[keycode].push(policy_);\n443: \n444:             \n445:             getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n446:         }\n447: \n448:         \n449:         policy_.setActiveStatus(true);\n450:     }\n\n```\n",
          "loc": [
            "[438](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L438-L438)"
          ]
        },
        {
          "content": "```solidity\n508:     function _migrateKernel(Kernel newKernel_) internal {\n509:         uint256 keycodeLen = allKeycodes.length;\n510: \n511:         \n512:         for (uint256 i; i < keycodeLen; ++i) { // <= FOUND\n513:             \n514:             Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n515:             \n516:             module.changeKernel(newKernel_);\n517:         }\n518: \n519:         \n520:         uint256 policiesLen = activePolicies.length;\n521:         for (uint256 j; j < policiesLen; ++j) { // <= FOUND\n522:             \n523:             Policy policy = activePolicies[j];\n524: \n525:             \n526:             policy.setActiveStatus(false);\n527: \n528:             \n529:             policy.changeKernel(newKernel_);\n530:         }\n531:     }\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L512-L521)"
          ]
        },
        {
          "content": "```solidity\n540:     function _reconfigurePolicies(Keycode keycode_) internal {\n541:         \n542:         Policy[] memory dependents = moduleDependents[keycode_];\n543:         uint256 depLength = dependents.length;\n544: \n545:         \n546:         for (uint256 i; i < depLength; ++i) { // <= FOUND\n547:             \n548:             dependents[i].configureDependencies();\n549:         }\n550:     }\n\n```\n",
          "loc": [
            "[546](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L546-L546)"
          ]
        },
        {
          "content": "```solidity\n560:     function _setPolicyPermissions(\n561:         Policy policy_,\n562:         Permissions[] memory requests_,\n563:         bool grant_\n564:     ) internal {\n565:         uint256 reqLength = requests_.length;\n566:         for (uint256 i = 0; i < reqLength; ++i) { // <= FOUND\n567:             \n568:             Permissions memory request = requests_[i];\n569:             modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n570: \n571:             emit Events.PermissionsUpdated(\n572:                 request.keycode,\n573:                 policy_,\n574:                 request.funcSelector,\n575:                 grant_\n576:             );\n577:         }\n578:     }\n\n```\n",
          "loc": [
            "[566](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L566-L566)"
          ]
        },
        {
          "content": "```solidity\n586:     function _pruneFromDependents(Policy policy_) internal {\n587:         \n588:         Keycode[] memory dependencies = policy_.configureDependencies();\n589:         uint256 depcLength = dependencies.length;\n590: \n591:         \n592:         for (uint256 i; i < depcLength; ++i) { // <= FOUND\n593:             \n594:             Keycode keycode = dependencies[i];\n595:             Policy[] storage dependents = moduleDependents[keycode];\n596: \n597:             \n598:             uint256 origIndex = getDependentIndex[keycode][policy_];\n599: \n600:             \n601:             Policy lastPolicy = dependents[dependents.length - 1];\n602: \n603:             \n604:             dependents[origIndex] = lastPolicy;\n605: \n606:             \n607:             \n608:             dependents.pop();\n609: \n610:             \n611:             getDependentIndex[keycode][lastPolicy] = origIndex;\n612: \n613:             \n614:             delete getDependentIndex[keycode][policy_];\n615:         }\n616:     }\n\n```\n",
          "loc": [
            "[592](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L592-L592)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use byte32 in place of string",
      "description": "For strings of 32 char strings and below you can use bytes32 instead as it's more gas efficient",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n25: \n27:     string internal constant _NAME = \"ReNFT-Rentals\"; // <= FOUND\n\n```\n",
          "loc": [
            "[25](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L25-L27)"
          ]
        },
        {
          "content": "```solidity\n26:     string internal constant _VERSION = \"1.0.0\"; // <= FOUND\n\n```\n",
          "loc": [
            "[26](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L26-L26)"
          ]
        },
        {
          "content": "```solidity\n315: \n316:         \n317:         eip712DomainTypehash = keccak256(\n318:             abi.encodePacked(\n319:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\" // <= FOUND\n320:             )\n321:         );\n\n```\n",
          "loc": [
            "[315](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L315-L319)"
          ]
        },
        {
          "content": "```solidity\n512: \n513:                 \n514:                 revert Errors.Shared_HookFailString(\n515:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode) // <= FOUND\n516:                 );\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L512-L515)"
          ]
        },
        {
          "content": "```solidity\n512: \n513:             \n514:             revert Errors.Shared_HookFailString(\n515:                 string.concat(\"Hook reverted: Panic code \", stringErrorCode) // <= FOUND\n516:             );\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L512-L515)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Default bool values are manually reset",
      "description": "Using .delete is better than resetting a Solidity variable to its default value manually because it frees up storage space on the Ethereum blockchain, resulting in gas cost savings. ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin { // <= FOUND\n334:         \n335:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_);\n336: \n337:         \n338:         if (!hasRole[addr_][role_])\n339:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_);\n340: \n341:         \n342:         hasRole[addr_][role_] = false;\n343: \n344:         emit Events.RoleRevoked(role_, addr_);\n345:     }\n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L333)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Default int values are manually reset",
      "description": "Using .delete is better than resetting a Solidity variable to its default value manually because it frees up storage space on the Ethereum blockchain, resulting in gas cost savings.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n19: \n21:     bytes1 constant create2_ff = 0xff; // <= FOUND\n\n```\n",
          "loc": [
            "[19](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L19-L21)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "<= or >= is more efficient than < or > ",
      "description": "Make such found comparisons to the <=/>= equivalent when comparing against integer literals",
      "gasSavings": 6,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n329: \n330:         \n331:         if (data.length < 4) { // <= FOUND\n\n```\n",
          "loc": [
            "[331](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L331-L331)"
          ]
        },
        {
          "content": "```solidity\n382:         \n383:         if (feeNumerator > 10000) { // <= FOUND\n\n```\n",
          "loc": [
            "[383](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L383-L383)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly to check for the zero address",
      "description": "\nUsing assembly for address comparisons in Solidity can save gas because it allows for more direct access to the Ethereum Virtual Machine (EVM), reducing the overhead of higher-level operations. Solidity's high-level abstraction simplifies coding but can introduce additional gas costs. Using assembly for simple operations like address comparisons can be more gas-efficient.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n309:     function checkTransaction(\n310:         address to,\n311:         uint256 value,\n312:         bytes memory data,\n313:         Enum.Operation operation,\n314:         uint256,\n315:         uint256,\n316:         uint256,\n317:         address,\n318:         address payable,\n319:         bytes memory,\n320:         address\n321:     ) external override {\n322:         \n323:         \n324:         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n325:             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n326:         }\n327: \n328:         \n329:         if (data.length < 4) {\n330:             revert Errors.GuardPolicy_FunctionSelectorRequired();\n331:         }\n332: \n333:         \n334:         address hook = STORE.contractToHook(to);\n335:         bool isActive = STORE.hookOnTransaction(hook);\n336: \n337:         \n338:         if (hook != address(0) && isActive) { // <= FOUND\n339:             _forwardToHook(hook, msg.sender, to, value, data);\n340:         }\n341:         \n342:         else {\n343:             _checkTransaction(msg.sender, to, data);\n344:         }\n345:     }\n\n```\n",
          "loc": [
            "[309](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L309-L338)"
          ]
        },
        {
          "content": "```solidity\n180:     function getModuleAddress(Keycode keycode_) internal view returns (address) {\n181:         address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n182:         if (moduleForKeycode == address(0)) // <= FOUND\n183:             revert Errors.Policy_ModuleDoesNotExist(keycode_);\n184:         return moduleForKeycode;\n185:     }\n\n```\n",
          "loc": [
            "[180](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L180-L182)"
          ]
        },
        {
          "content": "```solidity\n356:     function _installModule(Module newModule_) internal {\n357:         \n358:         Keycode keycode = newModule_.KEYCODE();\n359: \n360:         \n361:         if (address(getModuleForKeycode[keycode]) != address(0)) { // <= FOUND\n362:             revert Errors.Kernel_ModuleAlreadyInstalled(keycode);\n363:         }\n364: \n365:         \n366:         getModuleForKeycode[keycode] = newModule_;\n367: \n368:         \n369:         getKeycodeForModule[newModule_] = keycode;\n370: \n371:         \n372:         allKeycodes.push(keycode);\n373: \n374:         \n375:         newModule_.INIT();\n376:     }\n\n```\n",
          "loc": [
            "[356](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L356-L361)"
          ]
        },
        {
          "content": "```solidity\n383:     function _upgradeModule(Module newModule_) internal {\n384:         \n385:         Keycode keycode = newModule_.KEYCODE();\n386: \n387:         \n388:         Module oldModule = getModuleForKeycode[keycode];\n389: \n390:         \n391:         \n392:         if (address(oldModule) == address(0) || oldModule == newModule_) { // <= FOUND\n393:             revert Errors.Kernel_InvalidModuleUpgrade(keycode);\n394:         }\n395: \n396:         \n397:         getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n398: \n399:         \n400:         getKeycodeForModule[newModule_] = keycode;\n401: \n402:         \n403:         getModuleForKeycode[keycode] = newModule_;\n404: \n405:         \n406:         newModule_.INIT();\n407: \n408:         \n409:         \n410:         _reconfigurePolicies(keycode);\n411:     }\n\n```\n",
          "loc": [
            "[383](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L383-L392)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Divisions which do not divide by -X cannot overflow or overflow so such operations can be unchecked to save gas",
      "description": "Make such found divisions are unchecked when ensured it is safe to do so",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n88:     function _calculateFee(uint256 amount) internal view returns (uint256) {\n89:         \n90:         return (amount * fee) / 10000; // <= FOUND\n91:     }\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L90-L90)"
          ]
        },
        {
          "content": "```solidity\n132:     function _calculatePaymentProRata(\n133:         uint256 amount,\n134:         uint256 elapsedTime,\n135:         uint256 totalTime\n136:     ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n137:         \n138:         uint256 numerator = (amount * elapsedTime) * 1000;\n139: \n140:         \n141:         \n142:         renterAmount = ((numerator / totalTime) + 500) / 1000; // <= FOUND\n143: \n144:         \n145:         lenderAmount = amount - renterAmount;\n146:     }\n\n```\n",
          "loc": [
            "[142](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L142-L142)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider activating via-ir for deploying",
      "description": "The Solidity compiler's Intermediate Representation (IR) based code generator, which can be activated using --via-ir on the command line or {\"viaIR\": true} in the options, serves a dual purpose. Firstly, it boosts the transparency and audibility of code generation, which enhances developers' comprehension and control over the contract's final bytecode. Secondly, it enables more sophisticated optimization passes that span multiple functions, thereby potentially leading to more efficient bytecode.\n\nIt's important to note that using the IR-based code generator may lengthen compile times due to the extra optimization steps. Therefore, it's advised to test your contract with and without this option enabled to measure the performance and gas cost implications. If the IR-based code generator significantly enhances your contract's performance or reduces gas costs, consider using the --via-ir flag during deployment. This way, you can leverage more advanced compiler optimizations without hindering your development workflow.",
      "gasSavings": 250,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n24: all\n\n```\n",
          "loc": [
            "[24](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L24-L24)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Expression (\"\") is cheaper than new bytes(0)",
      "description": "In Solidity, using an empty string (\"\") instead of \"new bytes(0)\" in expressions can result in cheaper gas costs. This is because \"new bytes(0)\" creates a dynamic byte array, leading to additional overhead. By simply using (\"\") when an empty bytes array is needed, you can optimize for gas efficiency.",
      "gasSavings": 518,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n563:             \n564:             \n565:             \n566:             bytes memory rentalAssetUpdates = new bytes(0); // <= FOUND\n\n```\n",
          "loc": [
            "[566](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L566-L566)"
          ]
        },
        {
          "content": "```solidity\n563: \n564:         \n565:         \n566:         \n567:         bytes memory rentalAssetUpdates = new bytes(0); // <= FOUND\n\n```\n",
          "loc": [
            "[567](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L567-L567)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Add unchecked {} for subtractions where the operands cannot underflow",
      "description": "n Solidity 0.8.x and above, arithmetic operations like subtraction automatically check for underflows and overflows, and revert the transaction if such a condition is met. This built-in safety feature provides a layer of security against potential numerical errors. However, these automatic checks also come with additional gas costs.\n\nIn some situations, you may already have a guard condition, like a require() statement or an if statement, that ensures the safety of the arithmetic operation. In such cases, the automatic check becomes redundant and leads to unnecessary gas expenditure.\n\nFor example, you may have a function that subtracts a smaller number from a larger one, and you may have already verified that the smaller number is indeed smaller. In this case, you're already sure that the subtraction operation won't underflow, so there's no need for the automatic check.\n\nIn these situations, you can use the unchecked { } block around the subtraction operation to skip the automatic check. This will reduce gas costs and make your contract more efficient, without sacrificing security. However, it's critical to use unchecked { } only when you're absolutely sure that the operation is safe.",
      "gasSavings": 680,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n145: \n146:         \n147:         lenderAmount = amount - renterAmount; // <= FOUND\n\n```\n",
          "loc": [
            "[145](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L145-L147)"
          ]
        },
        {
          "content": "```solidity\n224:         \n225:         uint256 elapsedTime = block.timestamp - start; // <= FOUND\n\n```\n",
          "loc": [
            "[224](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L224-L225)"
          ]
        },
        {
          "content": "```solidity\n225:         uint256 totalTime = end - start; // <= FOUND\n\n```\n",
          "loc": [
            "[225](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L225-L225)"
          ]
        },
        {
          "content": "```solidity\n405: \n406:         \n407:         uint256 skimmedBalance = trueBalance - syncedBalance; // <= FOUND\n\n```\n",
          "loc": [
            "[405](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L405-L407)"
          ]
        },
        {
          "content": "```solidity\n431: \n432:         \n433:         getPolicyIndex[policy_] = activePolicies.length - 1; // <= FOUND\n\n```\n",
          "loc": [
            "[431](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L431-L433)"
          ]
        },
        {
          "content": "```solidity\n445: \n446:             \n447:             getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1; // <= FOUND\n\n```\n",
          "loc": [
            "[445](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L445-L447)"
          ]
        },
        {
          "content": "```solidity\n469: \n470:         \n471:         Policy lastPolicy = activePolicies[activePolicies.length - 1]; // <= FOUND\n\n```\n",
          "loc": [
            "[469](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L469-L471)"
          ]
        },
        {
          "content": "```solidity\n601: \n602:             \n603:             Policy lastPolicy = dependents[dependents.length - 1]; // <= FOUND\n\n```\n",
          "loc": [
            "[601](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L601-L603)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Private functions used once can be inlined",
      "description": "Private functions which are only called once can be inlined to save GAS.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n32:     function _transferERC721(Item memory item, address recipient) private  // <= FOUND\n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L32-L32)"
          ]
        },
        {
          "content": "```solidity\n42:     function _transferERC1155(Item memory item, address recipient) private  // <= FOUND\n\n```\n",
          "loc": [
            "[42](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L42-L42)"
          ]
        },
        {
          "content": "```solidity\n159:     function _forwardToHook( // <= FOUND\n160:         address hook,\n161:         address safe,\n162:         address to,\n163:         uint256 value,\n164:         bytes memory data\n165:     ) private \n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n195:     function _checkTransaction(address from, address to, bytes memory data) private view  // <= FOUND\n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L195)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use bitmap to save gas",
      "description": "Bitmaps in Solidity are essentially a way of representing a set of boolean values within an integer type variable such as `uint256`. Each bit in the integer represents a true or false value (1 or 0), thus allowing efficient storage of multiple boolean values.\n\nBitmaps can save gas in the Ethereum network because they condense a lot of information into a small amount of storage. In Ethereum, storage is one of the most significant costs in terms of gas usage. By reducing the amount of storage space needed, you can potentially save on gas fees.\n\nHere's a quick comparison:\n\nIf you were to represent 256 different boolean values in the traditional way, you would have to declare 256 different `bool` variables. Given that each `bool` occupies a storage slot and each storage slot costs 20,000 gas to initialize, you would end up paying a considerable amount of gas.\n\nOn the other hand, if you were to use a bitmap, you could store these 256 boolean values within a single `uint256` variable. In other words, you'd only pay for a single storage slot, resulting in significant gas savings.\n\nHowever, it's important to note that while bitmaps can provide gas efficiencies, they do add complexity to the code, making it harder to read and maintain. Also, using bitmaps is efficient only when dealing with a large number of boolean variables that are frequently changed or accessed together. \n\nIn contrast, the straightforward counterpart to bitmaps would be using arrays or mappings to store boolean values, with each `bool` value occupying its own storage slot. This approach is simpler and more readable but could potentially be more expensive in terms of gas usage.",
      "gasSavings": 490,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n90:         initialized = true; // <= FOUND\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L90-L90)"
          ]
        },
        {
          "content": "```solidity\n405: \n406:         \n407:         uint256 skimmedBalance = trueBalance - syncedBalance; // <= FOUND\n\n```\n",
          "loc": [
            "[407](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L407-L407)"
          ]
        },
        {
          "content": "```solidity\n194:         \n195:         orders[orderHash] = true; // <= FOUND\n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L195-L195)"
          ]
        },
        {
          "content": "```solidity\n50: \n51:         \n52:         deployed[targetDeploymentAddress] = true; // <= FOUND\n\n```\n",
          "loc": [
            "[52](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L52-L52)"
          ]
        },
        {
          "content": "```solidity\n319: \n320:         \n321:         if (!isRole[role_]) isRole[role_] = true; // <= FOUND\n\n```\n",
          "loc": [
            "[321](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L321-L321)"
          ]
        },
        {
          "content": "```solidity\n322: \n323:         \n324:         hasRole[addr_][role_] = true; // <= FOUND\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L324-L324)"
          ]
        },
        {
          "content": "```solidity\n342: \n343:         \n344:         hasRole[addr_][role_] = false; // <= FOUND\n\n```\n",
          "loc": [
            "[344](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L344-L344)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly hashing",
      "description": "From a gas standpoint, the assembly version of the keccak256 hashing function can be more efficient than the high-level Solidity version. This is because Solidity has additional overhead when handling function calls and memory management, which can increase the gas cost.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n309:         \n310:         nameHash = keccak256(bytes(_NAME)); // <= FOUND\n\n```\n",
          "loc": [
            "[309](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L309-L310)"
          ]
        },
        {
          "content": "```solidity\n312: \n313:         \n314:         versionHash = keccak256(bytes(_VERSION)); // <= FOUND\n\n```\n",
          "loc": [
            "[312](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L312-L314)"
          ]
        },
        {
          "content": "```solidity\n315: \n316:         \n317:         eip712DomainTypehash = keccak256( // <= FOUND\n318:             abi.encodePacked(\n319:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n320:             )\n321:         );\n\n```\n",
          "loc": [
            "[315](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L315-L317)"
          ]
        },
        {
          "content": "```solidity\n367: \n368:         \n369:         itemTypeHash = keccak256(itemTypeString); // <= FOUND\n\n```\n",
          "loc": [
            "[367](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L367-L369)"
          ]
        },
        {
          "content": "```solidity\n370: \n371:         \n372:         hookTypeHash = keccak256(hookTypeString); // <= FOUND\n\n```\n",
          "loc": [
            "[370](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L370-L372)"
          ]
        },
        {
          "content": "```solidity\n373: \n374:         \n375:         rentalOrderTypeHash = keccak256( // <= FOUND\n376:             abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n377:         );\n\n```\n",
          "loc": [
            "[373](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L373-L375)"
          ]
        },
        {
          "content": "```solidity\n394: \n395:             \n396:             rentPayloadTypeHash = keccak256( // <= FOUND\n397:                 abi.encodePacked(\n398:                     rentPayloadTypeString,\n399:                     orderMetadataTypeString,\n400:                     orderFulfillmentTypeString\n401:                 )\n402:             );\n\n```\n",
          "loc": [
            "[394](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L394-L396)"
          ]
        },
        {
          "content": "```solidity\n403: \n404:             \n405:             orderFulfillmentTypeHash = keccak256(orderFulfillmentTypeString); // <= FOUND\n\n```\n",
          "loc": [
            "[403](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L403-L405)"
          ]
        },
        {
          "content": "```solidity\n406: \n407:             \n408:             orderMetadataTypeHash = keccak256(orderMetadataTypeString); // <= FOUND\n\n```\n",
          "loc": [
            "[406](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L406-L408)"
          ]
        },
        {
          "content": "```solidity\n89:         \n90:         bytes32 addressHash = keccak256( // <= FOUND\n91:             abi.encodePacked(create2_ff, address(this), salt, keccak256(initCode))\n92:         );\n\n```\n",
          "loc": [
            "[89](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L89-L90)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider using OZ EnumerateSet in place of nested mappings",
      "description": "Nested mappings and multi-dimensional arrays in Solidity operate through a process of double hashing, wherein the original storage slot and the first key are concatenated and hashed, and then this hash is again concatenated with the second key and hashed. This process can be quite gas expensive due to the double-hashing operation and subsequent storage operation (sstore).\n\nA possible optimization involves manually concatenating the keys followed by a single hash operation and an sstore. However, this technique introduces the risk of storage collision, especially when there are other nested hash maps in the contract that use the same key types. Because Solidity is unaware of the number and structure of nested hash maps in a contract, it follows a conservative approach in computing the storage slot to avoid possible collisions.\n\nOpenZeppelin's EnumerableSet provides a potential solution to this problem. It creates a data structure that combines the benefits of set operations with the ability to enumerate stored elements, which is not natively available in Solidity. EnumerableSet handles the element uniqueness internally and can therefore provide a more gas-efficient and collision-resistant alternative to nested mappings or multi-dimensional arrays in certain scenarios. ",
      "gasSavings": 3000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n218:     mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex; // <= FOUND\n\n```\n",
          "loc": [
            "[218](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L218-L218)"
          ]
        },
        {
          "content": "```solidity\n221:     mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) // <= FOUND\n\n```\n",
          "loc": [
            "[221](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L221-L221)"
          ]
        },
        {
          "content": "```solidity\n229:     mapping(address => mapping(Role => bool)) public hasRole; // <= FOUND\n\n```\n",
          "loc": [
            "[229](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L229-L229)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly to emit events",
      "description": "With the use of inline assembly in Solidity, we can take advantage of low-level features like scratch space and the free memory pointer, offering more gas-efficient ways of emitting events. The scratch space is a certain area of memory where we can temporarily store data, and the free memory pointer indicates the next available memory slot. Using these, we can efficiently assemble event data without incurring additional memory expansion costs. However, safety is paramount: to avoid overwriting or leakage, we must cache the free memory pointer before use and restore it afterward, ensuring that it points to the correct memory location post-operation.",
      "gasSavings": 304,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n411: \n412:         \n413:         emit Events.FeeTaken(token, skimmedBalance); // <= FOUND\n\n```\n",
          "loc": [
            "[413](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L413-L413)"
          ]
        },
        {
          "content": "```solidity\n171:         \n172:         emit Events.RentalOrderStarted( // <= FOUND\n173:             orderHash,\n174:             extraData,\n175:             order.seaportOrderHash,\n176:             order.items,\n177:             order.hooks,\n178:             order.orderType,\n179:             order.lender,\n180:             order.renter,\n181:             order.rentalWallet,\n182:             order.startTimestamp,\n183:             order.endTimestamp\n184:         );\n\n```\n",
          "loc": [
            "[172](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L172-L172)"
          ]
        },
        {
          "content": "```solidity\n192: \n193:         \n194:         emit Events.RentalSafeDeployment(safe, owners, threshold); // <= FOUND\n\n```\n",
          "loc": [
            "[194](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L194-L194)"
          ]
        },
        {
          "content": "```solidity\n113:         \n114:         emit Events.RentalOrderStopped(seaportOrderHash, stopper); // <= FOUND\n\n```\n",
          "loc": [
            "[114](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L114-L114)"
          ]
        },
        {
          "content": "```solidity\n301: \n302:         emit Events.ActionExecuted(action_, target_); // <= FOUND\n\n```\n",
          "loc": [
            "[302](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L302-L302)"
          ]
        },
        {
          "content": "```solidity\n324: \n325:         emit Events.RoleGranted(role_, addr_); // <= FOUND\n\n```\n",
          "loc": [
            "[325](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L325-L325)"
          ]
        },
        {
          "content": "```solidity\n344: \n345:         emit Events.RoleRevoked(role_, addr_); // <= FOUND\n\n```\n",
          "loc": [
            "[345](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L345-L345)"
          ]
        },
        {
          "content": "```solidity\n571: \n572:             emit Events.PermissionsUpdated( // <= FOUND\n573:                 request.keycode,\n574:                 policy_,\n575:                 request.funcSelector,\n576:                 grant_\n577:             );\n\n```\n",
          "loc": [
            "[572](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L572-L572)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use solady library where possible to save gas",
      "description": "The following OpenZeppelin imports have a Solady equivalent, as such they can be used to save GAS as Solady modules have been specifically designed to be as GAS efficient as possible",
      "gasSavings": 3000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n4: import {IERC721} from \"@openzeppelin-contracts/token/ERC721/IERC721.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n4: import {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[4](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L4-L4)"
          ]
        },
        {
          "content": "```solidity\n5: import {IERC1155} from \"@openzeppelin-contracts/token/ERC1155/IERC1155.sol\"; // <= FOUND\n\n```\n",
          "loc": [
            "[5](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L5-L5)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly in place of abi.decode to extract calldata values more efficiently",
      "description": "Using inline assembly to extract calldata values can be more gas-efficient than using `abi.decode` in Solidity. Inline assembly gives more direct access to EVM operations, enabling optimized usage of calldata. However, assembly should be used judiciously as it's more prone to errors. Opt for this approach when performance is critical and the complexity it introduces is manageable.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n115: \n116:         \n117:         \n118:         \n119:         \n120:         \n121:         \n122:         \n123:         \n124:         \n125:         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) { // <= FOUND\n\n```\n",
          "loc": [
            "[125](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L125-L125)"
          ]
        },
        {
          "content": "```solidity\n737:         \n738:         (RentPayload memory payload, bytes memory signature) = abi.decode( // <= FOUND\n739:             zoneParams.extraData,\n740:             (RentPayload, bytes)\n741:         );\n\n```\n",
          "loc": [
            "[738](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L738-L738)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Counting down in for statements is more gas efficient",
      "description": "Looping downwards in Solidity is more gas efficient due to how the EVM compares variables. In a 'for' loop that counts down, the end condition is usually to compare with zero, which is cheaper than comparing with another number. As such, restructure your loops to count downwards where possible.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n231:        for (uint256 i = 0; i < items.length; ++i) { // <= FOUND\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n\n```\n",
          "loc": [
            "[231](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L231-L231)"
          ]
        },
        {
          "content": "```solidity\n341:        for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n342:             \n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L341-L341)"
          ]
        },
        {
          "content": "```solidity\n197:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) { // <= FOUND\n198:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n199: \n200:             \n201:             rentedAssets[asset.rentalId] += asset.amount;\n202:         }\n\n```\n",
          "loc": [
            "[197](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n249:        for (uint256 i = 0; i < orderHashes.length; ++i) { // <= FOUND\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n\n```\n",
          "loc": [
            "[249](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L249-L249)"
          ]
        },
        {
          "content": "```solidity\n170:        for (uint256 i = 0; i < order.items.length; ++i) { // <= FOUND\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n\n```\n",
          "loc": [
            "[170](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L170-L170)"
          ]
        },
        {
          "content": "```solidity\n225:        for (uint256 i = 0; i < metadata.hooks.length; ++i) { // <= FOUND\n226:             \n227:             hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n228:         }\n\n```\n",
          "loc": [
            "[225](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L225-L225)"
          ]
        },
        {
          "content": "```solidity\n261:        for (uint256 i; i < offers.length; ++i) { // <= FOUND\n262:             \n263:             SpentItem memory offer = offers[i];\n264: \n265:             \n266:             if (offer.isERC721()) {\n267:                 \n268:                 \n269:                 itemType = ItemType.ERC721;\n270:                 settleTo = SettleTo.LENDER;\n271: \n272:                 \n273:                 totalRentals++; // <= FOUND\n274:             }\n275:             \n276:             else if (offer.isERC1155()) {\n277:                 \n278:                 \n279:                 itemType = ItemType.ERC1155;\n280:                 settleTo = SettleTo.LENDER;\n281: \n282:                 \n283:                 totalRentals++; // <= FOUND\n284:             }\n285:             \n286:             else if (offer.isERC20()) {\n287:                 \n288:                 \n289:                 itemType = ItemType.ERC20;\n290:                 settleTo = SettleTo.RENTER;\n291: \n292:                 \n293:                 totalPayments++; // <= FOUND\n294:             }\n295:             \n296:             else {\n297:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n298:             }\n299: \n300:             \n301:             rentalItems[i + startIndex] = Item({\n302:                 itemType: itemType,\n303:                 settleTo: settleTo,\n304:                 token: offer.token,\n305:                 amount: offer.amount,\n306:                 identifier: offer.identifier\n307:             });\n308:         }\n\n```\n",
          "loc": [
            "[261](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L261-L293)"
          ]
        },
        {
          "content": "```solidity\n375:        for (uint256 i; i < considerations.length; ++i) { // <= FOUND\n376:             \n377:             ReceivedItem memory consideration = considerations[i];\n378: \n379:             \n380:             if (consideration.isERC20()) {\n381:                 totalPayments++; // <= FOUND\n382:             }\n383:             \n384:             else if (consideration.isRental()) {\n385:                 totalRentals++; // <= FOUND\n386:             }\n387:             \n388:             else {\n389:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n390:                     consideration.itemType\n391:                 );\n392:             }\n393:         }\n\n```\n",
          "loc": [
            "[375](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L375-L385)"
          ]
        },
        {
          "content": "```solidity\n475:        for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n476:             \n477:             target = hooks[i].target;\n478: \n479:             \n480:             if (!STORE.hookOnStart(target)) {\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             \n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             \n488:             offer = offerItems[itemIndex];\n489: \n490:             \n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             \n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 \n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) {\n508:                 \n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 \n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n514:                 );\n515:             } catch (bytes memory revertData) {\n516:                 \n517:                 revert Errors.Shared_HookFailBytes(revertData);\n518:             }\n519:         }\n\n```\n",
          "loc": [
            "[475](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L475-L475)"
          ]
        },
        {
          "content": "```solidity\n695:        for (uint256 i = 0; i < executions.length; ++i) { // <= FOUND\n696:             ReceivedItem memory execution = executions[i];\n697: \n698:             \n699:             if (execution.isERC20()) {\n700:                 _checkExpectedRecipient(execution, address(ESCRW));\n701:             }\n702:             \n703:             \n704:             else if (execution.isRental()) {\n705:                 _checkExpectedRecipient(execution, expectedRentalSafe);\n706:             }\n707:             \n708:             else {\n709:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n710:                     execution.itemType\n711:                 );\n712:             }\n713:         }\n\n```\n",
          "loc": [
            "[695](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L695-L695)"
          ]
        },
        {
          "content": "```solidity\n205:        for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n206:             \n207:             target = hooks[i].target;\n208: \n209:             \n210:             if (!STORE.hookOnStop(target)) {\n211:                 revert Errors.Shared_DisabledHook(target);\n212:             }\n213: \n214:             \n215:             itemIndex = hooks[i].itemIndex;\n216: \n217:             \n218:             item = rentalItems[itemIndex];\n219: \n220:             \n221:             if (!item.isRental()) {\n222:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n223:             }\n224: \n225:             \n226:             try\n227:                 IHook(target).onStop(\n228:                     rentalWallet,\n229:                     item.token,\n230:                     item.identifier,\n231:                     item.amount,\n232:                     hooks[i].extraData\n233:                 )\n234:             {} catch Error(string memory revertReason) {\n235:                 \n236:                 revert Errors.Shared_HookFailString(revertReason);\n237:             } catch Panic(uint256 errorCode) {\n238:                 \n239:                 string memory stringErrorCode = LibString.toString(errorCode);\n240: \n241:                 \n242:                 revert Errors.Shared_HookFailString(\n243:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n244:                 );\n245:             } catch (bytes memory revertData) {\n246:                 \n247:                 revert Errors.Shared_HookFailBytes(revertData);\n248:             }\n249:         }\n\n```\n",
          "loc": [
            "[205](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L205-L205)"
          ]
        },
        {
          "content": "```solidity\n276:        for (uint256 i; i < order.items.length; ++i) { // <= FOUND\n277:             if (order.items[i].isRental()) {\n278:                 \n279:                 _insert(\n280:                     rentalAssetUpdates,\n281:                     order.items[i].toRentalId(order.rentalWallet),\n282:                     order.items[i].amount\n283:                 );\n284:             }\n285:         }\n\n```\n",
          "loc": [
            "[276](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L276-L276)"
          ]
        },
        {
          "content": "```solidity\n324:        for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n325:             \n326:             _validateRentalCanBeStoped(\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             \n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) { // <= FOUND\n334:                 \n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert(\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             \n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n346: \n347:             \n348:             if (orders[i].hooks.length > 0) {\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n350:             }\n351: \n352:             \n353:             _reclaimRentedItems(orders[i]);\n354: \n355:             \n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:         }\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L333)"
          ]
        },
        {
          "content": "```solidity\n438:        for (uint256 i; i < depLength; ++i) { // <= FOUND\n439:             Keycode keycode = dependencies[i];\n440: \n441:             \n442:             moduleDependents[keycode].push(policy_);\n443: \n444:             \n445:             getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n446:         }\n\n```\n",
          "loc": [
            "[438](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L438-L438)"
          ]
        },
        {
          "content": "```solidity\n512:        for (uint256 i; i < keycodeLen; ++i) { // <= FOUND\n513:             \n514:             Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n515:             \n516:             module.changeKernel(newKernel_);\n517:         }\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L512-L512)"
          ]
        },
        {
          "content": "```solidity\n546:        for (uint256 i; i < depLength; ++i) { // <= FOUND\n547:             \n548:             dependents[i].configureDependencies();\n549:         }\n\n```\n",
          "loc": [
            "[546](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L546-L546)"
          ]
        },
        {
          "content": "```solidity\n566:        for (uint256 i = 0; i < reqLength; ++i) { // <= FOUND\n567:             \n568:             Permissions memory request = requests_[i];\n569:             modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n570: \n571:             emit Events.PermissionsUpdated(\n572:                 request.keycode,\n573:                 policy_,\n574:                 request.funcSelector,\n575:                 grant_\n576:             );\n577:         }\n\n```\n",
          "loc": [
            "[566](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L566-L566)"
          ]
        },
        {
          "content": "```solidity\n592:        for (uint256 i; i < depcLength; ++i) { // <= FOUND\n593:             \n594:             Keycode keycode = dependencies[i];\n595:             Policy[] storage dependents = moduleDependents[keycode];\n596: \n597:             \n598:             uint256 origIndex = getDependentIndex[keycode][policy_];\n599: \n600:             \n601:             Policy lastPolicy = dependents[dependents.length - 1];\n602: \n603:             \n604:             dependents[origIndex] = lastPolicy;\n605: \n606:             \n607:             \n608:             dependents.pop();\n609: \n610:             \n611:             getDependentIndex[keycode][lastPolicy] = origIndex;\n612: \n613:             \n614:             delete getDependentIndex[keycode][policy_];\n615:         }\n\n```\n",
          "loc": [
            "[592](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L592-L592)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Identical Deployments Should be Replaced with Clone",
      "description": "In the context of smart contracts, deploying multiple identical contracts can lead to inefficient use of gas and unnecessarily duplicate code on the blockchain. A more gas-efficient approach is to use a \"clone\" pattern. By deploying a master contract and then creating clones of it, only the differences between the instances are stored for each clone. This approach leverages the EIP-1167 standard, which defines a minimal proxy contract that points to the implementation contract. Clones can be far cheaper to deploy compared to full instances. So, the resolution is to replace identical deployments with clones, saving on gas and storage space.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n54:             deploymentAddress := create2( // <= FOUND\n55:                 \n56:                 callvalue(),\n57:                 \n58:                 add(initCode, 0x20),\n59:                 \n60:                 mload(initCode),\n61:                 \n62:                 salt\n63:             )\n64:         }\n\n```\n",
          "loc": [
            "[54](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L54-L54)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Redundant Contract Existence Check in Consecutive External Calls",
      "description": "Redundant contract existence checks occur when a smart contract verifies the existence of another contract multiple times consecutively in external calls, leading to unnecessary gas consumption and bloated code. When interacting with another contract, it might be necessary to ensure that the contract is indeed deployed and exists, but performing this check multiple times in consecutive calls is inefficient. Instead of checking the existence of a contract every time before calling its functions, you can check once at the beginning of the sequence and store the result in a local variable. Subsequent interactions can then use this result without additional checks. By removing redundant contract existence checks, developers can save gas and make their code more concise and efficient. Tools like linters or static analyzers can help identify these redundancies during the development phase.",
      "gasSavings": 400,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n294:     function updateHookPath(address to, address hook) external onlyByProxy permissioned {\n295:         \n296:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to); // <= FOUND\n297: \n298:         \n299:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n300: \n301:         \n302:         _contractToHook[to] = hook;\n303:     }\n\n```\n",
          "loc": [
            "[294](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L294-L299)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Mark Functions That Revert For Normal Users As payable",
      "description": "In Solidity, marking functions as `payable` allows them to accept Ether. If a function is known to revert for regular users (non-admin or specific roles) but needs to be accessible to others, marking it as `payable` can be beneficial. This ensures that even if a regular user accidentally sends Ether to the function, the Ether won't be trapped, as the function reverts, returning the funds. This can save gas by avoiding unnecessary failure handling in the function itself. Resolution: Carefully assess the roles and access patterns, and mark functions that should revert for regular users as `payable` to handle accidental Ether transfers.",
      "gasSavings": 325,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n310:     function grantRole(Role role_, address addr_) public onlyAdmin {\n311:         \n312:         if (hasRole[addr_][role_])\n313:             revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_);\n314: \n315:         \n316:         ensureValidRole(role_);\n317: \n318:         \n319:         if (!isRole[role_]) isRole[role_] = true;\n320: \n321:         \n322:         hasRole[addr_][role_] = true;\n323: \n324:         emit Events.RoleGranted(role_, addr_);\n325:     }\n\n```\n",
          "loc": [
            "[310](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L310-L310)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin {\n334:         \n335:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_);\n336: \n337:         \n338:         if (!hasRole[addr_][role_])\n339:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_);\n340: \n341:         \n342:         hasRole[addr_][role_] = false;\n343: \n344:         emit Events.RoleRevoked(role_, addr_);\n345:     }\n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L333)"
          ]
        },
        {
          "content": "```solidity\n99:     function toggleWhitelistDelegate(\n100:         address delegate,\n101:         bool isEnabled\n102:     ) external onlyRole(\"ADMIN_ADMIN\") {\n103:         STORE.toggleWhitelistDelegate(delegate, isEnabled);\n104:     }\n\n```\n",
          "loc": [
            "[99](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L99-L99)"
          ]
        },
        {
          "content": "```solidity\n113:     function toggleWhitelistExtension(\n114:         address extension,\n115:         bool isEnabled\n116:     ) external onlyRole(\"ADMIN_ADMIN\") {\n117:         STORE.toggleWhitelistExtension(extension, isEnabled);\n118:     }\n\n```\n",
          "loc": [
            "[113](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L113-L113)"
          ]
        },
        {
          "content": "```solidity\n126:     function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") {\n127:         STORE.upgrade(newImplementation);\n128:     }\n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L126-L126)"
          ]
        },
        {
          "content": "```solidity\n134:     function freezeStorage() external onlyRole(\"ADMIN_ADMIN\") {\n135:         STORE.freeze();\n136:     }\n\n```\n",
          "loc": [
            "[134](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L134-L134)"
          ]
        },
        {
          "content": "```solidity\n144:     function upgradePaymentEscrow(\n145:         address newImplementation\n146:     ) external onlyRole(\"ADMIN_ADMIN\") {\n147:         ESCRW.upgrade(newImplementation);\n148:     }\n\n```\n",
          "loc": [
            "[144](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L144-L144)"
          ]
        },
        {
          "content": "```solidity\n154:     function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\") {\n155:         ESCRW.freeze();\n156:     }\n\n```\n",
          "loc": [
            "[154](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L154-L154)"
          ]
        },
        {
          "content": "```solidity\n164:     function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") {\n165:         ESCRW.skim(token, to);\n166:     }\n\n```\n",
          "loc": [
            "[164](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L164-L164)"
          ]
        },
        {
          "content": "```solidity\n173:     function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") {\n174:         ESCRW.setFee(feeNumerator);\n175:     }\n\n```\n",
          "loc": [
            "[173](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L173-L173)"
          ]
        },
        {
          "content": "```solidity\n733:     function validateOrder(\n734:         ZoneParameters calldata zoneParams\n735:     ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue) {\n736:         \n737:         (RentPayload memory payload, bytes memory signature) = abi.decode(\n738:             zoneParams.extraData,\n739:             (RentPayload, bytes)\n740:         );\n741: \n742:         \n743:         SeaportPayload memory seaportPayload = SeaportPayload({\n744:             orderHash: zoneParams.orderHash,\n745:             zoneHash: zoneParams.zoneHash,\n746:             offer: zoneParams.offer,\n747:             consideration: zoneParams.consideration,\n748:             totalExecutions: zoneParams.totalExecutions,\n749:             fulfiller: zoneParams.fulfiller,\n750:             offerer: zoneParams.offerer\n751:         });\n752: \n753:         \n754:         _validateProtocolSignatureExpiration(payload.expiration);\n755: \n756:         \n757:         _validateFulfiller(payload.intendedFulfiller, seaportPayload.fulfiller);\n758: \n759:         \n760:         address signer = _recoverSignerFromPayload(\n761:             _deriveRentPayloadHash(payload),\n762:             signature\n763:         );\n764: \n765:         \n766:         if (!kernel.hasRole(signer, toRole(\"CREATE_SIGNER\"))) {\n767:             revert Errors.CreatePolicy_UnauthorizedCreatePolicySigner();\n768:         }\n769: \n770:         \n771:         _rentFromZone(payload, seaportPayload);\n772: \n773:         \n774:         validOrderMagicValue = ZoneInterface.validateOrder.selector;\n775:     }\n\n```\n",
          "loc": [
            "[733](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733-L733)"
          ]
        },
        {
          "content": "```solidity\n362:     function updateHookPath(address to, address hook) external onlyRole(\"GUARD_ADMIN\") {\n363:         STORE.updateHookPath(to, hook);\n364:     }\n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L362-L362)"
          ]
        },
        {
          "content": "```solidity\n373:     function updateHookStatus(\n374:         address hook,\n375:         uint8 bitmap\n376:     ) external onlyRole(\"GUARD_ADMIN\") {\n377:         STORE.updateHookStatus(hook, bitmap);\n378:     }\n\n```\n",
          "loc": [
            "[373](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L373-L373)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "State variable read in a loop",
      "description": "Reading a state variable inside a loop in Solidity can be gas-inefficient, particularly in older versions of the language. Each read from a state variable in a loop incurs a gas cost, and these costs can accumulate quickly if the loop iterates many times. As a resolution, developers often manually cache the state variable outside the loop, reducing the number of state reads. By reading the variable only once and using the cached value within the loop, the gas costs can be significantly reduced. This approach requires careful consideration of the code's logic but can lead to more efficient contract execution.",
      "gasSavings": 9,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n566:        for (uint256 i = 0; i < reqLength; ++i) {\n567:             \n568:             Permissions memory request = requests_[i];\n569:             modulePermissions[request.keycode][policy_][request.funcSelector] = grant_; // <= FOUND\n570: \n571:             emit Events.PermissionsUpdated(\n572:                 request.keycode,\n573:                 policy_,\n574:                 request.funcSelector,\n575:                 grant_\n576:             );\n577:         }\n\n```\n",
          "loc": [
            "[569](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L569-L569)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Function names can be optimized",
      "description": "Function names in Solidity contracts can be optimized to save gas during both deployment and execution. Method IDs are the first four bytes of the keccak256 hash of the function signature, and having two leading zero bytes can save 128 gas each during deployment. Additionally, renaming functions to have lower method IDs can save 22 gas per call, per sorted position shifted. This optimization leverages the way EVM handles data storage, making the execution more efficient. While these savings might seem minor, they can add up in contracts with numerous calls, contributing to more economical and efficient code.",
      "gasSavings": 1408,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23: contract PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n14: contract StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n15: contract Admin is Policy  // <= FOUND\n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n22: contract Factory is Policy  // <= FOUND\n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard  // <= FOUND\n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        },
        {
          "content": "```solidity\n14: contract Create2Deployer  // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n206: contract Kernel  // <= FOUND\n\n```\n",
          "loc": [
            "[206](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L206-L206)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Assembly let var only used on once",
      "description": "If a variable is only once, it makes more sense to use the value the variable holds directly",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n40:         assembly {\n41:             \n42:             if eq(mload(rentalAssets), 0) {\n43:                 \n44:                 mstore(rentalAssets, 0x20)\n45: \n46:                 \n47:                 mstore(add(0x20, rentalAssets), 0x00)\n48:             }\n49: \n50:             \n51:             \n52:             let newByteDataSize := add(mload(rentalAssets), 0x40) // <= FOUND\n53: \n54:             \n55:             let rentalAssetElementPtr := add(rentalAssets, 0x20)\n56: \n57:             \n58:             let elements := add(mload(rentalAssetElementPtr), 1)\n59: \n60:             \n61:             \n62:             \n63:             \n64:             let newItemPosition := add(\n65:                 rentalAssetElementPtr,\n66:                 sub(mul(elements, 0x40), 0x20)\n67:             )\n68: \n69:             \n70:             mstore(rentalAssets, newByteDataSize) // <= FOUND\n71: \n72:             \n73:             mstore(rentalAssetElementPtr, elements)\n74: \n75:             \n76:             mstore(newItemPosition, _rentalId)\n77: \n78:             \n79:             mstore(add(newItemPosition, 0x20), rentalAssetAmount)\n80: \n81:             \n82:             \n83:             mstore(0x40, add(newItemPosition, 0x40))\n84:         }\n\n```\n",
          "loc": [
            "[40](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L40-L70)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly to validate msg.sender",
      "description": "Utilizing assembly for validating `msg.sender` can potentially save gas as it allows for more direct and efficient access to Ethereumâ€™s EVM opcodes, bypassing some of the overhead introduced by Solidityâ€™s higher-level abstractions. However, this practice requires deep expertise in EVM, as incorrect implementation can introduce critical vulnerabilities. It is a trade-off between gas efficiency and code safety.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n141:                 revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[141](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L141-L141)"
          ]
        },
        {
          "content": "```solidity\n38:             revert Errors.Create2Deployer_UnauthorizedSender(msg.sender, salt); // <= FOUND\n\n```\n",
          "loc": [
            "[38](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L38-L38)"
          ]
        },
        {
          "content": "```solidity\n41:         if (msg.sender != address(kernel)) // <= FOUND\n42:             revert Errors.KernelAdapter_OnlyKernel(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L41-L42)"
          ]
        },
        {
          "content": "```solidity\n79:             revert Errors.Module_PolicyNotAuthorized(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[79](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L79-L79)"
          ]
        },
        {
          "content": "```solidity\n255:         if (msg.sender != executor) revert Errors.Kernel_OnlyExecutor(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[255](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L255-L255)"
          ]
        },
        {
          "content": "```solidity\n263:         if (msg.sender != admin) revert Errors.Kernel_OnlyAdmin(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[263](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L263-L263)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Simple checks for zero uint can be done using assembly to save gas",
      "description": "Using assembly for simple zero checks on unsigned integers can save gas due to lower-level, optimized operations. \n\n**Resolution**: Implement inline assembly with Solidity's `assembly` block to perform zero checks. Ensure thorough testing and verification, as assembly lacks the safety checks of high-level Solidity, potentially introducing vulnerabilities if not used carefully.",
      "gasSavings": 48,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n296:         \n297:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to); // <= FOUND\n\n```\n",
          "loc": [
            "[296](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L296-L297)"
          ]
        },
        {
          "content": "```solidity\n299: \n300:         \n301:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n\n```\n",
          "loc": [
            "[299](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L299-L301)"
          ]
        },
        {
          "content": "```solidity\n299:         \n300:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n\n```\n",
          "loc": [
            "[299](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L299-L300)"
          ]
        },
        {
          "content": "```solidity\n127: \n128:         \n129:         return rentedAssets[rentalId] != 0; // <= FOUND\n\n```\n",
          "loc": [
            "[127](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L127-L129)"
          ]
        },
        {
          "content": "```solidity\n141: \n142:         \n143:         \n144:         return hookStatus[hook] != 0 ? hook : address(0); // <= FOUND\n\n```\n",
          "loc": [
            "[141](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L141-L144)"
          ]
        },
        {
          "content": "```solidity\n151:         \n152:         return (uint8(1) & hookStatus[hook]) != 0; // <= FOUND\n\n```\n",
          "loc": [
            "[151](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L151-L152)"
          ]
        },
        {
          "content": "```solidity\n161:         \n162:         return uint8(2) & hookStatus[hook] != 0; // <= FOUND\n\n```\n",
          "loc": [
            "[161](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L161-L162)"
          ]
        },
        {
          "content": "```solidity\n171:         \n172:         return uint8(4) & hookStatus[hook] != 0; // <= FOUND\n\n```\n",
          "loc": [
            "[171](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L171-L172)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Trade-offs Between Modifiers and Internal Functions",
      "description": "In Solidity, both modifiers and internal functions can be used to modularize and reuse code, but they have different trade-offs.\n\nModifiers are primarily used to augment the behavior of functions, often for checks or validations. They can access parameters of the function they modify and are integrated into the functionâ€™s code at compile time. This makes them syntactically cleaner for repetitive precondition checks. However, modifiers can sometimes lead to less readable code, especially when the logic is complex or when multiple modifiers are used on a single function.\n\nInternal functions, on the other hand, offer more flexibility. They can contain complex logic, return values, and be called from other functions. This makes them more suitable for reusable chunks of business logic. Since internal functions are separate entities, they can be more readable and easier to test in isolation compared to modifiers.\n\nUsing internal functions can result in slightly more gas consumption, as it involves an internal function call. However, this cost is usually minimal and can be a worthwhile trade-off for increased code clarity and maintainability.\n\nIn summary, while modifiers offer a concise way to include checks and simple logic across multiple functions, internal functions provide more flexibility and are better suited for complex and reusable code. The choice between the two should be based on the specific use case, considering factors like code complexity, readability, and gas efficiency.",
      "gasSavings": 546000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n88:     function _calculateFee(uint256 amount) internal view returns (uint256)  // <= FOUND\n\n```\n",
          "loc": [
            "[88](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L88-L88)"
          ]
        },
        {
          "content": "```solidity\n100:     function _safeTransfer(address token, address to, uint256 value) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L100-L100)"
          ]
        },
        {
          "content": "```solidity\n132:     function _calculatePaymentProRata( // <= FOUND\n133:         uint256 amount, // <= FOUND\n134:         uint256 elapsedTime, // <= FOUND\n135:         uint256 totalTime // <= FOUND\n136:     ) internal pure returns (uint256 renterAmount, uint256 lenderAmount)  // <= FOUND\n\n```\n",
          "loc": [
            "[132](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L132-L136)"
          ]
        },
        {
          "content": "```solidity\n159:     function _settlePaymentProRata( // <= FOUND\n160:         address token, // <= FOUND\n161:         uint256 amount, // <= FOUND\n162:         address lender, // <= FOUND\n163:         address renter, // <= FOUND\n164:         uint256 elapsedTime, // <= FOUND\n165:         uint256 totalTime // <= FOUND\n166:     ) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L159-L166)"
          ]
        },
        {
          "content": "```solidity\n190:     function _settlePaymentInFull( // <= FOUND\n191:         address token, // <= FOUND\n192:         uint256 amount, // <= FOUND\n193:         SettleTo settleTo, // <= FOUND\n194:         address lender, // <= FOUND\n195:         address renter // <= FOUND\n196:     ) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[190](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L190-L196)"
          ]
        },
        {
          "content": "```solidity\n215:     function _settlePayment( // <= FOUND\n216:         Item[] calldata items, // <= FOUND\n217:         OrderType orderType, // <= FOUND\n218:         address lender, // <= FOUND\n219:         address renter, // <= FOUND\n220:         uint256 start, // <= FOUND\n221:         uint256 end // <= FOUND\n222:     ) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L215-L222)"
          ]
        },
        {
          "content": "```solidity\n292:     function _decreaseDeposit(address token, uint256 amount) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[292](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L292-L292)"
          ]
        },
        {
          "content": "```solidity\n304:     function _increaseDeposit(address token, uint256 amount) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[304](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L304-L304)"
          ]
        },
        {
          "content": "```solidity\n32:     function _insert( // <= FOUND\n33:         bytes memory rentalAssets, // <= FOUND\n34:         RentalId rentalId, // <= FOUND\n35:         uint256 rentalAssetAmount // <= FOUND\n36:     ) internal pure  // <= FOUND\n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L32-L36)"
          ]
        },
        {
          "content": "```solidity\n96:     function _convertToStatic( // <= FOUND\n97:         bytes memory rentalAssetUpdates // <= FOUND\n98:     ) internal pure returns (RentalAssetUpdate[] memory updates)  // <= FOUND\n\n```\n",
          "loc": [
            "[96](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L96-L98)"
          ]
        },
        {
          "content": "```solidity\n76:     function _validateFulfiller( // <= FOUND\n77:         address intendedFulfiller, // <= FOUND\n78:         address actualFulfiller // <= FOUND\n79:     ) internal pure  // <= FOUND\n\n```\n",
          "loc": [
            "[76](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L76-L79)"
          ]
        },
        {
          "content": "```solidity\n94:     function _validateProtocolSignatureExpiration(uint256 expiration) internal view  // <= FOUND\n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L94-L94)"
          ]
        },
        {
          "content": "```solidity\n107:     function _recoverSignerFromPayload( // <= FOUND\n108:         bytes32 payloadHash, // <= FOUND\n109:         bytes memory signature // <= FOUND\n110:     ) internal view returns (address)  // <= FOUND\n\n```\n",
          "loc": [
            "[107](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L107-L110)"
          ]
        },
        {
          "content": "```solidity\n125:     function _deriveItemHash(Item memory item) internal view returns (bytes32)  // <= FOUND\n\n```\n",
          "loc": [
            "[125](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L125-L125)"
          ]
        },
        {
          "content": "```solidity\n147:     function _deriveHookHash(Hook memory hook) internal view returns (bytes32)  // <= FOUND\n\n```\n",
          "loc": [
            "[147](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L147-L147)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash( // <= FOUND\n163:         RentalOrder memory order // <= FOUND\n164:     ) internal view returns (bytes32)  // <= FOUND\n\n```\n",
          "loc": [
            "[162](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L162-L164)"
          ]
        },
        {
          "content": "```solidity\n204:     function _deriveOrderFulfillmentHash( // <= FOUND\n205:         OrderFulfillment memory fulfillment // <= FOUND\n206:     ) internal view returns (bytes32)  // <= FOUND\n\n```\n",
          "loc": [
            "[204](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L204-L206)"
          ]
        },
        {
          "content": "```solidity\n218:     function _deriveOrderMetadataHash( // <= FOUND\n219:         OrderMetadata memory metadata // <= FOUND\n220:     ) internal view returns (bytes32)  // <= FOUND\n\n```\n",
          "loc": [
            "[218](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L218-L220)"
          ]
        },
        {
          "content": "```solidity\n248:     function _deriveRentPayloadHash( // <= FOUND\n249:         RentPayload memory payload // <= FOUND\n250:     ) internal view returns (bytes32)  // <= FOUND\n\n```\n",
          "loc": [
            "[248](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L248-L250)"
          ]
        },
        {
          "content": "```solidity\n273:     function _deriveDomainSeparator( // <= FOUND\n274:         bytes32 _eip712DomainTypeHash, // <= FOUND\n275:         bytes32 _nameHash, // <= FOUND\n276:         bytes32 _versionHash // <= FOUND\n277:     ) internal view virtual returns (bytes32)  // <= FOUND\n\n```\n",
          "loc": [
            "[273](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L273-L277)"
          ]
        },
        {
          "content": "```solidity\n298:     function _deriveTypehashes() // <= FOUND\n299:         internal // <= FOUND\n300:         view // <= FOUND\n301:         returns ( // <= FOUND\n302:             bytes32 nameHash, // <= FOUND\n303:             bytes32 versionHash, // <= FOUND\n304:             bytes32 eip712DomainTypehash, // <= FOUND\n305:             bytes32 domainSeparator // <= FOUND\n306:         ) // <= FOUND\n307:      // <= FOUND\n\n```\n",
          "loc": [
            "[298](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L298-L307)"
          ]
        },
        {
          "content": "```solidity\n339:     function _deriveRentalTypehashes() // <= FOUND\n340:         internal // <= FOUND\n341:         pure // <= FOUND\n342:         returns ( // <= FOUND\n343:             bytes32 itemTypeHash, // <= FOUND\n344:             bytes32 hookTypeHash, // <= FOUND\n345:             bytes32 rentalOrderTypeHash, // <= FOUND\n346:             bytes32 orderFulfillmentTypeHash, // <= FOUND\n347:             bytes32 orderMetadataTypeHash, // <= FOUND\n348:             bytes32 rentPayloadTypeHash // <= FOUND\n349:         ) // <= FOUND\n350:      // <= FOUND\n\n```\n",
          "loc": [
            "[339](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L339-L350)"
          ]
        },
        {
          "content": "```solidity\n165:     function _emitRentalOrderStarted( // <= FOUND\n166:         RentalOrder memory order, // <= FOUND\n167:         bytes32 orderHash, // <= FOUND\n168:         bytes memory extraData // <= FOUND\n169:     ) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[165](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L165-L169)"
          ]
        },
        {
          "content": "```solidity\n195:     function _processBaseOrderOffer( // <= FOUND\n196:         Item[] memory rentalItems, // <= FOUND\n197:         SpentItem[] memory offers, // <= FOUND\n198:         uint256 startIndex // <= FOUND\n199:     ) internal pure  // <= FOUND\n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L195-L199)"
          ]
        },
        {
          "content": "```solidity\n247:     function _processPayOrderOffer( // <= FOUND\n248:         Item[] memory rentalItems, // <= FOUND\n249:         SpentItem[] memory offers, // <= FOUND\n250:         uint256 startIndex // <= FOUND\n251:     ) internal pure  // <= FOUND\n\n```\n",
          "loc": [
            "[247](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L247-L251)"
          ]
        },
        {
          "content": "```solidity\n326:     function _processBaseOrderConsideration( // <= FOUND\n327:         Item[] memory rentalItems, // <= FOUND\n328:         ReceivedItem[] memory considerations, // <= FOUND\n329:         uint256 startIndex // <= FOUND\n330:     ) internal pure  // <= FOUND\n\n```\n",
          "loc": [
            "[326](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L326-L330)"
          ]
        },
        {
          "content": "```solidity\n367:     function _processPayeeOrderConsideration( // <= FOUND\n368:         ReceivedItem[] memory considerations // <= FOUND\n369:     ) internal pure  // <= FOUND\n\n```\n",
          "loc": [
            "[367](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L367-L369)"
          ]
        },
        {
          "content": "```solidity\n411:     function _convertToItems( // <= FOUND\n412:         SpentItem[] memory offers, // <= FOUND\n413:         ReceivedItem[] memory considerations, // <= FOUND\n414:         OrderType orderType // <= FOUND\n415:     ) internal pure returns (Item[] memory items)  // <= FOUND\n\n```\n",
          "loc": [
            "[411](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L411-L415)"
          ]
        },
        {
          "content": "```solidity\n464:     function _addHooks( // <= FOUND\n465:         Hook[] memory hooks, // <= FOUND\n466:         SpentItem[] memory offerItems, // <= FOUND\n467:         address rentalWallet // <= FOUND\n468:     ) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[464](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L464-L468)"
          ]
        },
        {
          "content": "```solidity\n530:     function _rentFromZone( // <= FOUND\n531:         RentPayload memory payload, // <= FOUND\n532:         SeaportPayload memory seaportPayload // <= FOUND\n533:     ) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[530](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530-L533)"
          ]
        },
        {
          "content": "```solidity\n626:     function _isValidOrderMetadata( // <= FOUND\n627:         OrderMetadata memory metadata, // <= FOUND\n628:         bytes32 zoneHash // <= FOUND\n629:     ) internal view  // <= FOUND\n\n```\n",
          "loc": [
            "[626](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L626-L629)"
          ]
        },
        {
          "content": "```solidity\n647:     function _isValidSafeOwner(address owner, address safe) internal view  // <= FOUND\n\n```\n",
          "loc": [
            "[647](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L647-L647)"
          ]
        },
        {
          "content": "```solidity\n666:     function _checkExpectedRecipient( // <= FOUND\n667:         ReceivedItem memory execution, // <= FOUND\n668:         address expectedRecipient // <= FOUND\n669:     ) internal pure  // <= FOUND\n\n```\n",
          "loc": [
            "[666](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L666-L669)"
          ]
        },
        {
          "content": "```solidity\n691:     function _executionInvariantChecks( // <= FOUND\n692:         ReceivedItem[] memory executions, // <= FOUND\n693:         address expectedRentalSafe // <= FOUND\n694:     ) internal view  // <= FOUND\n\n```\n",
          "loc": [
            "[691](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L691-L694)"
          ]
        },
        {
          "content": "```solidity\n111:     function _emitRentalOrderStopped(bytes32 seaportOrderHash, address stopper) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[111](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L111-L111)"
          ]
        },
        {
          "content": "```solidity\n126:     function _validateRentalCanBeStoped( // <= FOUND\n127:         OrderType orderType, // <= FOUND\n128:         uint256 endTimestamp, // <= FOUND\n129:         address expectedLender // <= FOUND\n130:     ) internal view  // <= FOUND\n\n```\n",
          "loc": [
            "[126](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L126-L130)"
          ]
        },
        {
          "content": "```solidity\n166:     function _reclaimRentedItems(RentalOrder memory order) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[166](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L166-L166)"
          ]
        },
        {
          "content": "```solidity\n194:     function _removeHooks( // <= FOUND\n195:         Hook[] calldata hooks, // <= FOUND\n196:         Item[] calldata rentalItems, // <= FOUND\n197:         address rentalWallet // <= FOUND\n198:     ) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[194](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L194-L198)"
          ]
        },
        {
          "content": "```solidity\n180:     function getModuleAddress(Keycode keycode_) internal view returns (address)  // <= FOUND\n\n```\n",
          "loc": [
            "[180](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L180-L180)"
          ]
        },
        {
          "content": "```solidity\n356:     function _installModule(Module newModule_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[356](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L356-L356)"
          ]
        },
        {
          "content": "```solidity\n383:     function _upgradeModule(Module newModule_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[383](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L383-L383)"
          ]
        },
        {
          "content": "```solidity\n418:     function _activatePolicy(Policy policy_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[418](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L418-L418)"
          ]
        },
        {
          "content": "```solidity\n457:     function _deactivatePolicy(Policy policy_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[457](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L457-L457)"
          ]
        },
        {
          "content": "```solidity\n508:     function _migrateKernel(Kernel newKernel_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[508](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L508-L508)"
          ]
        },
        {
          "content": "```solidity\n540:     function _reconfigurePolicies(Keycode keycode_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[540](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L540-L540)"
          ]
        },
        {
          "content": "```solidity\n560:     function _setPolicyPermissions( // <= FOUND\n561:         Policy policy_, // <= FOUND\n562:         Permissions[] memory requests_, // <= FOUND\n563:         bool grant_ // <= FOUND\n564:     ) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[560](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L560-L564)"
          ]
        },
        {
          "content": "```solidity\n586:     function _pruneFromDependents(Policy policy_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[586](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L586-L586)"
          ]
        },
        {
          "content": "```solidity\n40:     modifier onlyKernel()  // <= FOUND\n\n```\n",
          "loc": [
            "[40](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L40-L40)"
          ]
        },
        {
          "content": "```solidity\n77:     modifier permissioned()  // <= FOUND\n\n```\n",
          "loc": [
            "[77](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L77-L77)"
          ]
        },
        {
          "content": "```solidity\n130:     modifier onlyRole(bytes32 role_)  // <= FOUND\n\n```\n",
          "loc": [
            "[130](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L130-L130)"
          ]
        },
        {
          "content": "```solidity\n254:     modifier onlyExecutor()  // <= FOUND\n\n```\n",
          "loc": [
            "[254](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L254-L254)"
          ]
        },
        {
          "content": "```solidity\n262:     modifier onlyAdmin()  // <= FOUND\n\n```\n",
          "loc": [
            "[262](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L262-L262)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Using nested if to save gas",
      "description": "Using nested `if` statements instead of logical AND (`&&`) operators can potentially save gas in Solidity contracts. When a series of conditions are connected with `&&`, all conditions must be evaluated even if the first one fails. In contrast, nested `if` statements allow for short-circuiting; if the first condition fails, the rest are skipped, saving gas. This approach is more gas-efficient, especially when dealing with complex or gas-intensive conditions. However, it's crucial to balance gas savings with code readability and maintainability, ensuring that the code remains clear and easy to understand.",
      "gasSavings": 30,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n115:         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) { // <= FOUND\n116:             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n117:         }\n\n```\n",
          "loc": [
            "[115](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L115-L115)"
          ]
        },
        {
          "content": "```solidity\n324:         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) { // <= FOUND\n325:             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n326:         }\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L324-L324)"
          ]
        },
        {
          "content": "```solidity\n338:         if (hook != address(0) && isActive) { // <= FOUND\n339:             _forwardToHook(hook, msg.sender, to, value, data);\n340:         }\n\n```\n",
          "loc": [
            "[338](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L338-L338)"
          ]
        },
        {
          "content": "```solidity\n148:             if (!isLender && (!hasExpired)) { // <= FOUND\n149:                 revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n150:             }\n\n```\n",
          "loc": [
            "[148](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L148-L148)"
          ]
        },
        {
          "content": "```solidity\n255:                 if (orderType.isPayOrder() && !isRentalOver) { // <= FOUND\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n\n```\n",
          "loc": [
            "[255](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L255-L255)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Optimize Deployment Size by Fine-tuning IPFS Hash",
      "description": "Optimizing the deployment size of a smart contract is vital to minimize gas costs, and one way to achieve this is by fine-tuning the IPFS hash appended by the Solidity compiler as metadata. This metadata, consisting of 53 bytes, increases the gas required for contract deployment by approximately 10,600 gas due to bytecode costs, and additionally, up to 848 gas due to calldata costs, depending on the proportion of zero and non-zero bytes. Utilize the --no-cbor-metadata compiler flag to prevent the compiler from appending metadata. However, this approach has a drawback as it can complicate the contract verification process on block explorers like Etherscan, potentially reducing transparency.",
      "gasSavings": 116600,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n23: contract PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[23](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L23-L23)"
          ]
        },
        {
          "content": "```solidity\n37: contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase  // <= FOUND\n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n14: contract StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n66: contract Storage is Proxiable, Module, StorageBase  // <= FOUND\n\n```\n",
          "loc": [
            "[66](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L66-L66)"
          ]
        },
        {
          "content": "```solidity\n15: contract Admin is Policy  // <= FOUND\n\n```\n",
          "loc": [
            "[15](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L15-L15)"
          ]
        },
        {
          "content": "```solidity\n41: contract Create is Policy, Signer, Zone, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L41-L41)"
          ]
        },
        {
          "content": "```solidity\n22: contract Factory is Policy  // <= FOUND\n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n39: contract Guard is Policy, BaseGuard  // <= FOUND\n\n```\n",
          "loc": [
            "[39](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L39-L39)"
          ]
        },
        {
          "content": "```solidity\n34: contract Stop is Policy, Signer, Reclaimer, Accumulator  // <= FOUND\n\n```\n",
          "loc": [
            "[34](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L34-L34)"
          ]
        },
        {
          "content": "```solidity\n14: contract Create2Deployer  // <= FOUND\n\n```\n",
          "loc": [
            "[14](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L14-L14)"
          ]
        },
        {
          "content": "```solidity\n206: contract Kernel  // <= FOUND\n\n```\n",
          "loc": [
            "[206](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L206-L206)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Avoid Unnecessary Public Variables",
      "description": "Public state variables in Solidity automatically generate getter functions, increasing contract size and potentially leading to higher deployment and interaction costs. To optimize gas usage and contract efficiency, minimize the use of public variables unless external access is necessary. Instead, use internal or private visibility combined with explicit getter functions when required. This practice not only reduces contract size but also provides better control over data access and manipulation, enhancing security and readability. Prioritize lean, efficient contracts to ensure cost-effectiveness and better performance on the blockchain.",
      "gasSavings": 352000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n28: uint256 public fee; // <= FOUND\n\n```\n",
          "loc": [
            "[28](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L28-L28)"
          ]
        },
        {
          "content": "```solidity\n36: uint256 public totalSafes; // <= FOUND\n\n```\n",
          "loc": [
            "[36](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L36-L36)"
          ]
        },
        {
          "content": "```solidity\n28: Storage public STORE; // <= FOUND\n\n```\n",
          "loc": [
            "[28](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L28-L28)"
          ]
        },
        {
          "content": "```solidity\n54: PaymentEscrow public ESCRW; // <= FOUND\n\n```\n",
          "loc": [
            "[54](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L54-L54)"
          ]
        },
        {
          "content": "```solidity\n31: Stop public immutable stopPolicy; // <= FOUND\n\n```\n",
          "loc": [
            "[31](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L31-L31)"
          ]
        },
        {
          "content": "```solidity\n32: Guard public immutable guardPolicy; // <= FOUND\n\n```\n",
          "loc": [
            "[32](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L32-L32)"
          ]
        },
        {
          "content": "```solidity\n35: TokenCallbackHandler public immutable fallbackHandler; // <= FOUND\n\n```\n",
          "loc": [
            "[35](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L35-L35)"
          ]
        },
        {
          "content": "```solidity\n36: SafeProxyFactory public immutable safeProxyFactory; // <= FOUND\n\n```\n",
          "loc": [
            "[36](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L36-L36)"
          ]
        },
        {
          "content": "```solidity\n37: SafeL2 public immutable safeSingleton; // <= FOUND\n\n```\n",
          "loc": [
            "[37](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L37-L37)"
          ]
        },
        {
          "content": "```solidity\n208: address public executor; // <= FOUND\n\n```\n",
          "loc": [
            "[208](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L208-L208)"
          ]
        },
        {
          "content": "```solidity\n209: address public admin; // <= FOUND\n\n```\n",
          "loc": [
            "[209](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L209-L209)"
          ]
        },
        {
          "content": "```solidity\n212: Keycode[] public allKeycodes; // <= FOUND\n\n```\n",
          "loc": [
            "[212](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L212-L212)"
          ]
        },
        {
          "content": "```solidity\n225: Policy[] public activePolicies; // <= FOUND\n\n```\n",
          "loc": [
            "[225](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L225-L225)"
          ]
        },
        {
          "content": "```solidity\n25: Kernel public kernel; // <= FOUND\n\n```\n",
          "loc": [
            "[25](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L25-L25)"
          ]
        },
        {
          "content": "```solidity\n90: function KEYCODE() public pure virtual returns (Keycode); // <= FOUND\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L90-L90)"
          ]
        },
        {
          "content": "```solidity\n116: bool public isActive; // <= FOUND\n\n```\n",
          "loc": [
            "[116](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L116-L116)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Avoid emitting event on every iteration",
      "description": "Emitting events within a loop can cause significant gas consumption due to repeated I/O operations. Instead, accumulate changes in memory and emit a single event post-loop with aggregated data. This approach improves contract efficiency, reduces gas costs, and simplifies event tracking for event listeners.",
      "gasSavings": 375,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n566:        for (uint256 i = 0; i < reqLength; ++i) {\n567:             \n568:             Permissions memory request = requests_[i];\n569:             modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n570: \n571:             emit Events.PermissionsUpdated( // <= FOUND\n572:                 request.keycode,\n573:                 policy_,\n574:                 request.funcSelector,\n575:                 grant_\n576:             );\n577:         }\n\n```\n",
          "loc": [
            "[571](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L571-L571)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Inline modifiers used only once",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n254:     modifier onlyExecutor() { // <= FOUND\n255:         if (msg.sender != executor) revert Errors.Kernel_OnlyExecutor(msg.sender);\n256:         _;\n257:     }\n\n```\n",
          "loc": [
            "[254](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L254-L254)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use s.x = s.x + y instead of s.x += y for memory structs (same for -= etc)",
      "description": "In Solidity, optimizing gas usage is crucial, particularly for frequently executed operations. For memory structs, using explicit assignment (e.g., `s.x = s.x + y`) instead of shorthand operations (e.g., `s.x += y`) can result in a minor gas saving, around 100 gas. This difference arises from the way the Solidity compiler optimizes bytecode. While such savings might seem small, they can add up in contracts with high transaction volume. This optimization applies to other compound assignment operators like `-=` and `*=` as well. It's a subtle efficiency gain that developers can leverage, especially in complex contracts where every gas unit counts.",
      "gasSavings": 400,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n189:     function addRentals(\n190:         bytes32 orderHash,\n191:         RentalAssetUpdate[] memory rentalAssetUpdates\n192:     ) external onlyByProxy permissioned {\n193:         \n194:         orders[orderHash] = true;\n195: \n196:         \n197:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n198:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n199: \n200:             \n201:             rentedAssets[asset.rentalId] += asset.amount; // <= FOUND\n202:         }\n203:     }\n\n```\n",
          "loc": [
            "[189](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L189-L201)"
          ]
        },
        {
          "content": "```solidity\n215:     function _settlePayment(\n216:         Item[] calldata items,\n217:         OrderType orderType,\n218:         address lender,\n219:         address renter,\n220:         uint256 start,\n221:         uint256 end\n222:     ) internal {\n223:         \n224:         uint256 elapsedTime = block.timestamp - start;\n225:         uint256 totalTime = end - start;\n226: \n227:         \n228:         bool isRentalOver = elapsedTime >= totalTime;\n229: \n230:         \n231:         for (uint256 i = 0; i < items.length; ++i) {\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) { // <= FOUND\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount; // <= FOUND\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee; // <= FOUND\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount); // <= FOUND\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token, // <= FOUND\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token, // <= FOUND\n273:                         paymentAmount,\n274:                         item.settleTo, // <= FOUND\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n281:             }\n282:         }\n283:     }\n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L215-L274)"
          ]
        },
        {
          "content": "```solidity\n216:     function removeRentals(\n217:         bytes32 orderHash,\n218:         RentalAssetUpdate[] calldata rentalAssetUpdates\n219:     ) external onlyByProxy permissioned {\n220:         \n221:         if (!orders[orderHash]) {\n222:             revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n223:         } else {\n224:             \n225:             delete orders[orderHash];\n226:         }\n227: \n228:         \n229:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n230:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n231: \n232:             \n233:             rentedAssets[asset.rentalId] -= asset.amount; // <= FOUND\n234:         }\n235:     }\n\n```\n",
          "loc": [
            "[216](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L216-L233)"
          ]
        },
        {
          "content": "```solidity\n244:     function removeRentalsBatch(\n245:         bytes32[] calldata orderHashes,\n246:         RentalAssetUpdate[] calldata rentalAssetUpdates\n247:     ) external onlyByProxy permissioned {\n248:         \n249:         for (uint256 i = 0; i < orderHashes.length; ++i) {\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n258: \n259:         \n260:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n261:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n262: \n263:             \n264:             rentedAssets[asset.rentalId] -= asset.amount; // <= FOUND\n265:         }\n266:     }\n\n```\n",
          "loc": [
            "[244](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L244-L264)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "++X costs slightly less gas than X++ (same with --)",
      "description": "Move the ++/-- action to the left of the variable",
      "gasSavings": 20,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n273: \n274:                 \n275:                 totalRentals++; // <= FOUND\n\n```\n",
          "loc": [
            "[275](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L275-L275)"
          ]
        },
        {
          "content": "```solidity\n293: \n294:                 \n295:                 totalPayments++; // <= FOUND\n\n```\n",
          "loc": [
            "[295](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L295-L295)"
          ]
        },
        {
          "content": "```solidity\n293:                 totalPayments++; // <= FOUND\n\n```\n",
          "loc": [
            "[293](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L293-L293)"
          ]
        },
        {
          "content": "```solidity\n273:                 totalRentals++; // <= FOUND\n\n```\n",
          "loc": [
            "[273](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L273-L273)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Variable declared within iteration",
      "description": "Please elaborate and generalise the following with detail and  feel free to use your own knowledge and lmit ur words to 100 words please: ",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n231:        for (uint256 i = 0; i < items.length; ++i) { // <= FOUND\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) {\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType)); // <= FOUND\n280:                 }\n281:             }\n282:         }\n\n```\n",
          "loc": [
            "[231](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L231-L279)"
          ]
        },
        {
          "content": "```solidity\n475:        for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n476:             \n477:             target = hooks[i].target;\n478: \n479:             \n480:             if (!STORE.hookOnStart(target)) {\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             \n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             \n488:             offer = offerItems[itemIndex];\n489: \n490:             \n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             \n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 \n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) { // <= FOUND\n508:                 \n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 \n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n514:                 );\n515:             } catch (bytes memory revertData) {\n516:                 \n517:                 revert Errors.Shared_HookFailBytes(revertData);\n518:             }\n519:         }\n\n```\n",
          "loc": [
            "[475](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L475-L507)"
          ]
        },
        {
          "content": "```solidity\n205:        for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n206:             \n207:             target = hooks[i].target;\n208: \n209:             \n210:             if (!STORE.hookOnStop(target)) {\n211:                 revert Errors.Shared_DisabledHook(target);\n212:             }\n213: \n214:             \n215:             itemIndex = hooks[i].itemIndex;\n216: \n217:             \n218:             item = rentalItems[itemIndex];\n219: \n220:             \n221:             if (!item.isRental()) {\n222:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n223:             }\n224: \n225:             \n226:             try\n227:                 IHook(target).onStop(\n228:                     rentalWallet,\n229:                     item.token,\n230:                     item.identifier,\n231:                     item.amount,\n232:                     hooks[i].extraData\n233:                 )\n234:             {} catch Error(string memory revertReason) {\n235:                 \n236:                 revert Errors.Shared_HookFailString(revertReason);\n237:             } catch Panic(uint256 errorCode) { // <= FOUND\n238:                 \n239:                 string memory stringErrorCode = LibString.toString(errorCode);\n240: \n241:                 \n242:                 revert Errors.Shared_HookFailString(\n243:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n244:                 );\n245:             } catch (bytes memory revertData) {\n246:                 \n247:                 revert Errors.Shared_HookFailBytes(revertData);\n248:             }\n249:         }\n\n```\n",
          "loc": [
            "[205](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L205-L237)"
          ]
        },
        {
          "content": "```solidity\n324:        for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n325:             \n326:             _validateRentalCanBeStoped(\n327:                 orders[i].orderType,\n328:                 orders[i].endTimestamp,\n329:                 orders[i].lender\n330:             );\n331: \n332:             \n333:             for (uint256 j = 0; j < orders[i].items.length; ++j) {\n334:                 \n335:                 if (orders[i].items[j].isRental()) {\n336:                     _insert(\n337:                         rentalAssetUpdates,\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet),\n339:                         orders[i].items[j].amount\n340:                     );\n341:                 }\n342:             }\n343: \n344:             \n345:             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n346: \n347:             \n348:             if (orders[i].hooks.length > 0) {\n349:                 _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n350:             }\n351: \n352:             \n353:             _reclaimRentedItems(orders[i]);\n354: \n355:             \n356:             _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:         }\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L324)"
          ]
        },
        {
          "content": "```solidity\n592:        for (uint256 i; i < depcLength; ++i) { // <= FOUND\n593:             \n594:             Keycode keycode = dependencies[i];\n595:             Policy[] storage dependents = moduleDependents[keycode];\n596: \n597:             \n598:             uint256 origIndex = getDependentIndex[keycode][policy_];\n599: \n600:             \n601:             Policy lastPolicy = dependents[dependents.length - 1];\n602: \n603:             \n604:             dependents[origIndex] = lastPolicy;\n605: \n606:             \n607:             \n608:             dependents.pop();\n609: \n610:             \n611:             getDependentIndex[keycode][lastPolicy] = origIndex;\n612: \n613:             \n614:             delete getDependentIndex[keycode][policy_];\n615:         }\n\n```\n",
          "loc": [
            "[592](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L592-L592)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "The use of a logical AND in place of double if is slightly less gas efficient in instances where there isn't a corresponding else statement for the given if statement",
      "description": "Using a double if statement instead of logical AND (&&) can provide similar short-circuiting behavior whereas double if is slightly more efficient.",
      "gasSavings": 90,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n115: \n116:         \n117:         \n118:         \n119:         \n120:         \n121:         \n122:         \n123:         \n124:         \n125:         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) { // <= FOUND\n\n```\n",
          "loc": [
            "[125](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L125-L125)"
          ]
        },
        {
          "content": "```solidity\n255: \n256:                 \n257:                 if (orderType.isPayOrder() && !isRentalOver) { // <= FOUND\n\n```\n",
          "loc": [
            "[257](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L257-L257)"
          ]
        },
        {
          "content": "```solidity\n267:                 \n268:                 else if (\n269:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder() // <= FOUND\n270:                 ) {\n\n```\n",
          "loc": [
            "[269](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L269-L269)"
          ]
        },
        {
          "content": "```solidity\n324:         \n325:         \n326:         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) { // <= FOUND\n\n```\n",
          "loc": [
            "[326](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L326-L326)"
          ]
        },
        {
          "content": "```solidity\n338: \n339:         \n340:         if (hook != address(0) && isActive) { // <= FOUND\n\n```\n",
          "loc": [
            "[340](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L340-L340)"
          ]
        },
        {
          "content": "```solidity\n148:             \n149:             \n150:             if (!isLender && (!hasExpired)) { // <= FOUND\n\n```\n",
          "loc": [
            "[150](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L150-L150)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Calling .length in a for loop wastes gas",
      "description": "Rather than calling .length for an array in a for loop declaration, it is far more gas efficient to cache this length before and use that instead. This will prevent the array length from being called every loop iteration",
      "gasSavings": 1358,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n599: for (uint256 i = 0; i < items.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[599](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L599-L599)"
          ]
        },
        {
          "content": "```solidity\n324: for (uint256 i = 0; i < orders.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L324-L324)"
          ]
        },
        {
          "content": "```solidity\n197: for (uint256 i = 0; i < rentalAssetUpdates.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[197](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L197-L197)"
          ]
        },
        {
          "content": "```solidity\n249: for (uint256 i = 0; i < orderHashes.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[249](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L249-L249)"
          ]
        },
        {
          "content": "```solidity\n170: for (uint256 i = 0; i < order.items.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[170](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L170-L170)"
          ]
        },
        {
          "content": "```solidity\n225: for (uint256 i = 0; i < metadata.hooks.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[225](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L225-L225)"
          ]
        },
        {
          "content": "```solidity\n209: for (uint256 i; i < offers.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[209](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L209-L209)"
          ]
        },
        {
          "content": "```solidity\n337: for (uint256 i; i < considerations.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[337](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L337-L337)"
          ]
        },
        {
          "content": "```solidity\n475: for (uint256 i = 0; i < hooks.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[475](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L475-L475)"
          ]
        },
        {
          "content": "```solidity\n567: for (uint256 i; i < items.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[567](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L567-L567)"
          ]
        },
        {
          "content": "```solidity\n695: for (uint256 i = 0; i < executions.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[695](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L695-L695)"
          ]
        },
        {
          "content": "```solidity\n276: for (uint256 i; i < order.items.length; ++i)  // <= FOUND\n\n```\n",
          "loc": [
            "[276](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L276-L276)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Internal functions only used once can be inlined so save gas",
      "description": "If a internal function is only used once it doesn't make sense to modularise it unless the function which does call the function would be overly long and complex otherwise",
      "gasSavings": 960,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n88:     function _calculateFee(uint256 amount) internal view returns (uint256)  // <= FOUND\n\n```\n",
          "loc": [
            "[88](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L88-L88)"
          ]
        },
        {
          "content": "```solidity\n132:     function _calculatePaymentProRata( // <= FOUND\n133:         uint256 amount,\n134:         uint256 elapsedTime,\n135:         uint256 totalTime\n136:     ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) \n\n```\n",
          "loc": [
            "[132](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L132-L132)"
          ]
        },
        {
          "content": "```solidity\n159:     function _settlePaymentProRata( // <= FOUND\n160:         address token,\n161:         uint256 amount,\n162:         address lender,\n163:         address renter,\n164:         uint256 elapsedTime,\n165:         uint256 totalTime\n166:     ) internal \n\n```\n",
          "loc": [
            "[159](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L159-L159)"
          ]
        },
        {
          "content": "```solidity\n190:     function _settlePaymentInFull( // <= FOUND\n191:         address token,\n192:         uint256 amount,\n193:         SettleTo settleTo,\n194:         address lender,\n195:         address renter\n196:     ) internal \n\n```\n",
          "loc": [
            "[190](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L190-L190)"
          ]
        },
        {
          "content": "```solidity\n292:     function _decreaseDeposit(address token, uint256 amount) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[292](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L292-L292)"
          ]
        },
        {
          "content": "```solidity\n304:     function _increaseDeposit(address token, uint256 amount) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[304](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L304-L304)"
          ]
        },
        {
          "content": "```solidity\n76:     function _validateFulfiller( // <= FOUND\n77:         address intendedFulfiller,\n78:         address actualFulfiller\n79:     ) internal pure \n\n```\n",
          "loc": [
            "[76](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L76-L76)"
          ]
        },
        {
          "content": "```solidity\n94:     function _validateProtocolSignatureExpiration(uint256 expiration) internal view  // <= FOUND\n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L94-L94)"
          ]
        },
        {
          "content": "```solidity\n107:     function _recoverSignerFromPayload( // <= FOUND\n108:         bytes32 payloadHash,\n109:         bytes memory signature\n110:     ) internal view returns (address) \n\n```\n",
          "loc": [
            "[107](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L107-L107)"
          ]
        },
        {
          "content": "```solidity\n125:     function _deriveItemHash(Item memory item) internal view returns (bytes32)  // <= FOUND\n\n```\n",
          "loc": [
            "[125](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L125-L125)"
          ]
        },
        {
          "content": "```solidity\n204:     function _deriveOrderFulfillmentHash( // <= FOUND\n205:         OrderFulfillment memory fulfillment\n206:     ) internal view returns (bytes32) \n\n```\n",
          "loc": [
            "[204](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L204-L204)"
          ]
        },
        {
          "content": "```solidity\n273:     function _deriveDomainSeparator( // <= FOUND\n274:         bytes32 _eip712DomainTypeHash,\n275:         bytes32 _nameHash,\n276:         bytes32 _versionHash\n277:     ) internal view virtual returns (bytes32) \n\n```\n",
          "loc": [
            "[273](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L273-L273)"
          ]
        },
        {
          "content": "```solidity\n298:     function _deriveTypehashes() // <= FOUND\n299:         internal\n300:         view\n301:         returns (\n302:             bytes32 nameHash,\n303:             bytes32 versionHash,\n304:             bytes32 eip712DomainTypehash,\n305:             bytes32 domainSeparator\n306:         )\n307:     \n\n```\n",
          "loc": [
            "[298](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L298-L298)"
          ]
        },
        {
          "content": "```solidity\n339:     function _deriveRentalTypehashes() // <= FOUND\n340:         internal\n341:         pure\n342:         returns (\n343:             bytes32 itemTypeHash,\n344:             bytes32 hookTypeHash,\n345:             bytes32 rentalOrderTypeHash,\n346:             bytes32 orderFulfillmentTypeHash,\n347:             bytes32 orderMetadataTypeHash,\n348:             bytes32 rentPayloadTypeHash\n349:         )\n350:     \n\n```\n",
          "loc": [
            "[339](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L339-L339)"
          ]
        },
        {
          "content": "```solidity\n165:     function _emitRentalOrderStarted( // <= FOUND\n166:         RentalOrder memory order,\n167:         bytes32 orderHash,\n168:         bytes memory extraData\n169:     ) internal \n\n```\n",
          "loc": [
            "[165](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L165-L165)"
          ]
        },
        {
          "content": "```solidity\n195:     function _processBaseOrderOffer( // <= FOUND\n196:         Item[] memory rentalItems,\n197:         SpentItem[] memory offers,\n198:         uint256 startIndex\n199:     ) internal pure \n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L195-L195)"
          ]
        },
        {
          "content": "```solidity\n247:     function _processPayOrderOffer( // <= FOUND\n248:         Item[] memory rentalItems,\n249:         SpentItem[] memory offers,\n250:         uint256 startIndex\n251:     ) internal pure \n\n```\n",
          "loc": [
            "[247](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L247-L247)"
          ]
        },
        {
          "content": "```solidity\n326:     function _processBaseOrderConsideration( // <= FOUND\n327:         Item[] memory rentalItems,\n328:         ReceivedItem[] memory considerations,\n329:         uint256 startIndex\n330:     ) internal pure \n\n```\n",
          "loc": [
            "[326](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L326-L326)"
          ]
        },
        {
          "content": "```solidity\n367:     function _processPayeeOrderConsideration( // <= FOUND\n368:         ReceivedItem[] memory considerations\n369:     ) internal pure \n\n```\n",
          "loc": [
            "[367](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L367-L367)"
          ]
        },
        {
          "content": "```solidity\n411:     function _convertToItems( // <= FOUND\n412:         SpentItem[] memory offers,\n413:         ReceivedItem[] memory considerations,\n414:         OrderType orderType\n415:     ) internal pure returns (Item[] memory items) \n\n```\n",
          "loc": [
            "[411](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L411-L411)"
          ]
        },
        {
          "content": "```solidity\n464:     function _addHooks( // <= FOUND\n465:         Hook[] memory hooks,\n466:         SpentItem[] memory offerItems,\n467:         address rentalWallet\n468:     ) internal \n\n```\n",
          "loc": [
            "[464](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L464-L464)"
          ]
        },
        {
          "content": "```solidity\n530:     function _rentFromZone( // <= FOUND\n531:         RentPayload memory payload,\n532:         SeaportPayload memory seaportPayload\n533:     ) internal \n\n```\n",
          "loc": [
            "[530](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530-L530)"
          ]
        },
        {
          "content": "```solidity\n626:     function _isValidOrderMetadata( // <= FOUND\n627:         OrderMetadata memory metadata,\n628:         bytes32 zoneHash\n629:     ) internal view \n\n```\n",
          "loc": [
            "[626](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L626-L626)"
          ]
        },
        {
          "content": "```solidity\n647:     function _isValidSafeOwner(address owner, address safe) internal view  // <= FOUND\n\n```\n",
          "loc": [
            "[647](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L647-L647)"
          ]
        },
        {
          "content": "```solidity\n691:     function _executionInvariantChecks( // <= FOUND\n692:         ReceivedItem[] memory executions,\n693:         address expectedRentalSafe\n694:     ) internal view \n\n```\n",
          "loc": [
            "[691](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L691-L691)"
          ]
        },
        {
          "content": "```solidity\n356:     function _installModule(Module newModule_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[356](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L356-L356)"
          ]
        },
        {
          "content": "```solidity\n383:     function _upgradeModule(Module newModule_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[383](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L383-L383)"
          ]
        },
        {
          "content": "```solidity\n418:     function _activatePolicy(Policy policy_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[418](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L418-L418)"
          ]
        },
        {
          "content": "```solidity\n457:     function _deactivatePolicy(Policy policy_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[457](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L457-L457)"
          ]
        },
        {
          "content": "```solidity\n508:     function _migrateKernel(Kernel newKernel_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[508](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L508-L508)"
          ]
        },
        {
          "content": "```solidity\n540:     function _reconfigurePolicies(Keycode keycode_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[540](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L540-L540)"
          ]
        },
        {
          "content": "```solidity\n586:     function _pruneFromDependents(Policy policy_) internal  // <= FOUND\n\n```\n",
          "loc": [
            "[586](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L586-L586)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Constructors can be marked as payable to save deployment gas",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n79:     constructor(Kernel kernel_) Module(kernel_) {}\n\n```\n",
          "loc": [
            "[79](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L79-L79)"
          ]
        },
        {
          "content": "```solidity\n22:     constructor() {\n23:         original = address(this);\n24:     }\n\n```\n",
          "loc": [
            "[22](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L22-L22)"
          ]
        },
        {
          "content": "```solidity\n44:     constructor() {\n45:         \n46:         (\n47:             _NAME_HASH,\n48:             _VERSION_HASH,\n49:             _EIP_712_DOMAIN_TYPEHASH,\n50:             _DOMAIN_SEPARATOR\n51:         ) = _deriveTypehashes();\n52: \n53:         \n54:         (\n55:             _ITEM_TYPEHASH,\n56:             _HOOK_TYPEHASH,\n57:             _RENTAL_ORDER_TYPEHASH,\n58:             _ORDER_FULFILLMENT_TYPEHASH,\n59:             _ORDER_METADATA_TYPEHASH,\n60:             _RENT_PAYLOAD_TYPEHASH\n61:         ) = _deriveRentalTypehashes();\n62: \n63:         \n64:         _CHAIN_ID = block.chainid;\n65:     }\n\n```\n",
          "loc": [
            "[44](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L44-L44)"
          ]
        },
        {
          "content": "```solidity\n29:     constructor(Kernel kernel_) Policy(kernel_) {}\n\n```\n",
          "loc": [
            "[29](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L29-L29)"
          ]
        },
        {
          "content": "```solidity\n61:     constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n\n```\n",
          "loc": [
            "[61](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L61-L61)"
          ]
        },
        {
          "content": "```solidity\n49:     constructor(\n50:         Kernel kernel_,\n51:         Stop stopPolicy_,\n52:         Guard guardPolicy_,\n53:         TokenCallbackHandler fallbackHandler_,\n54:         SafeProxyFactory safeProxyFactory_,\n55:         SafeL2 safeSingleton_\n56:     ) Policy(kernel_) {\n57:         stopPolicy = stopPolicy_;\n58:         guardPolicy = guardPolicy_;\n59:         fallbackHandler = fallbackHandler_;\n60:         safeProxyFactory = safeProxyFactory_;\n61:         safeSingleton = safeSingleton_;\n62:     }\n\n```\n",
          "loc": [
            "[49](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L49-L49)"
          ]
        },
        {
          "content": "```solidity\n52:     constructor(Kernel kernel_) Policy(kernel_) Signer() Reclaimer() {}\n\n```\n",
          "loc": [
            "[52](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L52-L52)"
          ]
        },
        {
          "content": "```solidity\n33:     constructor(Kernel kernel_) {\n34:         kernel = kernel_;\n35:     }\n\n```\n",
          "loc": [
            "[33](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L33-L33)"
          ]
        },
        {
          "content": "```solidity\n71:     constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n```\n",
          "loc": [
            "[71](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L71-L71)"
          ]
        },
        {
          "content": "```solidity\n242:     constructor(address _executor, address _admin) {\n243:         executor = _executor;\n244:         admin = _admin;\n245:     }\n\n```\n",
          "loc": [
            "[242](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L242-L242)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly scratch space to build calldata for external calls",
      "description": "Using Solidity's assembly scratch space for constructing calldata in external calls with one or two arguments can be a gas-efficient approach. This method leverages the designated memory area (the first 64 bytes of memory) for temporary data storage during assembly operations. By directly writing arguments into this scratch space, it eliminates the need for additional memory allocation typically required for calldata preparation. This technique can lead to notable gas savings, especially in high-frequency or gas-sensitive operations. However, it requires careful implementation to avoid data corruption and should be used with a thorough understanding of low-level EVM operations and memory handling. Proper testing and validation are crucial when employing such optimizations.",
      "gasSavings": 22220,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n411: \n412:         \n413:         emit Events.FeeTaken(token, skimmedBalance); // <= FOUND\n\n```\n",
          "loc": [
            "[411](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L411-L413)"
          ]
        },
        {
          "content": "```solidity\n94: \n95:             \n96:             if (item.itemType == ItemType.ERC721) // <= FOUND\n97:                 _transferERC721(item, rentalOrder.lender); // <= FOUND\n\n```\n",
          "loc": [
            "[94](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L94-L97)"
          ]
        },
        {
          "content": "```solidity\n98: \n99:             \n100:             if (item.itemType == ItemType.ERC1155) // <= FOUND\n101:                 _transferERC1155(item, rentalOrder.lender); // <= FOUND\n\n```\n",
          "loc": [
            "[98](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L98-L101)"
          ]
        },
        {
          "content": "```solidity\n82:             revert Errors.SignerPackage_UnauthorizedFulfiller( // <= FOUND\n83:                 actualFulfiller, // <= FOUND\n84:                 intendedFulfiller\n85:             );\n\n```\n",
          "loc": [
            "[82](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L82-L83)"
          ]
        },
        {
          "content": "```solidity\n97:             revert Errors.SignerPackage_SignatureExpired(block.timestamp, expiration); // <= FOUND\n\n```\n",
          "loc": [
            "[97](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L97-L97)"
          ]
        },
        {
          "content": "```solidity\n103:         STORE.toggleWhitelistDelegate(delegate, isEnabled); // <= FOUND\n\n```\n",
          "loc": [
            "[103](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L103-L103)"
          ]
        },
        {
          "content": "```solidity\n117:         STORE.toggleWhitelistExtension(extension, isEnabled); // <= FOUND\n\n```\n",
          "loc": [
            "[117](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L117-L117)"
          ]
        },
        {
          "content": "```solidity\n165:         ESCRW.skim(token, to); // <= FOUND\n\n```\n",
          "loc": [
            "[165](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L165-L165)"
          ]
        },
        {
          "content": "```solidity\n312:             revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments); // <= FOUND\n\n```\n",
          "loc": [
            "[312](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L312-L312)"
          ]
        },
        {
          "content": "```solidity\n512: \n513:                 \n514:                 revert Errors.Shared_HookFailString( // <= FOUND\n515:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode) // <= FOUND\n516:                 );\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L512-L515)"
          ]
        },
        {
          "content": "```solidity\n570:                     \n571:                     _insert( // <= FOUND\n572:                         rentalAssetUpdates, // <= FOUND\n573:                         items[i].toRentalId(payload.fulfillment.recipient), // <= FOUND\n574:                         items[i].amount // <= FOUND\n575:                     );\n\n```\n",
          "loc": [
            "[570](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L570-L574)"
          ]
        },
        {
          "content": "```solidity\n595: \n596:             \n597:             STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates)); // <= FOUND\n\n```\n",
          "loc": [
            "[595](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L595-L597)"
          ]
        },
        {
          "content": "```solidity\n601:                     ESCRW.increaseDeposit(items[i].token, items[i].amount); // <= FOUND\n\n```\n",
          "loc": [
            "[601](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L601-L601)"
          ]
        },
        {
          "content": "```solidity\n655:             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe); // <= FOUND\n\n```\n",
          "loc": [
            "[655](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L655-L655)"
          ]
        },
        {
          "content": "```solidity\n766: \n767:         \n768:         if (!kernel.hasRole(signer, toRole(\"CREATE_SIGNER\"))) { // <= FOUND\n\n```\n",
          "loc": [
            "[766](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L766-L768)"
          ]
        },
        {
          "content": "```solidity\n144:             revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length); // <= FOUND\n\n```\n",
          "loc": [
            "[144](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L144-L144)"
          ]
        },
        {
          "content": "```solidity\n512: \n513:             \n514:             revert Errors.Shared_HookFailString( // <= FOUND\n515:                 string.concat(\"Hook reverted: Panic code \", stringErrorCode) // <= FOUND\n516:             );\n\n```\n",
          "loc": [
            "[512](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L512-L515)"
          ]
        },
        {
          "content": "```solidity\n363:         STORE.updateHookPath(to, hook); // <= FOUND\n\n```\n",
          "loc": [
            "[363](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L363-L363)"
          ]
        },
        {
          "content": "```solidity\n377:         STORE.updateHookStatus(hook, bitmap); // <= FOUND\n\n```\n",
          "loc": [
            "[377](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L377-L377)"
          ]
        },
        {
          "content": "```solidity\n113:         \n114:         emit Events.RentalOrderStopped(seaportOrderHash, stopper); // <= FOUND\n\n```\n",
          "loc": [
            "[113](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L113-L114)"
          ]
        },
        {
          "content": "```solidity\n141:                 revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[141](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L141-L141)"
          ]
        },
        {
          "content": "```solidity\n279:                 \n280:                 _insert( // <= FOUND\n281:                     rentalAssetUpdates, // <= FOUND\n282:                     order.items[i].toRentalId(order.rentalWallet), // <= FOUND\n283:                     order.items[i].amount // <= FOUND\n284:                 );\n\n```\n",
          "loc": [
            "[279](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L279-L283)"
          ]
        },
        {
          "content": "```solidity\n299: \n300:         \n301:         STORE.removeRentals( // <= FOUND\n302:             _deriveRentalOrderHash(order), // <= FOUND\n303:             _convertToStatic(rentalAssetUpdates) // <= FOUND\n304:         );\n\n```\n",
          "loc": [
            "[299](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L299-L303)"
          ]
        },
        {
          "content": "```solidity\n336:                     _insert( // <= FOUND\n337:                         rentalAssetUpdates, // <= FOUND\n338:                         orders[i].items[j].toRentalId(orders[i].rentalWallet), // <= FOUND\n339:                         orders[i].items[j].amount // <= FOUND\n340:                     );\n\n```\n",
          "loc": [
            "[336](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L336-L339)"
          ]
        },
        {
          "content": "```solidity\n363: \n364:         \n365:         STORE.removeRentalsBatch(orderHashes, _convertToStatic(rentalAssetUpdates)); // <= FOUND\n\n```\n",
          "loc": [
            "[363](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L363-L365)"
          ]
        },
        {
          "content": "```solidity\n38:             revert Errors.Create2Deployer_UnauthorizedSender(msg.sender, salt); // <= FOUND\n\n```\n",
          "loc": [
            "[38](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L38-L38)"
          ]
        },
        {
          "content": "```solidity\n46:             revert Errors.Create2Deployer_AlreadyDeployed(targetDeploymentAddress, salt); // <= FOUND\n\n```\n",
          "loc": [
            "[46](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L46-L46)"
          ]
        },
        {
          "content": "```solidity\n68:             revert Errors.Create2Deployer_MismatchedDeploymentAddress( // <= FOUND\n69:                 targetDeploymentAddress, // <= FOUND\n70:                 deploymentAddress\n71:             );\n\n```\n",
          "loc": [
            "[68](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L68-L69)"
          ]
        },
        {
          "content": "```solidity\n132:         if (!kernel.hasRole(msg.sender, role)) { // <= FOUND\n\n```\n",
          "loc": [
            "[132](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L132-L132)"
          ]
        },
        {
          "content": "```solidity\n301: \n302:         emit Events.ActionExecuted(action_, target_); // <= FOUND\n\n```\n",
          "loc": [
            "[301](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L301-L302)"
          ]
        },
        {
          "content": "```solidity\n312:         \n313:         if (hasRole[addr_][role_]) // <= FOUND\n314:             revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_); // <= FOUND\n\n```\n",
          "loc": [
            "[312](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L312-L314)"
          ]
        },
        {
          "content": "```solidity\n324: \n325:         emit Events.RoleGranted(role_, addr_); // <= FOUND\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L324-L325)"
          ]
        },
        {
          "content": "```solidity\n338: \n339:         \n340:         if (!hasRole[addr_][role_]) // <= FOUND\n341:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_); // <= FOUND\n\n```\n",
          "loc": [
            "[338](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L338-L341)"
          ]
        },
        {
          "content": "```solidity\n344: \n345:         emit Events.RoleRevoked(role_, addr_); // <= FOUND\n\n```\n",
          "loc": [
            "[344](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L344-L345)"
          ]
        },
        {
          "content": "```solidity\n76:         return Keycode.wrap(\"ESCRW\"); // <= FOUND\n\n```\n",
          "loc": [
            "[76](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L76-L76)"
          ]
        },
        {
          "content": "```solidity\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType)); // <= FOUND\n\n```\n",
          "loc": [
            "[279](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L279-L279)"
          ]
        },
        {
          "content": "```solidity\n402: \n403:         \n404:         uint256 trueBalance = IERC20(token).balanceOf(address(this)); // <= FOUND\n\n```\n",
          "loc": [
            "[402](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L402-L404)"
          ]
        },
        {
          "content": "```solidity\n104:         return Keycode.wrap(\"STORE\"); // <= FOUND\n\n```\n",
          "loc": [
            "[104](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L104-L104)"
          ]
        },
        {
          "content": "```solidity\n222:             revert Errors.StorageModule_OrderDoesNotExist(orderHash); // <= FOUND\n\n```\n",
          "loc": [
            "[222](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L222-L222)"
          ]
        },
        {
          "content": "```solidity\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]); // <= FOUND\n\n```\n",
          "loc": [
            "[252](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L252-L252)"
          ]
        },
        {
          "content": "```solidity\n296:         \n297:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to); // <= FOUND\n\n```\n",
          "loc": [
            "[296](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L296-L297)"
          ]
        },
        {
          "content": "```solidity\n299: \n300:         \n301:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n\n```\n",
          "loc": [
            "[299](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L299-L301)"
          ]
        },
        {
          "content": "```solidity\n299:         \n300:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n\n```\n",
          "loc": [
            "[299](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L299-L300)"
          ]
        },
        {
          "content": "```solidity\n38:         \n39:         bytes32 _rentalId = RentalId.unwrap(rentalId); // <= FOUND\n\n```\n",
          "loc": [
            "[38](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L38-L39)"
          ]
        },
        {
          "content": "```solidity\n81:             revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed( // <= FOUND\n82:                 rentalOrder.rentalWallet // <= FOUND\n83:             );\n\n```\n",
          "loc": [
            "[81](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L81-L82)"
          ]
        },
        {
          "content": "```solidity\n112:         \n113:         bytes32 digest = _DOMAIN_SEPARATOR.toTypedDataHash(payloadHash); // <= FOUND\n\n```\n",
          "loc": [
            "[112](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L112-L113)"
          ]
        },
        {
          "content": "```solidity\n115: \n116:         \n117:         return digest.recover(signature); // <= FOUND\n\n```\n",
          "loc": [
            "[115](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L115-L117)"
          ]
        },
        {
          "content": "```solidity\n127:         STORE.upgrade(newImplementation); // <= FOUND\n\n```\n",
          "loc": [
            "[127](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L127-L127)"
          ]
        },
        {
          "content": "```solidity\n147:         ESCRW.upgrade(newImplementation); // <= FOUND\n\n```\n",
          "loc": [
            "[147](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L147-L147)"
          ]
        },
        {
          "content": "```solidity\n174:         ESCRW.setFee(feeNumerator); // <= FOUND\n\n```\n",
          "loc": [
            "[174](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L174-L174)"
          ]
        },
        {
          "content": "```solidity\n223:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType); // <= FOUND\n\n```\n",
          "loc": [
            "[223](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L223-L223)"
          ]
        },
        {
          "content": "```solidity\n343:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported( // <= FOUND\n344:                     consideration.itemType // <= FOUND\n345:                 );\n\n```\n",
          "loc": [
            "[343](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L343-L344)"
          ]
        },
        {
          "content": "```solidity\n434:                 revert Errors.CreatePolicy_ConsiderationCountNonZero( // <= FOUND\n435:                     considerations.length // <= FOUND\n436:                 );\n\n```\n",
          "loc": [
            "[434](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L434-L435)"
          ]
        },
        {
          "content": "```solidity\n443:                 revert Errors.CreatePolicy_OfferCountNonZero(offers.length); // <= FOUND\n\n```\n",
          "loc": [
            "[443](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L443-L443)"
          ]
        },
        {
          "content": "```solidity\n451:             revert Errors.Shared_OrderTypeNotSupported(uint8(orderType)); // <= FOUND\n\n```\n",
          "loc": [
            "[451](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L451-L451)"
          ]
        },
        {
          "content": "```solidity\n480: \n481:             \n482:             if (!STORE.hookOnStart(target)) { // <= FOUND\n\n```\n",
          "loc": [
            "[480](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L480-L482)"
          ]
        },
        {
          "content": "```solidity\n481:                 revert Errors.Shared_DisabledHook(target); // <= FOUND\n\n```\n",
          "loc": [
            "[481](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L481-L481)"
          ]
        },
        {
          "content": "```solidity\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex); // <= FOUND\n\n```\n",
          "loc": [
            "[492](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L492-L492)"
          ]
        },
        {
          "content": "```solidity\n506:                 \n507:                 revert Errors.Shared_HookFailString(revertReason); // <= FOUND\n\n```\n",
          "loc": [
            "[506](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L506-L507)"
          ]
        },
        {
          "content": "```solidity\n509:                 \n510:                 string memory stringErrorCode = LibString.toString(errorCode); // <= FOUND\n\n```\n",
          "loc": [
            "[509](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L509-L510)"
          ]
        },
        {
          "content": "```solidity\n517:                 \n518:                 revert Errors.Shared_HookFailBytes(revertData); // <= FOUND\n\n```\n",
          "loc": [
            "[517](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L517-L518)"
          ]
        },
        {
          "content": "```solidity\n649:         \n650:         if (STORE.deployedSafes(safe) == 0) { // <= FOUND\n\n```\n",
          "loc": [
            "[649](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L649-L650)"
          ]
        },
        {
          "content": "```solidity\n650:             revert Errors.CreatePolicy_InvalidRentalSafe(safe); // <= FOUND\n\n```\n",
          "loc": [
            "[650](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L650-L650)"
          ]
        },
        {
          "content": "```solidity\n654: \n655:         \n656:         if (!ISafe(safe).isOwner(owner)) { // <= FOUND\n\n```\n",
          "loc": [
            "[654](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L654-L656)"
          ]
        },
        {
          "content": "```solidity\n709:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported( // <= FOUND\n710:                     execution.itemType // <= FOUND\n711:                 );\n\n```\n",
          "loc": [
            "[709](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L709-L710)"
          ]
        },
        {
          "content": "```solidity\n124:         \n125:         ISafe(address(this)).enableModule(_stopPolicy); // <= FOUND\n\n```\n",
          "loc": [
            "[124](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L124-L125)"
          ]
        },
        {
          "content": "```solidity\n127: \n128:         \n129:         ISafe(address(this)).setGuard(_guardPolicy); // <= FOUND\n\n```\n",
          "loc": [
            "[127](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L127-L129)"
          ]
        },
        {
          "content": "```solidity\n189: \n190:         \n191:         STORE.addRentalSafe(safe); // <= FOUND\n\n```\n",
          "loc": [
            "[189](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L189-L191)"
          ]
        },
        {
          "content": "```solidity\n134:             revert Errors.GuardPolicy_UnauthorizedSelector(selector); // <= FOUND\n\n```\n",
          "loc": [
            "[134](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L134-L134)"
          ]
        },
        {
          "content": "```solidity\n145:         \n146:         if (!STORE.whitelistedExtensions(extension)) { // <= FOUND\n\n```\n",
          "loc": [
            "[145](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L145-L146)"
          ]
        },
        {
          "content": "```solidity\n146:             revert Errors.GuardPolicy_UnauthorizedExtension(extension); // <= FOUND\n\n```\n",
          "loc": [
            "[146](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L146-L146)"
          ]
        },
        {
          "content": "```solidity\n506:             \n507:             revert Errors.Shared_HookFailString(revertReason); // <= FOUND\n\n```\n",
          "loc": [
            "[506](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L506-L507)"
          ]
        },
        {
          "content": "```solidity\n509:             \n510:             string memory stringErrorCode = LibString.toString(errorCode); // <= FOUND\n\n```\n",
          "loc": [
            "[509](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L509-L510)"
          ]
        },
        {
          "content": "```solidity\n517:             \n518:             revert Errors.Shared_HookFailBytes(revertData); // <= FOUND\n\n```\n",
          "loc": [
            "[517](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L517-L518)"
          ]
        },
        {
          "content": "```solidity\n271:                 revert Errors.GuardPolicy_UnauthorizedSelector( // <= FOUND\n272:                     shared_set_approval_for_all_selector\n273:                 );\n\n```\n",
          "loc": [
            "[271](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L271-L271)"
          ]
        },
        {
          "content": "```solidity\n281:                 revert Errors.GuardPolicy_UnauthorizedSelector( // <= FOUND\n282:                     e1155_safe_batch_transfer_from_selector\n283:                 );\n\n```\n",
          "loc": [
            "[281](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L281-L281)"
          ]
        },
        {
          "content": "```solidity\n288:                 revert Errors.GuardPolicy_UnauthorizedSelector( // <= FOUND\n289:                     gnosis_safe_set_guard_selector\n290:                 );\n\n```\n",
          "loc": [
            "[288](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L288-L288)"
          ]
        },
        {
          "content": "```solidity\n324:         \n325:         \n326:         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) { // <= FOUND\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L324-L326)"
          ]
        },
        {
          "content": "```solidity\n325:             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to); // <= FOUND\n\n```\n",
          "loc": [
            "[325](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L325-L325)"
          ]
        },
        {
          "content": "```solidity\n334: \n335:         \n336:         address hook = STORE.contractToHook(to); // <= FOUND\n\n```\n",
          "loc": [
            "[334](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L334-L336)"
          ]
        },
        {
          "content": "```solidity\n335:         bool isActive = STORE.hookOnTransaction(hook); // <= FOUND\n\n```\n",
          "loc": [
            "[335](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L335-L335)"
          ]
        },
        {
          "content": "```solidity\n210: \n211:             \n212:             if (!STORE.hookOnStop(target)) { // <= FOUND\n\n```\n",
          "loc": [
            "[210](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L210-L212)"
          ]
        },
        {
          "content": "```solidity\n296: \n297:         \n298:         ESCRW.settlePayment(order); // <= FOUND\n\n```\n",
          "loc": [
            "[296](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L296-L298)"
          ]
        },
        {
          "content": "```solidity\n360: \n361:         \n362:         ESCRW.settlePaymentBatch(orders); // <= FOUND\n\n```\n",
          "loc": [
            "[360](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L360-L362)"
          ]
        },
        {
          "content": "```solidity\n41:         if (msg.sender != address(kernel)) // <= FOUND\n42:             revert Errors.KernelAdapter_OnlyKernel(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[41](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L41-L42)"
          ]
        },
        {
          "content": "```solidity\n79:             revert Errors.Module_PolicyNotAuthorized(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[79](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L79-L79)"
          ]
        },
        {
          "content": "```solidity\n133:             revert Errors.Policy_OnlyRole(role); // <= FOUND\n\n```\n",
          "loc": [
            "[133](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L133-L133)"
          ]
        },
        {
          "content": "```solidity\n181:         address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_)); // <= FOUND\n\n```\n",
          "loc": [
            "[181](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L181-L181)"
          ]
        },
        {
          "content": "```solidity\n255:         if (msg.sender != executor) revert Errors.Kernel_OnlyExecutor(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[255](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L255-L255)"
          ]
        },
        {
          "content": "```solidity\n263:         if (msg.sender != admin) revert Errors.Kernel_OnlyAdmin(msg.sender); // <= FOUND\n\n```\n",
          "loc": [
            "[263](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L263-L263)"
          ]
        },
        {
          "content": "```solidity\n335:         \n336:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_); // <= FOUND\n\n```\n",
          "loc": [
            "[335](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L335-L336)"
          ]
        },
        {
          "content": "```solidity\n362:             revert Errors.Kernel_ModuleAlreadyInstalled(keycode); // <= FOUND\n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L362-L362)"
          ]
        },
        {
          "content": "```solidity\n372: \n373:         \n374:         allKeycodes.push(keycode); // <= FOUND\n\n```\n",
          "loc": [
            "[372](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L372-L374)"
          ]
        },
        {
          "content": "```solidity\n393:             revert Errors.Kernel_InvalidModuleUpgrade(keycode); // <= FOUND\n\n```\n",
          "loc": [
            "[393](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L393-L393)"
          ]
        },
        {
          "content": "```solidity\n428: \n429:         \n430:         activePolicies.push(policy_); // <= FOUND\n\n```\n",
          "loc": [
            "[428](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L428-L430)"
          ]
        },
        {
          "content": "```solidity\n442: \n443:             \n444:             moduleDependents[keycode].push(policy_); // <= FOUND\n\n```\n",
          "loc": [
            "[442](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L442-L444)"
          ]
        },
        {
          "content": "```solidity\n449: \n450:         \n451:         policy_.setActiveStatus(true); // <= FOUND\n\n```\n",
          "loc": [
            "[449](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L449-L451)"
          ]
        },
        {
          "content": "```solidity\n489: \n490:         \n491:         policy_.setActiveStatus(false); // <= FOUND\n\n```\n",
          "loc": [
            "[489](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L489-L491)"
          ]
        },
        {
          "content": "```solidity\n516:             \n517:             module.changeKernel(newKernel_); // <= FOUND\n\n```\n",
          "loc": [
            "[516](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L516-L517)"
          ]
        },
        {
          "content": "```solidity\n526: \n527:             \n528:             policy.setActiveStatus(false); // <= FOUND\n\n```\n",
          "loc": [
            "[526](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L526-L528)"
          ]
        },
        {
          "content": "```solidity\n529: \n530:             \n531:             policy.changeKernel(newKernel_); // <= FOUND\n\n```\n",
          "loc": [
            "[529](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L529-L531)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly scratch space to build calldata for event emits",
      "description": "Utilizing Solidity's assembly scratch space to build calldata for emitting events with just one or two arguments can optimize gas usage. The scratch space, a designated area in the first 64 bytes of memory, is ideal for temporary storage during assembly-level operations. By directly writing the event arguments into this area, developers can bypass the standard memory allocation process required for event emission. This approach results in gas savings, particularly for contracts where events are frequently emitted. However, such low-level optimization requires a deep understanding of Ethereum Virtual Machine (EVM) mechanics and careful coding to prevent data mishandling. Rigorous testing is essential to ensure the integrity and correct functionality of the contract.",
      "gasSavings": 1100,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n411: \n412:         \n413:         emit Events.FeeTaken(token, skimmedBalance); // <= FOUND\n\n```\n",
          "loc": [
            "[411](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L411-L413)"
          ]
        },
        {
          "content": "```solidity\n113:         \n114:         emit Events.RentalOrderStopped(seaportOrderHash, stopper); // <= FOUND\n\n```\n",
          "loc": [
            "[113](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L113-L114)"
          ]
        },
        {
          "content": "```solidity\n301: \n302:         emit Events.ActionExecuted(action_, target_); // <= FOUND\n\n```\n",
          "loc": [
            "[301](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L301-L302)"
          ]
        },
        {
          "content": "```solidity\n324: \n325:         emit Events.RoleGranted(role_, addr_); // <= FOUND\n\n```\n",
          "loc": [
            "[324](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L324-L325)"
          ]
        },
        {
          "content": "```solidity\n344: \n345:         emit Events.RoleRevoked(role_, addr_); // <= FOUND\n\n```\n",
          "loc": [
            "[344](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L344-L345)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider using solady's \"FixedPointMathLib\"",
      "description": "Using Solady's \"FixedPointMathLib\" for multiplication or division operations in Solidity can lead to significant gas savings. This library is designed to optimize fixed-point arithmetic operations, which are common in financial calculations involving tokens or currencies. By implementing more efficient algorithms and assembly optimizations, \"FixedPointMathLib\" minimizes the computational resources required for these operations. For contracts that frequently perform such calculations, integrating this library can reduce transaction costs, thereby enhancing overall performance and cost-effectiveness. However, developers must ensure compatibility with their existing codebase and thoroughly test for accuracy and expected behavior to avoid any unintended consequences.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n90:         \n91:         return (amount * fee) / 10000; // <= FOUND\n\n```\n",
          "loc": [
            "[91](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L91-L91)"
          ]
        },
        {
          "content": "```solidity\n142: \n143:         \n144:         \n145:         renterAmount = ((numerator / totalTime) + 500) / 1000; // <= FOUND\n\n```\n",
          "loc": [
            "[145](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L145-L145)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Same cast is done multiple times",
      "description": "Repeatedly casting the same variable to the same type within a function is redundant and can be optimized for better gas efficiency and code readability. Each unnecessary cast operation, while minor, adds to the gas cost and clutters the code. To optimize, the best practice is to perform the cast once and store the result in a temporary variable, which can then be used wherever needed in the function.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n138:     function deployRentalSafe(\n139:         address[] calldata owners,\n140:         uint256 threshold\n141:     ) external returns (address safe) {\n142:         \n143:         if (threshold == 0 || threshold > owners.length) {\n144:             revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length);\n145:         }\n146: \n147:         \n148:         \n149:         bytes memory data = abi.encodeCall(\n150:             Factory.initializeRentalSafe,\n151:             (address(stopPolicy), address(guardPolicy))\n152:         );\n153: \n154:         \n155:         bytes memory initializerPayload = abi.encodeCall(\n156:             ISafe.setup,\n157:             (\n158:                 \n159:                 owners,\n160:                 \n161:                 threshold,\n162:                 \n163:                 address(this),\n164:                 \n165:                 data,\n166:                 \n167:                 address(fallbackHandler),\n168:                 \n169:                 address(0), // <= FOUND 'address(0)'\n170:                 \n171:                 0,\n172:                 \n173:                 payable(address(0)) // <= FOUND 'address(0)'\n174:             )\n175:         );\n176: \n177:         \n178:         \n179:         \n180:         safe = address(\n181:             safeProxyFactory.createProxyWithNonce(\n182:                 address(safeSingleton),\n183:                 initializerPayload,\n184:                 uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))\n185:             )\n186:         );\n187: \n188:         \n189:         STORE.addRentalSafe(safe);\n190: \n191:         \n192:         emit Events.RentalSafeDeployment(safe, owners, threshold);\n193:     }\n\n```\n",
          "loc": [
            "[138](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138-L173)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Assigning to structs can be more efficient",
      "description": "Rather defining the struct in a single line, it is more efficient to declare an empty struct and then assign each struct element individually. This can net quite a large gas saving of 130 per instance.",
      "gasSavings": 650,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n195:     function _processBaseOrderOffer(\n196:         Item[] memory rentalItems,\n197:         SpentItem[] memory offers,\n198:         uint256 startIndex\n199:     ) internal pure {\n200:         \n201:         if (offers.length == 0) {\n202:             revert Errors.CreatePolicy_OfferCountZero();\n203:         }\n204: \n205:         \n206:         ItemType itemType;\n207: \n208:         \n209:         for (uint256 i; i < offers.length; ++i) {\n210:             \n211:             SpentItem memory offer = offers[i];\n212: \n213:             \n214:             if (offer.isERC721()) {\n215:                 itemType = ItemType.ERC721;\n216:             }\n217:             \n218:             else if (offer.isERC1155()) {\n219:                 itemType = ItemType.ERC1155;\n220:             }\n221:             \n222:             else {\n223:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n224:             }\n225: \n226:             \n227:             \n228:             rentalItems[i + startIndex] = Item({\n229:                 itemType: itemType,\n230:                 settleTo: SettleTo.LENDER,\n231:                 token: offer.token,\n232:                 amount: offer.amount,\n233:                 identifier: offer.identifier\n234:             });\n235:         }\n236:     }\n\n```\n",
          "loc": [
            "[195](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L195-L195)"
          ]
        },
        {
          "content": "```solidity\n247:     function _processPayOrderOffer(\n248:         Item[] memory rentalItems,\n249:         SpentItem[] memory offers,\n250:         uint256 startIndex\n251:     ) internal pure {\n252:         \n253:         uint256 totalRentals;\n254:         uint256 totalPayments;\n255: \n256:         \n257:         ItemType itemType;\n258:         SettleTo settleTo;\n259: \n260:         \n261:         for (uint256 i; i < offers.length; ++i) {\n262:             \n263:             SpentItem memory offer = offers[i];\n264: \n265:             \n266:             if (offer.isERC721()) {\n267:                 \n268:                 \n269:                 itemType = ItemType.ERC721;\n270:                 settleTo = SettleTo.LENDER;\n271: \n272:                 \n273:                 totalRentals++;\n274:             }\n275:             \n276:             else if (offer.isERC1155()) {\n277:                 \n278:                 \n279:                 itemType = ItemType.ERC1155;\n280:                 settleTo = SettleTo.LENDER;\n281: \n282:                 \n283:                 totalRentals++;\n284:             }\n285:             \n286:             else if (offer.isERC20()) {\n287:                 \n288:                 \n289:                 itemType = ItemType.ERC20;\n290:                 settleTo = SettleTo.RENTER;\n291: \n292:                 \n293:                 totalPayments++;\n294:             }\n295:             \n296:             else {\n297:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(offer.itemType);\n298:             }\n299: \n300:             \n301:             rentalItems[i + startIndex] = Item({\n302:                 itemType: itemType,\n303:                 settleTo: settleTo,\n304:                 token: offer.token,\n305:                 amount: offer.amount,\n306:                 identifier: offer.identifier\n307:             });\n308:         }\n309: \n310:         \n311:         if (totalRentals == 0 || totalPayments == 0) {\n312:             revert Errors.CreatePolicy_ItemCountZero(totalRentals, totalPayments);\n313:         }\n314:     }\n\n```\n",
          "loc": [
            "[247](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L247-L247)"
          ]
        },
        {
          "content": "```solidity\n326:     function _processBaseOrderConsideration(\n327:         Item[] memory rentalItems,\n328:         ReceivedItem[] memory considerations,\n329:         uint256 startIndex\n330:     ) internal pure {\n331:         \n332:         if (considerations.length == 0) {\n333:             revert Errors.CreatePolicy_ConsiderationCountZero();\n334:         }\n335: \n336:         \n337:         for (uint256 i; i < considerations.length; ++i) {\n338:             \n339:             ReceivedItem memory consideration = considerations[i];\n340: \n341:             \n342:             if (!consideration.isERC20()) {\n343:                 revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n344:                     consideration.itemType\n345:                 );\n346:             }\n347: \n348:             \n349:             \n350:             rentalItems[i + startIndex] = Item({\n351:                 itemType: ItemType.ERC20,\n352:                 settleTo: SettleTo.LENDER,\n353:                 token: consideration.token,\n354:                 amount: consideration.amount,\n355:                 identifier: consideration.identifier\n356:             });\n357:         }\n358:     }\n\n```\n",
          "loc": [
            "[326](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L326-L326)"
          ]
        },
        {
          "content": "```solidity\n530:     function _rentFromZone(\n531:         RentPayload memory payload,\n532:         SeaportPayload memory seaportPayload\n533:     ) internal {\n534:         \n535:         _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n536: \n537:         \n538:         _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n539: \n540:         \n541:         _executionInvariantChecks(\n542:             seaportPayload.totalExecutions,\n543:             payload.fulfillment.recipient\n544:         );\n545: \n546:         \n547:         \n548:         Item[] memory items = _convertToItems(\n549:             seaportPayload.offer,\n550:             seaportPayload.consideration,\n551:             payload.metadata.orderType\n552:         );\n553: \n554:         \n555:         \n556:         if (\n557:             payload.metadata.orderType.isBaseOrder() ||\n558:             payload.metadata.orderType.isPayOrder()\n559:         ) {\n560:             \n561:             \n562:             \n563:             bytes memory rentalAssetUpdates = new bytes(0);\n564: \n565:             \n566:             \n567:             for (uint256 i; i < items.length; ++i) {\n568:                 if (items[i].isRental()) {\n569:                     \n570:                     _insert(\n571:                         rentalAssetUpdates,\n572:                         items[i].toRentalId(payload.fulfillment.recipient),\n573:                         items[i].amount\n574:                     );\n575:                 }\n576:             }\n577: \n578:             \n579:             RentalOrder memory order = RentalOrder({\n580:                 seaportOrderHash: seaportPayload.orderHash,\n581:                 items: items,\n582:                 hooks: payload.metadata.hooks,\n583:                 orderType: payload.metadata.orderType,\n584:                 lender: seaportPayload.offerer,\n585:                 renter: payload.intendedFulfiller,\n586:                 rentalWallet: payload.fulfillment.recipient,\n587:                 startTimestamp: block.timestamp,\n588:                 endTimestamp: block.timestamp + payload.metadata.rentDuration\n589:             });\n590: \n591:             \n592:             bytes32 orderHash = _deriveRentalOrderHash(order);\n593: \n594:             \n595:             STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n596: \n597:             \n598:             \n599:             for (uint256 i = 0; i < items.length; ++i) {\n600:                 if (items[i].isERC20()) {\n601:                     ESCRW.increaseDeposit(items[i].token, items[i].amount);\n602:                 }\n603:             }\n604: \n605:             \n606:             if (payload.metadata.hooks.length > 0) {\n607:                 _addHooks(\n608:                     payload.metadata.hooks,\n609:                     seaportPayload.offer,\n610:                     payload.fulfillment.recipient\n611:                 );\n612:             }\n613: \n614:             \n615:             _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n616:         }\n617:     }\n\n```\n",
          "loc": [
            "[530](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530-L530)"
          ]
        },
        {
          "content": "```solidity\n733:     function validateOrder(\n734:         ZoneParameters calldata zoneParams\n735:     ) external override onlyRole(\"SEAPORT\") returns (bytes4 validOrderMagicValue) {\n736:         \n737:         (RentPayload memory payload, bytes memory signature) = abi.decode(\n738:             zoneParams.extraData,\n739:             (RentPayload, bytes)\n740:         );\n741: \n742:         \n743:         SeaportPayload memory seaportPayload = SeaportPayload({\n744:             orderHash: zoneParams.orderHash,\n745:             zoneHash: zoneParams.zoneHash,\n746:             offer: zoneParams.offer,\n747:             consideration: zoneParams.consideration,\n748:             totalExecutions: zoneParams.totalExecutions,\n749:             fulfiller: zoneParams.fulfiller,\n750:             offerer: zoneParams.offerer\n751:         });\n752: \n753:         \n754:         _validateProtocolSignatureExpiration(payload.expiration);\n755: \n756:         \n757:         _validateFulfiller(payload.intendedFulfiller, seaportPayload.fulfiller);\n758: \n759:         \n760:         address signer = _recoverSignerFromPayload(\n761:             _deriveRentPayloadHash(payload),\n762:             signature\n763:         );\n764: \n765:         \n766:         if (!kernel.hasRole(signer, toRole(\"CREATE_SIGNER\"))) {\n767:             revert Errors.CreatePolicy_UnauthorizedCreatePolicySigner();\n768:         }\n769: \n770:         \n771:         _rentFromZone(payload, seaportPayload);\n772: \n773:         \n774:         validOrderMagicValue = ZoneInterface.validateOrder.selector;\n775:     }\n\n```\n",
          "loc": [
            "[733](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733-L733)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Cache address(this) when used more than once",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n71:     function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n72:         \n73:         if (address(this) == original) { // <= FOUND\n74:             revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed();\n75:         }\n76: \n77:         \n78:         \n79:         \n80:         if (address(this) != rentalOrder.rentalWallet) { // <= FOUND\n81:             revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed(\n82:                 rentalOrder.rentalWallet\n83:             );\n84:         }\n85: \n86:         \n87:         uint256 itemCount = rentalOrder.items.length;\n88: \n89:         \n90:         for (uint256 i = 0; i < itemCount; ++i) {\n91:             Item memory item = rentalOrder.items[i];\n92: \n93:             \n94:             if (item.itemType == ItemType.ERC721)\n95:                 _transferERC721(item, rentalOrder.lender);\n96: \n97:             \n98:             if (item.itemType == ItemType.ERC1155)\n99:                 _transferERC1155(item, rentalOrder.lender);\n100:         }\n101:     }\n\n```\n",
          "loc": [
            "[71](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L71-L80)"
          ]
        },
        {
          "content": "```solidity\n122:     function initializeRentalSafe(address _stopPolicy, address _guardPolicy) external {\n123:         \n124:         ISafe(address(this)).enableModule(_stopPolicy); // <= FOUND\n125: \n126:         \n127:         ISafe(address(this)).setGuard(_guardPolicy); // <= FOUND\n128:     }\n\n```\n",
          "loc": [
            "[122](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L122-L127)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "bytes.concat() can be used in place of abi.encodePacked",
      "description": "Given concatenation is not going to be used for hashing bytes.concat is the preferred method to use as its more gas efficient when used with bytes variables",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n352:         \n353:         bytes memory itemTypeString = abi.encodePacked( // <= FOUND\n354:             \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n355:         );\n\n```\n",
          "loc": [
            "[352](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L352-L353)"
          ]
        },
        {
          "content": "```solidity\n357: \n358:         \n359:         bytes memory hookTypeString = abi.encodePacked( // <= FOUND\n360:             \"Hook(address target,uint256 itemIndex,bytes extraData)\" // <= FOUND\n361:         );\n\n```\n",
          "loc": [
            "[357](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L357-L360)"
          ]
        },
        {
          "content": "```solidity\n362: \n363:         \n364:         bytes memory rentalOrderTypeString = abi.encodePacked( // <= FOUND\n365:             \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\" // <= FOUND\n366:         );\n\n```\n",
          "loc": [
            "[362](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L362-L365)"
          ]
        },
        {
          "content": "```solidity\n379:             \n380:             bytes memory orderFulfillmentTypeString = abi.encodePacked( // <= FOUND\n381:                 \"OrderFulfillment(address recipient)\"\n382:             );\n\n```\n",
          "loc": [
            "[379](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L379-L380)"
          ]
        },
        {
          "content": "```solidity\n384: \n385:             \n386:             bytes memory orderMetadataTypeString = abi.encodePacked( // <= FOUND\n387:                 \"OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\" // <= FOUND\n388:             );\n\n```\n",
          "loc": [
            "[384](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L384-L387)"
          ]
        },
        {
          "content": "```solidity\n389: \n390:             \n391:             bytes memory rentPayloadTypeString = abi.encodePacked( // <= FOUND\n392:                 \"RentPayload(OrderFulfillment fulfillment,OrderMetadata metadata,uint256 expiration,address intendedFulfiller)\"\n393:             );\n\n```\n",
          "loc": [
            "[389](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L389-L391)"
          ]
        },
        {
          "content": "```solidity\n89:         \n90:         bytes32 addressHash = keccak256( // <= FOUND\n91:             abi.encodePacked(create2_ff, address(this), salt, keccak256(initCode)) // <= FOUND\n92:         );\n\n```\n",
          "loc": [
            "[89](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Create2Deployer.sol#L89-L91)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Empty functions should be removed to save gas",
      "description": "",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n353:     function checkAfterExecution(bytes32 txHash, bool success) external override {}\n\n```\n",
          "loc": [
            "[353](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L353-L353)"
          ]
        },
        {
          "content": "```solidity\n100:     function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L100-L100)"
          ]
        },
        {
          "content": "```solidity\n106:     function INIT() external virtual onlyKernel {}\n\n```\n",
          "loc": [
            "[106](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L106-L106)"
          ]
        },
        {
          "content": "```solidity\n148:     function configureDependencies()\n149:         external\n150:         virtual\n151:         onlyKernel\n152:         returns (Keycode[] memory dependencies)\n153:     {}\n\n```\n",
          "loc": [
            "[148](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L148-L148)"
          ]
        },
        {
          "content": "```solidity\n166:     function requestPermissions()\n167:         external\n168:         view\n169:         virtual\n170:         onlyKernel\n171:         returns (Permissions[] memory requests)\n172:     {}\n\n```\n",
          "loc": [
            "[166](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L166-L166)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Gas grief possible on unsafe external calls [EXP]",
      "description": "In Solidity, the use of low-level `call` methods can expose contracts to gas griefing attacks. The potential problem arises when the callee contract returns a large amount of data. This data is allocated in the memory of the calling contract, which pays for the gas costs. If the callee contract intentionally returns an enormous amount of data, the gas costs can skyrocket, causing the transaction to fail due to an Out of Gas error. Therefore, it's advisable to limit the use of `call` when interacting with untrusted contracts, or ensure that the callee's returned data size is capped or known in advance to prevent unexpected high gas costs.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n100:     function _safeTransfer(address token, address to, uint256 value) internal { // <= FOUND\n101:         \n102:         (bool success, bytes memory data) = token.call(\n103:             abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n104:         );\n105: \n106:         \n107:         \n108:         \n109:         \n110:         \n111:         \n112:         \n113:         \n114:         \n115:         if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n116:             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n117:         }\n118:     }\n\n```\n",
          "loc": [
            "[100](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L100-L100)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Function with two array parameter missing a length check [EXP]",
      "description": "In Solidity, if two array parameters are used within a function and one of their lengths is used as the for-loop range, it's essential to have a length check. If the arrays are not the same length, you could experience out-of-bounds errors or unintended behavior. This could happen if the function tries to access an index that doesn't exist in the shorter array.\n\nResolution: Always validate that the lengths of both arrays are the same before entering the loop. Add a require statement at the start of the function to check that both arrays are of equal length. This helps maintain the integrity of the function and prevents potential errors due to differing array lengths. This requirement ensures the function fails early if the arrays don't match, rather than failing unpredictably or silently during execution.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n464:     function _addHooks(\n465:         Hook[] memory hooks,\n466:         SpentItem[] memory offerItems,\n467:         address rentalWallet\n468:     ) internal {\n469:         \n470:         address target;\n471:         uint256 itemIndex;\n472:         SpentItem memory offer;\n473: \n474:         \n475:         for (uint256 i = 0; i < hooks.length; ++i) { // <= FOUND\n476:             \n477:             target = hooks[i].target;\n478: \n479:             \n480:             if (!STORE.hookOnStart(target)) {\n481:                 revert Errors.Shared_DisabledHook(target);\n482:             }\n483: \n484:             \n485:             itemIndex = hooks[i].itemIndex;\n486: \n487:             \n488:             offer = offerItems[itemIndex];\n489: \n490:             \n491:             if (!offer.isRental()) {\n492:                 revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:             }\n494: \n495:             \n496:             try\n497:                 IHook(target).onStart(\n498:                     rentalWallet,\n499:                     offer.token,\n500:                     offer.identifier,\n501:                     offer.amount,\n502:                     hooks[i].extraData\n503:                 )\n504:             {} catch Error(string memory revertReason) {\n505:                 \n506:                 revert Errors.Shared_HookFailString(revertReason);\n507:             } catch Panic(uint256 errorCode) {\n508:                 \n509:                 string memory stringErrorCode = LibString.toString(errorCode);\n510: \n511:                 \n512:                 revert Errors.Shared_HookFailString(\n513:                     string.concat(\"Hook reverted: Panic code \", stringErrorCode)\n\n```\n",
          "loc": [
            "[464](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L464-L475)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Code does not follow the best practice of check-effects-interaction [EXP]",
      "description": "The \"check-effects-interaction\" pattern is a best practice in smart contract development, emphasizing the order of operations in functions to prevent reentrancy attacks. Violations arise when a function interacts with external contracts before settling internal state changes or checks. This misordering can expose the contract to potential threats. To adhere to this pattern, first ensure all conditions or checks are satisfied, then update any internal states, and only after these steps, interact with external contracts or addresses. Rearranging operations to this recommended sequence bolsters contract security and aligns with established best practices in the Ethereum community.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n294:     function updateHookPath(address to, address hook) external onlyByProxy permissioned { // <= FOUND\n295:         \n296:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to); // <= FOUND\n297: \n298:         \n299:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n300: \n301:         \n302:         _contractToHook[to] = hook;\n303:     }\n\n```\n",
          "loc": [
            "[294](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L294-L299)"
          ]
        },
        {
          "content": "```solidity\n294:     function updateHookPath(address to, address hook) external onlyByProxy permissioned { // <= FOUND\n295:         \n296:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to); // <= FOUND\n297: \n298:         \n299:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n300: \n301:         \n302:         _contractToHook[to] = hook;\n303:     }\n\n```\n",
          "loc": [
            "[294](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L294-L299)"
          ]
        },
        {
          "content": "```solidity\n294:     function updateHookPath(address to, address hook) external onlyByProxy permissioned { // <= FOUND\n295:         \n296:         if (to.code.length == 0) revert Errors.StorageModule_NotContract(to); // <= FOUND\n297: \n298:         \n299:         if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook); // <= FOUND\n300: \n301:         \n302:         _contractToHook[to] = hook;\n303:     }\n\n```\n",
          "loc": [
            "[294](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L294-L299)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Events may be emitted out of order due to code not follow the best practice of check-effects-interaction [EXP]",
      "description": "The \"check-effects-interaction\" pattern also impacts event ordering. When a contract doesn't adhere to this pattern, events might be emitted in a sequence that doesn't reflect the actual logical flow of operations. This can cause confusion during event tracking, potentially leading to erroneous off-chain interpretations. To rectify this, always ensure that checks are performed first, state modifications come next, and interactions with external contracts or addresses are done last. This will ensure events are emitted in a logical, consistent manner, providing a clear and accurate chronological record of on-chain actions for off-chain systems and observers.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n397:     function skim(address token, address to) external onlyByProxy permissioned { // <= FOUND\n398:         \n399:         uint256 syncedBalance = balanceOf[token];\n400: \n401:         \n402:         uint256 trueBalance = IERC20(token).balanceOf(address(this)); // <= FOUND\n403: \n404:         \n405:         uint256 skimmedBalance = trueBalance - syncedBalance;\n406: \n407:         \n408:         _safeTransfer(token, to, skimmedBalance);\n409: \n410:         \n411:         emit Events.FeeTaken(token, skimmedBalance); // <= FOUND\n412:     }\n\n```\n",
          "loc": [
            "[397](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L397-L411)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Consider merging sequential for loops [EXP]",
      "description": "Merging multiple `for` loops within a function in Solidity can enhance efficiency and reduce gas costs, especially when they share a common iterating variable or perform related operations. By minimizing redundant iterations over the same data set, execution becomes more cost-effective. However, while merging can optimize gas usage and simplify logic, it may also increase code complexity. Therefore, careful balance between optimization and maintainability is essential, along with thorough testing to ensure the refactored code behaves as expected.\n",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n244:     function removeRentalsBatch(\n245:         bytes32[] calldata orderHashes,\n246:         RentalAssetUpdate[] calldata rentalAssetUpdates\n247:     ) external onlyByProxy permissioned {\n248:         \n249:         for (uint256 i = 0; i < orderHashes.length; ++i) { // <= FOUND\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n258: \n259:         \n260:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) { // <= FOUND\n261:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n262: \n263:             \n264:             rentedAssets[asset.rentalId] -= asset.amount;\n265:         }\n266:     }\n\n```\n",
          "loc": [
            "[244](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L244-L260)"
          ]
        },
        {
          "content": "```solidity\n244:     function removeRentalsBatch(\n245:         bytes32[] calldata orderHashes,\n246:         RentalAssetUpdate[] calldata rentalAssetUpdates\n247:     ) external onlyByProxy permissioned {\n248:         \n249:         for (uint256 i = 0; i < orderHashes.length; ++i) { // <= FOUND\n250:             \n251:             if (!orders[orderHashes[i]]) {\n252:                 revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:             } else {\n254:                 \n255:                 delete orders[orderHashes[i]];\n256:             }\n257:         }\n258: \n259:         \n260:         for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) { // <= FOUND\n261:             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n262: \n263:             \n264:             rentedAssets[asset.rentalId] -= asset.amount;\n265:         }\n266:     }\n\n```\n",
          "loc": [
            "[244](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L244-L260)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) { // <= FOUND\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) { // <= FOUND\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)),\n187:                     keccak256(abi.encodePacked(hookHashes)),\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[162](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L162-L176)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) { // <= FOUND\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) { // <= FOUND\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)),\n187:                     keccak256(abi.encodePacked(hookHashes)),\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[162](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L162-L176)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Avoid updating storage when the value hasn't changed [EXP]",
      "description": "",
      "gasSavings": 800,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n586:     function _pruneFromDependents(Policy policy_) internal { // <= FOUND\n587:         \n588:         Keycode[] memory dependencies = policy_.configureDependencies();\n589:         uint256 depcLength = dependencies.length;\n590: \n591:         \n592:         for (uint256 i; i < depcLength; ++i) {\n593:             \n594:             Keycode keycode = dependencies[i];\n595:             Policy[] storage dependents = moduleDependents[keycode]; // <= FOUND\n596: \n597:             \n598:             uint256 origIndex = getDependentIndex[keycode][policy_];\n599: \n600:             \n601:             Policy lastPolicy = dependents[dependents.length - 1];\n602: \n603:             \n604:             dependents[origIndex] = lastPolicy;\n605: \n606:             \n607:             \n608:             dependents.pop();\n609: \n610:             \n611:             getDependentIndex[keycode][lastPolicy] = origIndex;\n612: \n613:             \n614:             delete getDependentIndex[keycode][policy_];\n615:         }\n616:     }\n\n```\n",
          "loc": [
            "[586](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L586-L595)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Multiple accesses of the same mapping/array key/index should be cached [EXP]",
      "description": "Caching repeated accesses to the same mapping or array key/index in smart contracts can lead to significant gas savings. In Solidity, each read operation from storage (like accessing a value in a mapping or array using a key or index) costs gas. By storing the accessed value in a local variable and reusing it within the function, you avoid multiple expensive storage read operations. This practice is particularly beneficial in loops or functions with multiple reads of the same data. Implementing this caching approach enhances efficiency and reduces transaction costs, which is crucial for optimizing smart contract performance and user experience on the blockchain.",
      "gasSavings": 294,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n310:     function grantRole(Role role_, address addr_) public onlyAdmin {\n311:         \n312:         if (hasRole[addr_][role_]) // <= FOUND\n313:             revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_);\n314: \n315:         \n316:         ensureValidRole(role_);\n317: \n318:         \n319:         if (!isRole[role_]) isRole[role_] = true; // <= FOUND\n320: \n321:         \n322:         hasRole[addr_][role_] = true; // <= FOUND\n323: \n324:         emit Events.RoleGranted(role_, addr_);\n325:     }\n\n```\n",
          "loc": [
            "[310](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L310-L322)"
          ]
        },
        {
          "content": "```solidity\n310:     function grantRole(Role role_, address addr_) public onlyAdmin {\n311:         \n312:         if (hasRole[addr_][role_]) // <= FOUND\n313:             revert Errors.Kernel_AddressAlreadyHasRole(addr_, role_);\n314: \n315:         \n316:         ensureValidRole(role_);\n317: \n318:         \n319:         if (!isRole[role_]) isRole[role_] = true; // <= FOUND\n320: \n321:         \n322:         hasRole[addr_][role_] = true; // <= FOUND\n323: \n324:         emit Events.RoleGranted(role_, addr_);\n325:     }\n\n```\n",
          "loc": [
            "[310](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L310-L322)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin {\n334:         \n335:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_); // <= FOUND\n336: \n337:         \n338:         if (!hasRole[addr_][role_]) // <= FOUND\n339:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_);\n340: \n341:         \n342:         hasRole[addr_][role_] = false; // <= FOUND\n343: \n344:         emit Events.RoleRevoked(role_, addr_);\n345:     }\n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L342)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin {\n334:         \n335:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_); // <= FOUND\n336: \n337:         \n338:         if (!hasRole[addr_][role_]) // <= FOUND\n339:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_);\n340: \n341:         \n342:         hasRole[addr_][role_] = false; // <= FOUND\n343: \n344:         emit Events.RoleRevoked(role_, addr_);\n345:     }\n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L342)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin {\n334:         \n335:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_); // <= FOUND\n336: \n337:         \n338:         if (!hasRole[addr_][role_]) // <= FOUND\n339:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_);\n340: \n341:         \n342:         hasRole[addr_][role_] = false; // <= FOUND\n343: \n344:         emit Events.RoleRevoked(role_, addr_);\n345:     }\n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L342)"
          ]
        },
        {
          "content": "```solidity\n333:     function revokeRole(Role role_, address addr_) public onlyAdmin {\n334:         \n335:         if (!isRole[role_]) revert Errors.Kernel_RoleDoesNotExist(role_); // <= FOUND\n336: \n337:         \n338:         if (!hasRole[addr_][role_]) // <= FOUND\n339:             revert Errors.Kernel_AddressDoesNotHaveRole(addr_, role_);\n340: \n341:         \n342:         hasRole[addr_][role_] = false; // <= FOUND\n343: \n344:         emit Events.RoleRevoked(role_, addr_);\n345:     }\n\n```\n",
          "loc": [
            "[333](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L333-L342)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "The result of a function call should be cached rather than re-calling the function [EXP-0]",
      "description": "External calls in Solidity are costly in terms of gas usage. This can significantly impact contract efficiency and cost. Functions that make repetitive calls to fetch the same data from other contracts can cause unnecessary gas expenditure. To optimize this, it's advisable to store the returned value of these function calls in a state variable, essentially caching the data. This data can be updated at regular intervals or under specific conditions instead of fetching it from the external contract on every invocation. Be sure to analyze the frequency of data change in the external contract to balance data freshness with gas efficiency when implementing caching.",
      "gasSavings": 100,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n215:     function _settlePayment(\n216:         Item[] calldata items,\n217:         OrderType orderType,\n218:         address lender,\n219:         address renter,\n220:         uint256 start,\n221:         uint256 end\n222:     ) internal {\n223:         \n224:         uint256 elapsedTime = block.timestamp - start;\n225:         uint256 totalTime = end - start;\n226: \n227:         \n228:         bool isRentalOver = elapsedTime >= totalTime;\n229: \n230:         \n231:         for (uint256 i = 0; i < items.length; ++i) {\n232:             \n233:             Item memory item = items[i];\n234: \n235:             \n236:             if (item.isERC20()) {\n237:                 \n238:                 \n239:                 uint256 paymentAmount = item.amount;\n240: \n241:                 \n242:                 if (fee != 0) {\n243:                     \n244:                     uint256 paymentFee = _calculateFee(paymentAmount);\n245: \n246:                     \n247:                     paymentAmount -= paymentFee;\n248:                 }\n249: \n250:                 \n251:                 \n252:                 _decreaseDeposit(item.token, item.amount);\n253: \n254:                 \n255:                 if (orderType.isPayOrder() && !isRentalOver) { // <= FOUND\n256:                     \n257:                     _settlePaymentProRata(\n258:                         item.token,\n259:                         paymentAmount,\n260:                         lender,\n261:                         renter,\n262:                         elapsedTime,\n263:                         totalTime\n264:                     );\n265:                 }\n266:                 \n267:                 else if (\n268:                     (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder() // <= FOUND\n269:                 ) {\n270:                     \n271:                     _settlePaymentInFull(\n272:                         item.token,\n273:                         paymentAmount,\n274:                         item.settleTo,\n275:                         lender,\n276:                         renter\n277:                     );\n278:                 } else {\n279:                     revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                 }\n281:             }\n282:         }\n283:     }\n\n```\n",
          "loc": [
            "[215](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L215-L268)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Non constant/immutable state variables are missing a setter post deployment [EXP-1]",
      "description": "Non-constant or non-immutable state variables lacking a setter function can create inflexibility in contract operations. If there's no way to update these variables post-deployment, the contract might not adapt to changing conditions or requirements, which can be a significant drawback, especially in upgradable or long-lived contracts. To resolve this, implement setter functions guarded by appropriate access controls, like `onlyOwner` or similar modifiers, so that these variables can be updated as required while maintaining security. This enables smoother contract maintenance and feature upgrades.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n90: function KEYCODE() public pure virtual returns (Keycode);\n\n```\n",
          "loc": [
            "[90](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L90-L90)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "State variables used within a function more than once should be cached to save gas [EXP-1]",
      "description": "Cache such variables and perform operations on them, if operations include modifications to the state variable(s) then remember to equate the state variable to it's cached counterpart at the end",
      "gasSavings": 200,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n72:     function configureDependencies() // <= FOUND\n73:         external\n74:         override\n75:         onlyKernel\n76:         returns (Keycode[] memory dependencies)\n77:     {\n78:         dependencies = new Keycode[](2);\n79: \n80:         dependencies[0] = toKeycode(\"STORE\"); // <= FOUND\n81:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\"))); // <= FOUND\n82: \n83:         dependencies[1] = toKeycode(\"ESCRW\"); // <= FOUND\n84:         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\"))); // <= FOUND\n85:     }\n\n```\n",
          "loc": [
            "[72](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L72-L84)"
          ]
        },
        {
          "content": "```solidity\n72:     function configureDependencies() // <= FOUND\n73:         external\n74:         override\n75:         onlyKernel\n76:         returns (Keycode[] memory dependencies)\n77:     {\n78:         dependencies = new Keycode[](2);\n79: \n80:         dependencies[0] = toKeycode(\"STORE\"); // <= FOUND\n81:         STORE = Storage(getModuleAddress(toKeycode(\"STORE\"))); // <= FOUND\n82: \n83:         dependencies[1] = toKeycode(\"ESCRW\"); // <= FOUND\n84:         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\"))); // <= FOUND\n85:     }\n\n```\n",
          "loc": [
            "[72](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L72-L84)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Using abi.encodePacked can result in hash collision when used in hashing functions [EXP-2]",
      "description": "Consider using abi.encode as this pads data to 32 byte segments",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n298:     function _deriveTypehashes()\n299:         internal\n300:         view\n301:         returns (\n302:             bytes32 nameHash,\n303:             bytes32 versionHash,\n304:             bytes32 eip712DomainTypehash,\n305:             bytes32 domainSeparator\n306:         )\n307:     {\n308:         \n309:         nameHash = keccak256(bytes(_NAME));\n310: \n311:         \n312:         versionHash = keccak256(bytes(_VERSION));\n313: \n314:         \n315:         eip712DomainTypehash = keccak256(\n316:             abi.encodePacked( // <= FOUND\n317:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n318:             )\n319:         );\n320: \n321:         \n322:         domainSeparator = _deriveDomainSeparator(\n323:             eip712DomainTypehash,\n324:             nameHash,\n325:             versionHash\n326:         );\n327:     }\n\n```\n",
          "loc": [
            "[316](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L316-L316)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) {\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) {\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)), // <= FOUND\n187:                     keccak256(abi.encodePacked(hookHashes)), // <= FOUND\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[186](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L186-L187)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) {\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) {\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)), // <= FOUND\n187:                     keccak256(abi.encodePacked(hookHashes)), // <= FOUND\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[186](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L186-L187)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) {\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) {\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)), // <= FOUND\n187:                     keccak256(abi.encodePacked(hookHashes)), // <= FOUND\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[186](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L186-L187)"
          ]
        },
        {
          "content": "```solidity\n162:     function _deriveRentalOrderHash(\n163:         RentalOrder memory order\n164:     ) internal view returns (bytes32) {\n165:         \n166:         bytes32[] memory itemHashes = new bytes32[](order.items.length);\n167:         bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n168: \n169:         \n170:         for (uint256 i = 0; i < order.items.length; ++i) {\n171:             \n172:             itemHashes[i] = _deriveItemHash(order.items[i]);\n173:         }\n174: \n175:         \n176:         for (uint256 i = 0; i < order.hooks.length; ++i) {\n177:             \n178:             hookHashes[i] = _deriveHookHash(order.hooks[i]);\n179:         }\n180: \n181:         return\n182:             keccak256(\n183:                 abi.encode(\n184:                     _RENTAL_ORDER_TYPEHASH,\n185:                     order.seaportOrderHash,\n186:                     keccak256(abi.encodePacked(itemHashes)), // <= FOUND\n187:                     keccak256(abi.encodePacked(hookHashes)), // <= FOUND\n188:                     order.orderType,\n189:                     order.lender,\n190:                     order.renter,\n191:                     order.startTimestamp,\n192:                     order.endTimestamp\n193:                 )\n194:             );\n195:     }\n\n```\n",
          "loc": [
            "[186](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L186-L187)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Getting a bool return value does not confirm the existence of a function in an external call [EXP-2]",
      "description": "External calls to contracts using `address.call()` might return a boolean indicating success or failure. However, this boolean doesn't guarantee the existence of a called function. If a function isn't present, the call won't revert but will simply return `false`. This behavior might lead developers into mistakenly believing they're interacting with a legitimate or expected function, whereas it might not exist at allâ€”a scenario sometimes termed as \"phantom functions\". Resolution: Instead of solely relying on the boolean, further validate the contract you're interacting with, or use interfaces or abstract contracts to enforce the existence of expected functions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n     function _safeTransfer(address token, address to, uint256 value) internal { // <= FOUND\n           (bool success, bytes memory data) = token.call(  abi.encodeWithSelector(IERC20.transfer.selector, to, value) );\n                          if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n         }\n     }\n\n```\n",
          "loc": [
            ""
          ]
        },
        {
          "content": "```solidity\n     function _safeTransfer(address token, address to, uint256 value) internal { // <= FOUND\n           (bool success, bytes memory data) = token.call(  abi.encodeWithSelector(IERC20.transfer.selector, to, value) );\n                          if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {             revert Errors.PaymentEscrowModule_PaymentTransferFailed(token, to, value);\n         }\n     }\n\n```\n",
          "loc": [
            ""
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "No limits when setting fees [EXP-3]",
      "description": "When settings fees state variables, ensure there a require checks in place to prevent incorrect values from being set. This is particularly important when dealing with fee values as without checks fees can be set to 100%",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n380:     function setFee(uint256 feeNumerator) external onlyByProxy permissioned {\n381:         \n382:         if (feeNumerator > 10000) {\n383:             revert Errors.PaymentEscrow_InvalidFeeNumerator();\n384:         }\n385: \n386:         \n387:         fee = feeNumerator;\n388:     }\n\n```\n",
          "loc": [
            "[380](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L380-L380)"
          ]
        },
        {
          "content": "```solidity\n380:     function setFee(uint256 feeNumerator) external onlyByProxy permissioned {\n381:         \n382:         if (feeNumerator > 10000) {\n383:             revert Errors.PaymentEscrow_InvalidFeeNumerator();\n384:         }\n385: \n386:         \n387:         fee = feeNumerator;\n388:     }\n\n```\n",
          "loc": [
            "[380](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L380-L380)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Employ Explicit Casting to Bytes or Bytes32 for Enhanced Code Clarity and Meaning [EXP-3]",
      "description": "Smart contracts are complex entities, and clarity in their operations is fundamental to ensure that they function as intended. Casting a single argument instead of utilizing 'abi.encodePacked()' improves the transparency of the operation. It elucidates the intent of the code, reducing ambiguity and making it easier for auditors and developers to understand the codeâ€™s purpose. Such practices promote readability and maintainability, thus reducing the likelihood of errors and misunderstandings. Therefore, it's recommended to employ explicit casts for single arguments where possible, to increase the contract's comprehensibility and ensure a smoother review process.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n298:     function _deriveTypehashes()\n299:         internal\n300:         view\n301:         returns (\n302:             bytes32 nameHash,\n303:             bytes32 versionHash,\n304:             bytes32 eip712DomainTypehash,\n305:             bytes32 domainSeparator\n306:         )\n307:     {\n308:         \n309:         nameHash = keccak256(bytes(_NAME));\n310: \n311:         \n312:         versionHash = keccak256(bytes(_VERSION));\n313: \n314:         \n315:         eip712DomainTypehash = keccak256(\n316:             abi.encodePacked( // <= FOUND\n317:                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n318:             )\n319:         );\n320: \n321:         \n322:         domainSeparator = _deriveDomainSeparator(\n323:             eip712DomainTypehash,\n324:             nameHash,\n325:             versionHash\n326:         );\n327:     }\n\n```\n",
          "loc": [
            "[316](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L316-L316)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Use assembly to write address storage values [EXP-3]",
      "description": "Using assembly to directly write storage values can be a gas-saving optimization, bypassing some of Solidity's overhead. While this can lead to reduced transaction costs, it introduces risks, as assembly lacks the safety checks inherent in high-level Solidity. Incorrect use can lead to critical vulnerabilities. If opting for this gas optimization, ensure that: 1) The assembly block is well-documented, detailing its purpose and operation; 2) Thorough tests are written, covering all potential edge cases; and 3) A meticulous code review is conducted by developers experienced in Ethereum assembly to ensure there are no oversights or unintended consequences.",
      "gasSavings": 74,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n242:     constructor(address _executor, address _admin) { // <= FOUND\n243:         executor = _executor; // <= FOUND\n244:         admin = _admin; // <= FOUND\n245:     }\n\n```\n",
          "loc": [
            "[242](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/Kernel.sol#L242-L244)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Using bools for storage incurs overhead [EXP-3]",
      "description": "Using boolean variables (`bool`) for storage in Solidity can incur overhead due to the way data is packed in Ethereum's storage layout. A `bool` takes a full storage slot, even though it represents only a true or false value. This leads to inefficient usage of storage space and potentially higher gas costs. To resolve this issue, developers can use bit fields or uint8/uint256 to pack multiple boolean values into a single storage slot. By employing such optimization techniques, it's possible to save on storage space and reduce gas costs, making the contract more efficient.",
      "gasSavings": 560,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n20:     \n25:     mapping(bytes32 orderHash => bool isActive) public orders; // <= FOUND\n\n```\n",
          "loc": [
            "[20](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L20-L25)"
          ]
        },
        {
          "content": "```solidity\n20:     \n25:     mapping(bytes32 orderHash => bool isActive) public orders; // <= FOUND\n\n```\n",
          "loc": [
            "[20](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L20-L25)"
          ]
        },
        {
          "content": "```solidity\n20:     \n25:     mapping(bytes32 orderHash => bool isActive) public orders; // <= FOUND\n\n```\n",
          "loc": [
            "[20](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L20-L25)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Loss of precision",
      "description": "Dividing by large integers in Solidity may cause a loss of precision due to the inherent limitations of fixed-point arithmetic in the Ethereum Virtual Machine (EVM). Solidity, like most programming languages, uses integer division, which truncates any decimal portion of the result. When dividing by large integers, the quotient can have a significant decimal component, but this is discarded, leading to an imprecise outcome. This loss of precision can have unintended consequences in smart contracts, especially in financial applications where accurate calculations are crucial. To mitigate this issue, developers should use appropriate scaling factors or specialized libraries that provide safe and precise arithmetic operations.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n132:     function _calculatePaymentProRata(\n133:         uint256 amount,\n134:         uint256 elapsedTime,\n135:         uint256 totalTime\n136:     ) internal pure returns (uint256 renterAmount, uint256 lenderAmount) {\n137:         \n138:         uint256 numerator = (amount * elapsedTime) * 1000;\n139: \n140:         \n141:         \n142:         renterAmount = ((numerator / totalTime) + 500) / 1000; // <= FOUND\n143: \n144:         \n145:         lenderAmount = amount - renterAmount;\n146:     }\n\n```\n",
          "loc": [
            "[142](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L142-L142)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "For loops in public or external functions should be avoided due to high gas costs and possible DOS",
      "description": "In Solidity, for loops can potentially cause Denial of Service (DoS) attacks if not handled carefully. DoS attacks can occur when an attacker intentionally exploits the gas cost of a function, causing it to run out of gas or making it too expensive for other users to call. Below are some scenarios where for loops can lead to DoS attacks: Nested for loops can become exceptionally gas expensive and should be used sparingly",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\n337:     function settlePaymentBatch(\n338:         RentalOrder[] calldata orders\n339:     ) external onlyByProxy permissioned {\n340:         \n341:         for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n342:             \n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n352:     }\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L341-L341)"
          ]
        },
        {
          "content": "```solidity\n337:     function settlePaymentBatch(\n338:         RentalOrder[] calldata orders\n339:     ) external onlyByProxy permissioned {\n340:         \n341:         for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n342:             \n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n352:     }\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L341-L341)"
          ]
        },
        {
          "content": "```solidity\n337:     function settlePaymentBatch(\n338:         RentalOrder[] calldata orders\n339:     ) external onlyByProxy permissioned {\n340:         \n341:         for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n342:             \n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n352:     }\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L341-L341)"
          ]
        },
        {
          "content": "```solidity\n337:     function settlePaymentBatch(\n338:         RentalOrder[] calldata orders\n339:     ) external onlyByProxy permissioned {\n340:         \n341:         for (uint256 i = 0; i < orders.length; ++i) { // <= FOUND\n342:             \n343:             _settlePayment(\n344:                 orders[i].items,\n345:                 orders[i].orderType,\n346:                 orders[i].lender,\n347:                 orders[i].renter,\n348:                 orders[i].startTimestamp,\n349:                 orders[i].endTimestamp\n350:             );\n351:         }\n352:     }\n\n```\n",
          "loc": [
            "[341](https://github.com/re-nft/smart-contracts/tree/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L341-L341)"
          ]
        }
      ]
    }
  ],
  "createdAt": "2024-01-08T20:51:43.337Z",
  "updatedAt": "2024-01-08T20:51:44.126Z"
}